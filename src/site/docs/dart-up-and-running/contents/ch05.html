---
layout: book
title: "Chapter 5. Walkthrough: Dart Chat from Dart: Up and Running"
description: "Read Chapter 5. Walkthrough: Dart Chat of Dart: Up and Running, published by O'Reilly."
---
<div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 5. Walkthrough: Dart Chat</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch04-summary.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="colophon.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="ch05"></a>Chapter 5. Walkthrough: Dart Chat</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="ch05.html#ch05-how-to-run">How to Run Dart Chat</a></span></dt><dt><span class="sect1"><a href="ch05.html#ch05-how-it-works">How Dart Chat Works</a></span></dt><dt><span class="sect1"><a href="ch05.html#ch05-client-html-code">The Client’s HTML Code</a></span></dt><dt><span class="sect1"><a href="ch05.html#ch05-client-dart-code">The Client’s Dart Code</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch05.html#ch05-find-element">Finding DOM Elements</a></span></dt><dt><span class="sect2"><a href="ch05.html#ch05-wrap-element">Wrapping DOM Elements</a></span></dt><dt><span class="sect2"><a href="ch05.html#ch05-update-element">Updating DOM Elements</a></span></dt><dt><span class="sect2"><a href="ch05.html#ch05-dart-json">Encoding and Decoding Messages</a></span></dt><dt><span class="sect2"><a href="ch05.html#ch05-web-sockets">Communicating with WebSockets</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch05.html#ch05-server">The Server’s Code</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch05.html#ch05-server-static-files">Serving Static Files</a></span></dt><dt><span class="sect2"><a href="ch05.html#ch05-server-web-sockets">Managing WebSocket Connections</a></span></dt><dt><span class="sect2"><a href="ch05.html#ch05-server-log">Logging Messages to a File</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch05.html#ch05-what-next">What Next?</a></span></dt></dl></div><p>This chapter points out some of the useful and fun features of Dart
  that we used to build Dart Chat, a client-server app. If you’d like
  step-by-step instructions on building Dart Chat, you might be interested in
  our <a class="ulink" href="https://www.dartlang.org/slides/2012/06/io12/Bullseye-Your-first-Dart-app-Codelab-GoogleIO2012.pdf" target="_top">code
  lab.</a></p><p><a class="xref" href="ch05.html#DartChat-screenshot" title="Figure 5.1. Multiple chat clients can use the chat server to talk">Figure 5.1, “Multiple chat clients can use the chat server to talk”</a> shows the chat client executing
  in a Dartium window. Each copy of the chat client can send messages to the
  chat server, which forwards those messages to the other chat clients.</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ch05-how-to-run"></a>How to Run Dart Chat</h2></div></div></div><p>The easiest way to run the Dart Chat client and server apps is to
    open them in Dart Editor.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Download the <a class="ulink" href="https://github.com/dart-lang/io-2012-dart-code-lab" target="_top">Dart Chat
        source</a> code from GitHub.</p></li><li class="listitem"><p>In Dart Editor, use <span class="bold"><strong>File &gt; Open
        Folder...</strong></span>, to open the <span class="bold"><strong>finished</strong></span> directory of the Dart Chat source
        code.</p></li><li class="listitem"><p>Select <code class="literal">chat-server.dart</code>, and
        then click the Run button <span class="inlinemediaobject"><img src="figs/web/run.png" width="11"></span>. A view named chat-server appears in Dart
        Editor, displaying debugging output for the server.</p></li><li class="listitem"><p>Select <code class="literal">client/chat-client.dart</code>, and then click the
        Run button <span class="inlinemediaobject"><img src="figs/web/run.png" width="11"></span>. Dartium launches, if necessary, and displays a
        Dart Chat tab.</p></li><li class="listitem"><p>To create another copy of the chat client, go to the Dart Chat
        tab in Dartium. Right-click the tab, and choose <span class="bold"><strong>Duplicate</strong></span>.</p></li></ol></div><div class="figure-float"><div class="figure"><a name="DartChat-screenshot"></a><p class="title"><b>Figure 5.1. Multiple chat clients can use the chat server to talk</b></p><div class="figure-contents"><div class="mediaobject"><img src="figs/web/daur_0501.png" alt="Multiple chat clients can use the chat server to talk"></div></div></div><br class="figure-break"></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ch05-how-it-works"></a>How Dart Chat Works</h2></div></div></div><p>The chat server and client are simple. The chat server is an HTTP
    server that provides a WebSocket. The chat client uses that WebSocket for
    a bi-directional communication channel with the server. The client sends
    chat messages to the server over the WebSocket, and the server relays those
    messages to all other connected clients.</p><p>As <a class="xref" href="ch05.html#web-socket-connections" title="Figure 5.2. Chat clients connect to a web socket created by the chat server">Figure 5.2, “Chat clients connect to a web socket created by the chat
      server”</a> shows, the server
    starts things off by listening for requests to <code class="literal">ws://127.0.0.1:1337/ws</code>. Chat clients then
    connect to that URL.</p><div class="figure"><a name="web-socket-connections"></a><p class="title"><b>Figure 5.2. Chat clients connect to a web socket created by the chat
      server</b></p><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="315"><tr><td><img src="figs/web/daur_0502.png" width="315" alt="Chat clients connect to a web socket created by the chat server"></td></tr></table></div></div></div><br class="figure-break"><p>The real communication between client and server happens when the
    user enters a message. As <a class="xref" href="ch05.html#web-socket-messages" title="Figure 5.3. A chat client uses the server to send a message to other chat clients">Figure 5.3, “A chat client uses the server to send a message to other chat
      clients”</a> shows,
    the chat client sends a JSON-encoded version of the message to the server.
    The server then forwards the message to every client except the one that
    sent it.</p><div class="figure"><a name="web-socket-messages"></a><p class="title"><b>Figure 5.3. A chat client uses the server to send a message to other chat
      clients</b></p><div class="figure-contents"><div class="mediaobject"><img src="figs/web/daur_0503.png" alt="A chat client uses the server to send a message to other chat clients"></div></div></div><br class="figure-break"><p>The chat server implements an HTTP server to listen for WebSocket
    requests. The HTTP server can also serve static files from the client
    directory—for example, http://127.0.0.1:1337/chat-log.txt shows the file
    that’s at client/chat-log.txt.</p><p>The client code is split between HTML (page structure), CSS (page
    look), and JavaScript (logic and behavior). That’s typical of web
    clients.</p><p>The twist is that this client’s JavaScript code is produced from
    Dart code, thanks to the dart2js compiler. Any modern browser can run this
    JavaScript code. Dartium (and any other browsers that support Dart) can
    run either the JavaScript code or the original Dart code.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ch05-client-html-code"></a>The Client’s HTML Code</h2></div></div></div><p>The main elements in the client UI are two text fields (with the IDs
    “chat-username” and “chat-message”) and a status area (ID:
    “chat-display”).</p><pre class="programlisting">&lt;!-- In client/index.html: --&gt;
&lt;textarea id="chat-display" rows="10" disabled&gt;&lt;/textarea&gt;
...
&lt;input id="chat-username" name="chat-username" type="text"&gt;
...
&lt;input id="chat-message" name="chat-message" type="text" disabled 
    value="enter message..."&gt;</pre><p>Near the bottom of client/index.html, a couple of &lt;script&gt;
    tags tell the browser to execute the client’s Dart or JavaScript
    code:</p><pre class="programlisting">&lt;script type="application/dart" src="chat-client.dart"&gt;&lt;/script&gt;
&lt;script src="dart.js"&gt;&lt;/script&gt;</pre><p>The first line works in browsers that have an embedded Dart VM and
    so can execute Dart code; currently, only Dartium qualifies. The second
    line is important for every other browser. It executes dart.js, which is a
    standard script that converts all Dart &lt;script&gt; tags to use
    foo.dart.js instead of foo.dart, with the assumption that foo.dart.js is a
    JavaScript version of foo.dart. For non-Dartium browsers, dart.js changes
    the first &lt;script&gt; tag to the following:</p><pre class="programlisting">&lt;!-- Inserted by dart.js for non-Dartium browsers --&gt;
&lt;script src="chat-client.dart.js"&gt;&lt;/script&gt;</pre><p>The script contents run when the browser has loaded the HTML and
    constructed its DOM (document object model).</p><p>You can get dart.js with the <a class="ulink" href="http://pub.dartlang.org/packages/browser" target="_top">browser package from
    pub,</a> or you can get it <a class="ulink" href="http://dart.googlecode.com/svn/trunk/dart/client/dart.js" target="_top">directly
    from the Dart project.</a> See <a class="xref" href="ch04-tools-dart2js.html" title="dart2js: The Dart-to-JavaScript Compiler">the section called “dart2js: The Dart-to-JavaScript Compiler”</a>
    for more information about compiling Dart code into its JavaScript
    equivalent.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ch05-client-dart-code"></a>The Client’s Dart Code</h2></div></div></div><p>Dart code (client/chat-client.dart) provides the client’s logic,
    using the DOM to interact with UI elements. For example, the client’s Dart
    code uses the DOM to find the text area where the client displays
    messages.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch05-find-element"></a>Finding DOM Elements</h3></div></div></div><p>The client app uses dart:html’s top-level
      <code class="literal">query()</code> method to get the client’s UI elements from
      the DOM.</p><pre class="programlisting">// In client/chat-client.dart:
import 'dart:html';
//...
TextAreaElement chatElem = query('#chat-display');
InputElement usernameElem = query('#chat-username');
InputElement messageElem = query('#chat-message');</pre><p>The <code class="literal">query()</code> method uses a selector string that
      identifies an element in the DOM. See <a class="xref" href="ch03.html#ch03-finding-elements" title="Finding elements">the section called “Finding elements”</a> for more about selectors.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch05-wrap-element"></a>Wrapping DOM Elements</h3></div></div></div><p>Rather than always dealing with DOM APIs, the chat client wraps
      the elements in Dart objects:</p><pre class="programlisting">chatWindow = new ChatWindow(chatElem);
usernameInput = new UsernameInput(usernameElem);
messageInput = new MessageInput(messageElem);</pre><p>ChatWindow, UsernameInput, and MessageInput are custom classes
      that extend another custom class called View. These Views effectively
      separate the DOM manipulation from the application logic.</p><p>Because Dart has real classes and inheritance, it’s simple to
      express the relationship that ChatWindow is-a View. Here’s the complete
      code for UsernameInput:</p><pre class="programlisting">class UsernameInput extends View&lt;InputElement&gt; {
  UsernameInput(InputElement elem) : super(elem);

  bind() { // Called by the View constructor.
    elem.on.change.add((e) =&gt; _onUsernameChange());
  }

  _onUsernameChange() {
    if (!elem.value.isEmpty) {
      messageInput.enable();
    } else {
      messageInput.disable();
    }
  }

  String get username =&gt; elem.value;
}</pre><p>To get the string that’s in the chat-username field, the client
      app uses the <code class="literal">username</code> getter of a
      UsernameInput object. For example:</p><pre class="programlisting">chatWindow.displayMessage(message, usernameInput.username);</pre><p>Notice how the code uses generics (View&lt;InputElement&gt;) to
      specify what kind of element the View class can encapsulate. In the
      preceding example, the UsernameInput wraps an <a class="ulink" href="http://api.dartlang.org/dart_html/InputElement.html" target="_top">InputElement.</a>
      Expressing this gives tools information that they can use to identify
      bugs or improve code completion.</p><p>Wrapping elements is a technique you can use as you develop a
      simple app that might evolve into a larger app. As the app grows, you
      might change it to use a real <a class="ulink" href="http://en.wikipedia.org/wiki/Model-view-controller" target="_top">model-view-controller
      (MVC) architecture.</a></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>We expect the Dart project to provide an MVC-type framework for
        clients.</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch05-update-element"></a>Updating DOM Elements</h3></div></div></div><p>The <code class="literal">bind()</code> method sets up the event handlers,
      which bind events from the DOM to logic in the Dart objects. For
      example, in UsernameInput, the <code class="literal">_onUsernameChange()</code>
      method is called any time the text in the input element changes.</p><p>To display messages in the chat window, the ChatWindow class adds
      the message to the text node of the text area.</p><pre class="programlisting">class ChatWindow extends View&lt;TextAreaElement&gt; {
  ChatWindow(TextAreaElement elem) : super(elem);
  
  displayMessage(String msg, String from) {
    _display('$from: $msg\n');
  }
  
  displayNotice(String notice) {
    _display('[system]: $notice\n');
  }
  
  _display(String str) {
    elem.addText(str);
  }
}</pre><p>In both examples, the View objects expose an application-specific
      API—for example, <code class="literal">displayMessage()</code> or
      <code class="literal">_onUsernameChange()</code>—and encapsulate the manipulation
      of DOM elements.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch05-dart-json"></a>Encoding and Decoding Messages</h3></div></div></div><p>The dart:json library encodes and decodes JSON-formatted messages.
      JSON is an easy way to provide string message data to WebSockets. Using
      JSON also gives a bit of structure to the messages and leaves the door
      open to creating more detailed messages in the future.</p><p>The <code class="literal">stringify()</code> method converts a Dart object
      to a JSON-encoded string, and the <code class="literal">parse()</code> method
      converts a JSON string back into a Dart object. Here’s the JSON-related
      code from the chat client:</p><pre class="programlisting">import 'dart:json' as json;

var encoded = json.stringify({'f': from, 'm': message});
Map message = json.parse(encodedMessage);</pre><p>See <a class="xref" href="ch03.html#ch03-json" title="dart:json - Encoding and Decoding Objects">the section called “dart:json - Encoding and Decoding Objects”</a> for more information.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch05-web-sockets"></a>Communicating with WebSockets</h3></div></div></div><p>The custom class ChatConnection takes care of the chat client’s
      WebSocket communication. First it connects to the WebSocket by calling
      the WebSocket constructor with the argument <code class="literal">'ws://127.0.0.1:1337/ws'</code>. Then ChatConnection
      adds event handlers for open, close, error, and message events, using
      the WebSocketEvents object it gets from <code class="literal">webSocket.on</code>.
      For example, here’s the code that responds to message events:</p><pre class="programlisting">webSocket.on.message.add((MessageEvent e) {
  print('received message ${e.data}');
  _receivedEncodedMessage(e.data);
});</pre><p>The <code class="literal">_receivedEncodedMessage()</code> method just
      parses the JSON data and displays it in the status area.</p><pre class="programlisting">_receivedEncodedMessage(String encodedMessage) {
  Map message = json.parse(encodedMessage);
  if (message['f'] != null) {
    chatWindow.displayMessage(message['m'], message['f']);
  }
}</pre><p>To send a message on the WebSocket connection,
      <code class="literal">_sendEncodedMessage()</code> ensures the WebSocket
      connection is ready and then sends the JSON-encoded message.</p><pre class="programlisting">// In the ChatConnection class:
send(String from, String message) {
  var encoded = json.stringify({'f': from, 'm': message});
  _sendEncodedMessage(encoded);
}

_sendEncodedMessage(String encodedMessage) {
  if (webSocket != null &amp;&amp; webSocket.readyState == WebSocket.OPEN) {
    webSocket.send(encodedMessage);
  } else {
    print('WebSocket not connected, message $encodedMessage not sent');
  }
}</pre><p>In the event of a connection problem, the client code attempts to
      reconnect to the WebSocket server. The following code takes advantage of
      Dart’s nested functions, nesting the
      <code class="literal">scheduleReconnect()</code> function inside of
      <code class="literal">_init()</code>. Dart’s lexical scoping ensures that
      <code class="literal">scheduleReconnect()</code> can see variables from
      <code class="literal">_init()</code>.</p><pre class="programlisting">_init([int retrySeconds = 2]) {
  bool encounteredError = false;
  chatWindow.displayNotice('Connecting to Web socket');
  webSocket = new WebSocket(url);
  
  scheduleReconnect() {
    chatWindow.displayNotice('socket closed, retrying in $retrySeconds seconds');
    if (!encounteredError) {
      window.setTimeout(() =&gt; _init(retrySeconds*2), 1000*retrySeconds);
    }
    encounteredError = true;
  } 
  //...
  webSocket.on.close.add((e) =&gt; scheduleReconnect());
  webSocket.on.error.add((e) =&gt; scheduleReconnect());</pre><p>The reconnect logic uses <code class="literal">setTimeout()</code> to
      schedule a retry using an exponential backoff algorithm.</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ch05-server"></a>The Server’s Code</h2></div></div></div><p>The chat-server.dart file contains most of the code used in the chat
    server. It is responsible for serving static files and managing WebSocket
    connections. The chat server also logs the chat messages to a file.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch05-server-static-files"></a>Serving Static Files</h3></div></div></div><p>The chat server uses dart:io’s HttpServer to implement a web
      server. The default request handler is configured to serve static files
      from a specific directory on the file system.</p><pre class="programlisting">runServer(String basePath, int port) {
  HttpServer server = new HttpServer();  
  server.defaultRequestHandler = new StaticFileHandler(basePath).onRequest;
  //...
  server.onError = (error) =&gt; print(error);
  server.listen('127.0.0.1', 1337);
  print('listening for connections on $port');
}

main() {
  var script = new File(new Options().script);
  var directory = script.directorySync();
  runServer('${directory.path}/client', 1337);
}</pre><p>The StaticFileHandler first gets the file contents using File and
      InputStream, and then sends the contents using OutputStream.</p><p>Because I/O can cause delays, due to variable network or disk
      bandwidth conditions, the chat server uses asynchronous I/O to handle
      HTTP requests while still being responsive to other requests. Each I/O
      request returns a Future, allowing the server to continue executing
      without waiting for the I/O to complete.</p><p>For example, in the following snippet the
      <code class="literal">exists()</code> method returns a Future. When the Future
      completes (with a value of true if the file exists, or false if it
      doesn’t), the function specified to <code class="literal">then()</code>
      executes.</p><pre class="programlisting">// Respond to HTTP requests for static files.
onRequest(HttpRequest request, HttpResponse response) {
  //...
  file.exists().then((found) {
    if (found) {
      // ...Respond with the file’s contents...
    } else {
      // ...Send a 404 response...
    }
  });</pre><p>See <a class="xref" href="ch03.html#ch03-asynchronous-programming" title="Asynchronous Programming">the section called “Asynchronous Programming”</a> for more
      information about using Future, and <a class="xref" href="ch03.html#ch03-files-and-directories" title="Files and Directories">the section called “Files and Directories”</a> for details on file and
      directory I/O.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch05-server-web-sockets"></a>Managing WebSocket Connections</h3></div></div></div><p>In addition to serving static files, the chat server manages
      WebSocket connections, routing chat messages between clients. The
      dart:io WebSocketHandler class accepts HTTP connections, converts them
      into WebSocket connections, and then passes them to ChatHandler.</p><pre class="programlisting">runServer(String basePath, int port) {
  //...
  WebSocketHandler wsHandler = new WebSocketHandler();
  wsHandler.onOpen = new ChatHandler(basePath).onOpen;
}</pre><p>ChatHandler is a custom class that takes care of all WebSocket
      communication for the chat server. Here is its implementation.</p><pre class="programlisting">class ChatHandler {
  Set&lt;WebSocketConnection&gt; connections;
  //...
  onOpen(WebSocketConnection conn) {
    connections.add(conn);

    conn.onClosed = (int status, String reason) {
      connections.remove(conn);
    };

    conn.onMessage = (message) {
      connections.forEach((connection) {
        if (conn != connection) {
          //...
          connection.send(message));
        }
      });
    };

    conn.onError = (e) {
      connections.remove(conn);
    };
  }
}</pre><p>When a client connects, the server adds the client’s WebSocket
      connection to a collection. When the client disconnects (either through
      an error or on purpose), the server removes that client’s connection
      from the collection. When a new message arrives, the server sends the
      message to all connected clients except the original source.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ch05-server-log"></a>Logging Messages to a File</h3></div></div></div><p>The chat server logs data to a file, client/chat-log.txt, using a
      custom library implemented in file-logger.dart. This library uses an
      isolate to handle file I/O without tying up the root isolate. Here’s the
      code that creates and starts this isolate:</p><pre class="programlisting">SendPort _loggingPort = spawnFunction(startLogging);</pre><p>The value returned by dart:isolate’s
      <code class="literal">spawnFunction()</code> is a SendPort object. Because
      isolates share no data, messages sent to ports are the only way for the
      root isolate to communicate with the spawned isolate.</p><p>The argument to <code class="literal">spawnFunction()</code> points to the
      <code class="literal">startLogging()</code> function, which implements the logging
      isolate. The logic for the logging isolate is simple: the first message
      specifies the log file location, and subsequent messages provide data to
      write to the log file.</p><pre class="programlisting">startLogging() {
  print('started logger');
  File logFile;
  OutputStream out;
  port.receive((msg, replyTo) {
    if (logFile == null) {
      print('Opening file $msg');
      logFile = new File(msg);
      out = logFile.openOutputStream(FileMode.APPEND);
    } else {
      time('write to file', () {
        out.writeString('${new Date.now()} : $msg\n');
      });
    }
  });
}</pre><p>In the preceding code, the port property used by
      <code class="literal">startLogging()</code> refers to a ReceivePort provided by
      dart:isolate. The port is how this isolate gets data from the root
      isolate. If this isolate needed to send messages back to the root
      isolate, it could use the replyTo argument (a SendPort) to do so.</p><p>Recall that in the root isolate, the _loggingPort variable holds a
      SendPort that the root isolate uses to send messages to the logging
      isolate. Every time the chat server calls the <code class="literal">log()</code>
      method, the root isolate sends the log data:</p><pre class="programlisting">void log(String message) {
  _loggingPort.send(message);
}</pre><p>See <a class="xref" href="ch03.html#ch03-dartisolate---concurrency-with-isolates" title="dart:isolate - Concurrency with Isolates">the section called “dart:isolate - Concurrency with Isolates”</a> for more
      information about using isolates.</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ch05-what-next"></a>What Next?</h2></div></div></div><p>You’ve seen how the Dart Chat sample uses both server-side and
    client-side Dart code to implement a web app. Here are some other samples
    you might want to look at:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="ulink" href="https://code.google.com/p/dart/source/browse/#svn%2Ftrunk%2Fdart%2Fsamples%2Fsolar" target="_top">
        Solar</a>, which simulates the solar system with animations in a
        canvas, using <span class="phrase"><code class="literal">requestAnimationFrame()</code></span>.</p></li><li class="listitem"><p><a class="ulink" href="https://code.google.com/p/dart/source/browse/#svn%2Ftrunk%2Fdart%2Fsamples%2Fspirodraw" target="_top">
        Spirodraw</a>, a fun, interactive tool to build colorful works of
        art.</p></li></ul></div><p>Finally, please visit our website and join the discussion. We look
    forward to hearing from you!</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="ulink" href="http://www.dartlang.org" target="_top">Dart website</a></p></li><li class="listitem"><p><a class="ulink" href="http://www.dartlang.org/mailing-list" target="_top"> Dart
        discussion group</a></p></li><li class="listitem"><p><a class="ulink" href="http://stackoverflow.com/tags/dart" target="_top"> Dart questions
        on Stack Overflow</a></p></li></ul></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch04-summary.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="colophon.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Summary </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Colophon</td></tr></table></div>