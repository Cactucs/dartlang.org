---
layout: default
title: "Dart Language Specification (0.20, M2)"
description: "A work in progress: The official specification of the Dart language"
---
<title> {{page.title }} </title>
<style type="text/css">
      body {
        font-family: arial, sans, sans-serif;
        margin: 0;
      }

      #header, #footer {
        display: none;
      }

      #contents p {
        margin-bottom: 0px;
      }

    </style></head><body><div id="header">Dart Language Specification (0.20, M2)</div><div id="contents"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=lDlvyQoqF_fCC0_TBvn38mEzxrq2SxUQeB3MGuqBVoY');ol{margin:0;padding:0}.c17{vertical-align:top;width:117pt;border-style:solid;border-color:#000000;border-width:1pt;padding:5pt 5pt 5pt 5pt}.c46{list-style-type:lower-latin;margin:0;padding:0}.c9{padding-left:0pt;direction:ltr;margin-left:36pt}.c39{list-style-type:circle;margin:0;padding:0}.c20{list-style-type:decimal;margin:0;padding:0}.c16{list-style-type:disc;margin:0;padding:0}.c7{color:#000099;text-decoration:underline}.c45{max-width:468pt;padding:72pt 72pt 72pt 72pt}.c38{font-size:10pt;background-color:#e9f6ff}.c8{height:11pt;direction:ltr}.c6{color:#1155cc;text-decoration:underline}.c4{color:inherit;text-decoration:inherit}.c11{direction:ltr;margin-left:72pt}.c1{vertical-align:sub;font-style:italic}.c29{color:#9900ff;text-decoration:underline}.c36{font-size:18pt}.c34{text-align:center}.c19{margin-left:54pt}.c32{text-decoration:underline}.c50{text-decoration:line-through}.c44{text-indent:450pt}.c22{vertical-align:sub}.c26{color:#666666}.c12{color:#0000ff}.c49{color:#0c343d}.c28{color:#8e7cc3}.c10{font-size:7pt}.c0{font-family:"Tahoma"}.c25{color:#274e13}.c27{font-size:14pt}.c15{margin-left:90pt}.c43{background-color:#ffff00}.c30{padding-left:0pt}.c35{border-collapse:collapse}.c24{background-color:#ffffff}.c18{color:#ff0000}.c42{color:#0000cc}.c3{color:#38761d}.c41{padding-left:-3pt}.c47{color:#6aa84f}.c21{text-indent:3pt}.c33{margin-left:18pt}.c2{font-style:italic}.c31{margin-left:39pt}.c5{font-weight:bold}.c14{line-height:1.0}.c13{direction:ltr}.c37{height:14pt}.c48{text-indent:36pt}.c23{margin-left:36pt}.c40{font-size:12pt}.title{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:36pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}.subtitle{padding-top:18pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:24pt;font-family:"Georgia";padding-bottom:4pt}li{color:#000000;font-size:11pt;font-family:"Arial"}p{color:#000000;font-size:11pt;margin:0;font-family:"Arial"}h1{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:24pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}h2{padding-top:18pt;line-height:1.15;text-align:left;color:#000000;font-size:18pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h3{padding-top:14pt;line-height:1.15;text-align:left;color:#000000;font-size:14pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h4{padding-top:12pt;line-height:1.15;text-align:left;color:#000000;font-size:12pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}h5{padding-top:11pt;line-height:1.15;text-align:left;color:#000000;font-size:11pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}h6{padding-top:10pt;line-height:1.15;text-align:left;color:#000000;font-size:10pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}</style><h1 class="c34 c13"><a name="h.jpubrpygof4i"></a><span>The Dart Programming Language Specification (0.20, M2)</span></h1><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c34 c13"><span class="c27 c5">The Dart Team</span></p><hr style="page-break-before:always;display:none;"><p class="c8 c34"><span class="c5 c27"></span></p><p class="c8 c34"><span class="c27 c5"></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.jn6bj1irtqj1">Licensing</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.t4es9cmzw059">Changes</a></span></p><p class="c15 c13"><span class="c6"><a class="c4" href="#h.e8xxgwjgzpjc">Changes Since Version 0.02</a></span></p><p class="c15 c13"><span class="c6"><a class="c4" href="#h.68dpyt5nyl5z">Changes Since Version 0.03</a></span></p><p class="c15 c13"><span class="c6"><a class="c4" href="#h.squ00fhhd653">Changes Since Version 0.04</a></span></p><p class="c15 c13"><span class="c6"><a class="c4" href="#h.ulrk584ahfkg">Changes Since Version 0.05</a></span></p><p class="c15 c13"><span class="c6"><a class="c4" href="#h.bkbuva4b219u">Changes since Version 0.06</a></span></p><p class="c15 c13"><span class="c6"><a class="c4" href="#h.rbsrz7603b1n">Changes since Version 0.07</a></span></p><p class="c15 c13"><span class="c6"><a class="c4" href="#h.wwxd98gjj5p9">Changes since Version 0.08</a></span></p><p class="c15 c13"><span class="c6"><a class="c4" href="#h.4ns1v9qzolgn">Changes since Version 0.09</a></span></p><p class="c15 c13"><span class="c6"><a class="c4" href="#h.kfples9ypam">Changes since Version 0.10</a></span></p>
    <p class="c15 c13"><span class="c6"><a class="c4" href="#h.genut37d8x7s">Changes since Version 0.11</a></span></p>
    <p class="c15 c13"><span class="c6"><a class="c4" href="#h.stx9ay3afbnv">Changes since Version 0.12</a></span></p>
    <p class="c19 c13"><span class="c6"><a class="c4" href="#h.e59lyipdamf1">Notation</a></span></p><p class="c13 c23"><span class="c6"><a class="c4" href="#h.p51fkz19s0b2">Overview</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.jb82efuudrc5">Scoping</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.9oi5o1gdzoe8">Privacy</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.a21lfdy211x8">Concurrency</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.n3lq43t151ad">Errors and Warnings</a></span></p><p class="c13 c23"><span class="c6"><a class="c4" href="#h.55kzc4r0q21p">Variables</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.8rl9lqgqtly">Evaluation of Implicit Â Variable Getters</a></span></p><p class="c13 c23"><span class="c6"><a class="c4" href="#h.kt174mfrzv4a">Functions</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.yntwge6nalyc">Function Declarations</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.1ng1g7im8ubk">Formal Parameters</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.co9rbd1pkdlm">Required Formals</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.lqef8gma6oso">Optional Formals</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.c2phpmj3ikev">Type of a Function</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.lkkt75qhbiwh">External Functions</a></span></p><p class="c13 c23"><span class="c6"><a class="c4" href="#h.ed5f44k6gfp">Classes</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.ze2p6bhp40it">Instance Methods</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.8z01vn73qf90">Operators</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.semn73yhmkb5">Getters</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.xn3nrcf01kbi">Setters</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.csqy2h5zh7b0">Abstract Instance Members</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.vfjux7h3rxj7">Instance Variables</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.500yt9xvog42">Constructors</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.flm5xvbwhs6u">Generative Constructors</a></span></p><p class="c13 c15"><span class="c6"><a class="c4" href="#h.mnfuvjel4wl1">Redirecting Constructors</a></span></p><p class="c15 c13"><span class="c6"><a class="c4" href="#h.7ybyo5btajop">Initializer Lists</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.1t7lgvdmbwt9">Factories</a></span></p><p class="c15 c13"><span class="c6"><a class="c4" href="#h.oqdcfan480v">Redirecting Factory Constructors</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.gk4elj1gohb4">Constant Constructors</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.i641x57pmqjt">Static Methods</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.1k2j0ywtrfjj">Static Variables</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.7crfigeelg47">Superclasses</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.n9p3c8rq84d5">Inheritance and Overriding</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.pk4aq5ol5027">Superinterfaces</a></span></p><p class="c13 c23"><span class="c6"><a class="c4" href="#h.3g1mmsk0kbcr">Interfaces</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.6njjvzks70uf">Superinterfaces</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.n9p3c8rq84d5">Inheritance and Overriding</a></span></p><p class="c13 c23"><span class="c6"><a class="c4" href="#h.dkzw3xyky3rs">Generics</a></span></p><p class="c13 c23"><span class="c6"><a class="c4" href="#h.d0rowtffuudf">Metadata</a></span></p><p class="c13 c23"><span class="c6"><a class="c4" href="#h.dz8ekoegseec">Expressions</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.9asvt38phduq">Constants</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.gianetx6ltsy">Null</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.ofa8cxlvo8lw">Numbers</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.jitw991wrmh5">Booleans</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.qoglfpvek4rj">Boolean Conversion</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.fp52o176rzde">Strings</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.us5hu2wpthk4">String Interpolation</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.aj7d3xqsd3m5">Lists</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.1f7gnk1hnxaz">Maps</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.lo4c3zw824l">Throw</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.w0k5ugtz3rpv">Function Expressions</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.a02n00oljphq">This</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.seezxc7foicl">Instance Creation</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.twiod7rqtbah">New</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.kk36x2av9f7f">Const</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.w9xbbkh4rog6">Spawning an Isolate</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.8rkt9qgxx3m">Property Extraction</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.y92yhnm0wxy7">Function Invocation</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.3tizygdkqnej">Actual Argument List Evaluation</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.edxvczd1cw0f">Binding Actuals to Formals</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.o9n2pv4hceh1">Unqualified Invocation</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.5l8tud6ne77w">Function Expression Invocation</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.mwjqhj0r8mr">Method Invocation</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.bq7ggoshcofg">Ordinary Invocation</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.30hsq2v14fk2">Cascaded Invocations</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.jwevbcchdb5f">Static Invocation</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.x8qjjxmvmrg9">Super Invocation</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.4d637niex9m0">Sending Messages</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.2hfie11p4p4e">Getter and Setter Lookup</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.qnxio27bibb">Getter Invocation</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.wkwl6fs6jml0">Assignment</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.ctjzifgzeqep">Compound Assignment</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.fpalvmah8gsn">Conditional</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.33dew20hjpt">Logical Boolean Expressions</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.gxkncuzhsd9x">Bitwise Expressions</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.5kdfq4b9vyr1">Equality</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.fmzbyxz4ly1c">Relational Expressions</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.jmq7bvufo5ez">Shift</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.7hq9zn6blrwm">Additive Expressions</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.uofn135f1hb3">Multiplicative Expressions</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.nctl41fjp9vk">Unary Expressions</a></span></p><p class="c13 c19"><span class="c6"><a class="c4" href="#h.h035ru2uchdu">Postfix Expressions</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.dt5sshf3wb90">Assignable Expressions</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.igni7ynd65c8">Identifier Reference</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.x0ar1hv8tolv">Type Test</a></span></p><p class="c13 c23"><span class="c6"><a class="c4" href="#h.4pppxtxtu3v2">Type Cast</a></span></p><p class="c13 c23"><span class="c6"><a class="c4" href="#h.mbzyefis3od1">Argument Definition Test</a></span></p><p class="c13 c23"><span class="c6"><a class="c4" href="#h.hqr7euivxf2k">Statements</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.cl7xuoqlaaeh">Blocks</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.xqzpebdcgm4">Expression Statements</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.w2e1gboc13um">Variable Declaration</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.4o2dnbvusvi5">Local Function Declaration</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.e62bkwgzzagn">If</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.phf2izoilhq7">For</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.30cq61pcbhlr">For Loop</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.7l7e185heu0v">For-in</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.4t8k3tvkyul3">While</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.vj4ainfqsbwg">Do</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.50ae78s6gbw2">Switch</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.jodos9r2r9lz">Try</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.q1wj04wamlw9">Return</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.k6ffi6ql1tjy">Labels</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.s4y8w9w8zyl0">Break</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.hkf3vffzbfy6">Continue</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.cb5i0axenow6">Assert</a></span></p><p class="c13 c23"><span class="c6"><a class="c4" href="#h.9ljawpv6s0wp">Libraries and Scripts</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.eyqxfqjhe14t">Imports</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.hn3xi6ounpdp">Exports</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.dpvx6nmfj2hs">Parts</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.ey3rvr2kjush">Scripts</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.nzq6637fb0bx">URIs</a></span></p><p class="c13 c23"><span class="c6"><a class="c4" href="#h.9ca6j5czrg1m">Types</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.7tlgp5n9j12w">Static Types</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.6g03yyyk32we">Dynamic Type System</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.h8qq10r7b7a7">Type Declarations</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.vv8c77hhsmtm">Typedef</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.36i2sfscvw0c">Interface Types</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.hj977zpcf6uf">Function Types</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.myhds5lp5ovr">Type dynamic</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.a5hjb7g00phr">Type Void</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.6kyg74b28ed0">Parameterized Types</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.eu4kv2vjewua">Actual Type of a Declaration</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.hegkdje9bscx">Least Upper Bounds</a></span></p><p class="c13 c23"><span class="c6"><a class="c4" href="#h.lhp7sn5lni0h">Reference</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.h9utggye7amm">Lexical Rules</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.huusvrzea3q">Reserved Words</a></span></p><p class="c11"><span class="c6"><a class="c4" href="#h.gey5ehc2i2ad">Comments</a></span></p><p class="c19 c13"><span class="c6"><a class="c4" href="#h.sn1uuf2ffwwd">Operator Precedence</a></span></p><p class="c13 c23"><span class="c6"><a class="c4" href="#h.a49aki5jh8v5">Appendix: Naming Conventions</a></span></p><p class="c8 c34"><span class="c27 c5"></span></p><p class="c8 c34"><span class="c27 c5"></span></p><hr style="page-break-before:always;display:none;"><p class="c8 c34"><span class="c27 c5"></span></p><p class="c8 c34"><span class="c27 c5"></span></p><p class="c8 c34"><span class="c27 c5"></span></p><a href="#" name="id.mx38kee05esu"></a><p class="c13"><span class="c27 c5">Notes</span></p><p class="c8"><span class="c27 c18 c5"></span></p><p class="c13"><span>T</span><span>his document is synced to version 0.20, M2 release.</span></p><p class="c8"><span></span></p><p class="c13"><span>Please send comments to gbracha@google.com.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c5">This is a work in progress.</span><span>Â Expect the contents and language rules to change over time.</span></p><h4 class="c13"><a name="h.jn6bj1irtqj1"></a><span>Licensing</span></h4><p class="c8"><span></span></p><p class="c13"><span class="c24">Except as otherwise </span><span class="c32 c24 c42"><a class="c4" href="http://code.google.com/policies.html#restrictions">noted</a></span><span class="c24 c26">, </span><span class="c24">the content of this document is licensed under the </span><span class="c7 c24"><a class="c4" href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0 License</a></span><span class="c24">, and code samples are licensed under the </span><span class="c32 c24 c42"><a class="c4" href="http://code.google.com/google_bsd_license.html">BSD License</a></span><span class="c26 c24">.</span></p><p class="c8"><span class="c26 c24"></span></p><h4 class="c13"><a name="h.t4es9cmzw059"></a><span>Changes</span></h4><p class="c8"><span></span></p><h5 class="c13"><a name="h.e8xxgwjgzpjc"></a><span>Changes Since Version 0.02</span></h5><p class="c8"><span></span></p><p class="c13"><span>The following changes have been made in version 0.03 since version 0.02. In addition, various typographical errors have been corrected. The changes are listed by section number.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.7zsvgjszhvsx">2:</a></span><span>Â Expanded examples of grammar in notation section.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.c8755sosjkuz">7.10:</a></span><span class="c5">Â </span><span>Removed static warning when imported superinterface of a class contains private members.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.5kvtnnyqvcjb">8.4:</a></span><span>Â Removed redundant prohibition on default values.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.1dtu82gkimcm">8.5:</a></span><span>Â Removed static warning when imported superinterface of an interface contains private members.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.5cg9qz6trgbb">10:</a></span><span>Â Fixed typo in grammar</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.pp0ymlz8g03s">10.10.1</a></span><span class="c5">, </span><span class="c7 c5"><a class="c4" href="#id.bfpdh2tlvt0v">10.10.2</a></span><span class="c5">Â :</span><span>Â made explicit accessibility requirement for class being constructed.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.bfpdh2tlvt0v">10.10.2:</a></span><span>Â make clear that referenced constructor must be marked const.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.mmuk7ayxh6r9">10.14.3:</a></span><span>Â fixed botched sentence where superclass </span><span class="c2">S</span><span>Â is introduced.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.jzsb5y8clslk">10.27:</a></span><span>Â qualified definition of </span><span class="c2">v++</span><span>Â so it is clear that </span><span class="c2">v</span><span>Â is an identifier.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><h5 class="c13"><a name="h.68dpyt5nyl5z"></a><span>Changes Since Version 0.03</span></h5><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.6kuu1330zv2p">7.1</a></span><span class="c5">:</span><span>Â Added rules prohibiting clashes of inherited variable names or of static and instance methods.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.6kuu1330zv2p">7.1</a></span><span class="c5">, </span><span class="c7 c5"><a class="c4" href="#id.oq9a3ejdhhkw">8.1</a></span><span class="c5">:</span><span>Â Added missing requirement that overriding methods have same number of required parameters and all optional parameters as overridden method, in same order.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.64iudgj9wjj1">9:</a></span><span>Â Added prohibition against cyclic type hierarchy for type parameters.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.hvkbnlui8uvu">10.10: </a></span><span>Â Clarified requirements on use of parameterized types in instance creation expressions.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.p7pe6x2fs02j">10.13.2:</a></span><span class="c5">Â </span><span>Added requirement that </span><span class="c2">q</span><span class="c1">i</span><span>Â are distinct. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.fe2sq6esvhvp">10.4.2:</a></span><span class="c5">Â </span><span>Static method invocation determines the function (which may involve evaluating a getter) before evaluating the arguments, so that static invocation and top-level function invocation agree.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.8l84oujmjm7p">10:30:</a></span><span>Â Added missing test that type being tested against is in scope and is indeed a type.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.j9iezeasgfnv">11.5.1:</a></span><span>Â Changed for loop to introduce fresh variable for each iteration.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.nr95v4q1z9z0">13.8:</a></span><span class="c5">Â </span><span>Â Malformed parameterized types generate warnings, not errors(except when </span><span>used i</span><span>n reified contexts like instance creation and superclasses/interfaces).</span></p><p class="c8"><span class="c5"></span></p><h5 class="c13"><a name="h.squ00fhhd653"></a><span>Changes Since Version 0.04</span></h5><p class="c8"><span class="c5"></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.qd5b7xk45uot">7.1.1:</a></span><span class="c5">Â </span><span>Removed unary plus operator. Clarified that operator formals must be required.</span></p><p class="c8"><span class="c5"></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.okcph2t66jnm">7.5.3:</a></span><span>Â Filled in a lot of missing detail.</span></p><p class="c8"><span class="c5"></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.5kvtnnyqvcjb">8.4:</a></span><span>Â Allowed factory class to be declared via a qualified name.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.qjvme5fkz60x">10.3:</a></span><span class="c5">Â </span><span>Changed production for Number.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.bfpdh2tlvt0v">10.10.2:</a></span><span>Â Added requirements that actuals be constant, rules for dealing with inappropriate types of actuals, and examples. Also explicitly prohibit type parameters.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#kix.5k4ge149hokr">10.13.4:</a></span><span>Â Modified final bullet to keep it inline with similar clauses in other sections. Exact wording of these sections also tweaked slightly.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.20somwjc6usp">10.25</a></span><span class="c7 c5"><a class="c4" href="#id.kkly3nwmaye">:</a></span><span>Â Specified ! operator. Eliminated section on prefix expressions and moved contents to section on unary expressions.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.72xk08vpsgpx">14.1:</a></span><span>Â Specified unicode form of Dart source.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><h5 class="c13"><a name="h.ulrk584ahfkg"></a><span>Changes Since Version 0.05</span></h5><p class="c8"><span class="c5"></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.e2bn3056d7ls">7:6.1:</a></span><span class="c5">Â </span><span>Clarified how initializing formals can act as optional parameters of generative constructors.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.ue4n89yodj3k">7.6.2:</a></span><span>Â  Treat factories as constructors, so type parameters are implicitly in scope</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.5kvtnnyqvcjb">8.4:</a></span><span>Â Simplify rules for interface factory clauses. Use the keyword </span><span class="c5">default</span><span>Â instead of </span><span class="c5">factory</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.64iudgj9wjj1">9:</a></span><span>Â Mention that typedefs can have type parameters.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.8l84oujmjm7p">10.29:</a></span><span>Â Added checked mode test that type arguments match generic type.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.xmnezjjgjrld">13.2:</a></span><span>Â Added definition of malformed types, and requirement on their handling in checked mode.</span></p><p class="c8"><span></span></p><h5 class="c13"><a name="h.bkbuva4b219u"></a><span>Changes since Version 0.06</span></h5><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#kix.6b1cgvgf1cyq">5:</a></span><span>Â Library variable initializers must be constant.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.o6h4ul6q3sru">7</a></span><span class="c5">: </span><span>Added</span><span class="c5">Â </span><span class="c0 c5">abstract</span><span>Â modifier to grammar.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.o6h4ul6q3sru">7</a></span><span class="c5">, </span><span class="c7 c5"><a class="c4" href="#id.y3ufp36d01bv">7.</a></span><span class="c5">7</span><span class="c5">, </span><span class="c7 c5"><a class="c4" href="#id.4vjq3uijqjm">7.</a></span><span class="c5">8</span><span class="c5">, </span><span class="c7 c5"><a class="c4" href="#id.umipgzep5jdf">10.13.3</a></span><span class="c5">, </span><span class="c7 c5"><a class="c4" href="#id.ayq1ul833tkz">10.28</a></span><span class="c5">: Â </span><span>Superclass static members are not in scope in subclasses, and do not conflict with subclass members.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.qd5b7xk45uot">7.1.1:</a></span><span>Â </span><span class="c0">[]=</span><span>Â must return </span><span class="c0 c5">void</span><span>. Operator </span><span class="c0 c5">call</span><span>Â added to support function emulation. Removed operator </span><span class="c0">&gt;&gt;&gt;</span><span>. Made explicit restriction on methods named </span><span class="c0 c5">call</span><span>Â  or </span><span class="c0 c5">negate</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.hzs87hup8wb">10.1:</a></span><span>Â Added </span><span class="c2">!e</span><span>Â as constant expression. Clarified what happens if evaluation of a constant fails.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.riie55qjrb82">10.7:</a></span><span>Â Map keys need not be constants. However, they are always string literals.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.v2khzso6nh04">10.9:</a></span><span class="c5">Â </span><span>State restrictions on use of </span><span class="c0 c5">this</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.hvkbnlui8uvu">10.10</a></span><span class="c5">, </span><span class="c7 c5"><a class="c4" href="#id.pp0ymlz8g03s">10.10.1</a></span><span class="c5">:</span><span>Â Rules for bounds checking of constructor arguments when calling default constructors for interfaces refined.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#kix.5k4ge149hokr">10.13.4:</a></span><span>Â Revised semantics to account for function emulation.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#kix.dveayw720vs7">10.14.1</a></span><span class="c5">: </span><span>Revised semantics to account for function emulation.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.fe2sq6esvhvp">10.14.2:</a></span><span>Â Revised semantics to account for function emulation.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.mmuk7ayxh6r9">10.14.3: </a></span><span>Â Factory constructors cannot contain super invocations. Revised semantics to account for function emulation.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.lc2fh7iv9xwt">10.16:</a></span><span>Â Specified assignment involving </span><span class="c0">[]=</span><span>Â operator. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.jkue5mysxwsv">10.16.1:</a></span><span>Â Removed operator </span><span class="c0">&gt;&gt;&gt;</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.dvp94fjydf3m">10.22:</a></span><span>Â Removed operator </span><span class="c0">&gt;&gt;&gt;</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.jzsb5y8clslk">10.26:</a></span><span>Â Postfix </span><span class="c0">--</span><span>Â operator specified. Behavior of postfix operations on subscripted expressions specified.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.ayq1ul833tkz">10:28:</a></span><span>Â Added built-in identifier </span><span class="c0 c5">call</span><span>. Â Banned use of built-in identifiers as types, and made other uses warnings.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.8l84oujmjm7p">10.29:</a></span><span>Â  Moved specification of test that type arguments match generic type to </span><span class="c7 c5"><a class="c4" href="#id.xmnezjjgjrld">13.2</a></span><span>Â .</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.9tgfidrdlcan">11.8:</a></span><span>Â Corrected evaluation of case clauses so that case expression is the receiver of ==. Revised specification to correctly deal with blank statements in case clauses.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.d0t8no72xrno">11:15:</a></span><span>Â Fixed bug in </span><span class="c0 c5">assert</span><span>Â specification that could lead to puzzlers.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.xmnezjjgjrld">13.2:</a></span><span>Â Consolidated definition of malformed types.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.mmt307l7ge76">13.5:</a></span><span>Â Revised semantics to account for function emulation.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><h5 class="c13"><a name="h.rbsrz7603b1n"></a><span>Changes since Version 0.07</span></h5><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#kix.6b1cgvgf1cyq">5:</a></span><span class="c5">Â  </span><span>Static variables are lazily initialized, but need not be constants. Orthogonal notion of constant variable introduced.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.qd5b7xk45uot">7.1.1:</a></span><span>Â Added </span><span class="c0 c5">equals</span><span>Â operator as part of revised </span><span class="c0">==</span><span>Â treatment.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.e2bn3056d7ls">7.6.1:</a></span><span>Â Initializing formals have the same type as the field they correspond to.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.4vjq3uijqjm">7.8:</a></span><span>Â Static variable getter rules revised to deal with lazy initialization.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.5cg9qz6trgbb">10:</a></span><span>Â Modified syntax to support cascaded method invocations.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.hzs87hup8wb">10.1:</a></span><span>Â Removed support for + operator on Strings. Extended string constants to support certain cases of string interpolation. Revised constants to deal with constant variables</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.6fv1qfiad49o">10.5:</a></span><span>Â Corrected definition of </span><span class="c5">HEX_DIGIT_SEQUENCE</span><span>. Support implicit concatenation of adjacent single line strings. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.p7pe6x2fs02j">10.13.2:</a></span><span>Â Centralized and corrected type rules for function invocation.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#kix.1bfikjk2e9bd">10.14:</a></span><span>Â Moved rules for checking function/method invocations to 10.1.3.2. Added definition of cascaded method invocations.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.lharm2td3qkb">10.15</a></span><span>, </span><span class="c6 c5"><a class="c4" href="#id.lc2fh7iv9xwt">10.16</a></span><span>: Updated </span><span class="c0">noSuchMethod()</span><span>Â call for getters and setters to conform to planned API.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.qbnp7zy55vr8">10.17:</a></span><span>Â Modified syntax to support cascaded method invocations.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.i3yv71am0yah">10:20:</a></span><span>Â Revised semantics for </span><span class="c0">==.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.ayq1ul833tkz">10:28:</a></span><span>Â Removed </span><span class="c0 c5">import</span><span>, </span><span class="c0 c5">library</span><span>Â and </span><span class="c0 c5">source</span><span>Â from list of built-in identifiers. Revised rules for evaluating identifiers to deal with lazy static variable initialization.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.rmt74cjqdxyr">11.13:</a></span><span>Â Fixed bug that allowed </span><span class="c0 c5">continue</span><span>Â labeled on non-loops.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.3o1inam4xp4c">12</a></span><span class="c5">:</span><span>Â Revised syntax so no space is permitted between </span><span class="c0">#</span><span>Â and directives. Introduced </span><span class="c0">show:</span><span>Â combinator. Describe </span><span class="c0">prefix:</span><span>Â as a combinator. Added initial discussion of namespaces. Preclude string interpolation in arguments to directives.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><h5 class="c13"><a name="h.wwxd98gjj5p9"></a><span>Changes since Version 0.08</span></h5><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.6kuu1330zv2p">7.1</a></span><span class="c5">, </span><span class="c6 c5"><a class="c4" href="#id.t8nep39l3cq0">7.4</a></span><span class="c5">:</span><span>Â Abstract methods may specify default values.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.obndo59vaebw">8</a></span><span class="c5">, </span><span class="c6 c5"><a class="c4" href="#id.oq9a3ejdhhkw">8.1</a></span><span class="c5">: </span><span>Interface methods may specify default values.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.hzs87hup8wb">10.1</a></span><span class="c5">:</span><span>Â The ~/ Â operator can apply to doubles.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.hvkbnlui8uvu">10.10</a></span><span class="c5">:</span><span>Â Refined rules regarding abstract class instantiation, allowing factories to be used.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.9tgfidrdlcan">11.8</a></span><span class="c5">: </span><span class="c0 c5">switch</span><span>Â  statement specification revised.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.2p1bowyir5aa">11.14</a></span><span class="c5">: </span><span class="c0 c5">throw</span><span>Â may not throw </span><span class="c0 c5">null</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.dplnn8904tiq">12.2</a></span><span class="c5">: </span><span>Imports introduce a scope separate from the library scope. Multiple libraries may share prefix. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.cogei5ciyfcy">13.3.1</a></span><span class="c5">:</span><span>Â Recursive typedefs disallowed.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><h5 class="c13"><a name="h.4ns1v9qzolgn"></a><span>Changes since Version 0.09</span></h5><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.ph0zb6qp0qlw">3.1:</a></span><span>Â Consolidated discussion of namespaces and scopes. Started to tighten up definitions of scopes.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.o6h4ul6q3sru">7</a></span><span class="c5">:</span><span>Â Overriding of fields allowed.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.qd5b7xk45uot">7.1.1</a></span><span class="c5">:</span><span>Â </span><span class="c0">call() </span><span>Â is no longer an operator.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.ikrswzhb8wds">8.3:</a></span><span>Â Added specification of variable declarations in interfaces.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c7 c5"><a class="c4" href="#id.hzs87hup8wb">10.1:</a></span><span>Â Static methods and top level functions are compile-time constants.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.6fv1qfiad49o">10.5:</a></span><span>Â Multiline strings can be implicitly concatenated and contain interpolated expressions.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.y1kn7e2pvkf4">10.30:</a></span><span>Â Type cast expression added.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.g07b8yer9ws5">11.2:</a></span><span>Â Map literals cannot be expression statements.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.vlflmf5cnfa1">11.9</a></span><span class="c5">, </span><span class="c6 c5"><a class="c4" href="#id.2p1bowyir5aa">11.14</a></span><span>: Clarified type of stack trace.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.7mzy8j3cdwod">12.1</a></span><span class="c5">, </span><span class="c6 c5"><a class="c4" href="#id.dplnn8904tiq">12.2</a></span><span class="c5">:</span><span>Â Added re-export facility.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><h5 class="c13"><a name="h.kfples9ypam"></a><span>Changes since Version 0.10</span></h5><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.nr0objucb6zv">3:</a></span><span>Â Discuss reified runtime types.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.ph0zb6qp0qlw">3.1:</a></span><span>Â Removed shadowing warnings. Allow overloading of </span><span class="c0">-</span><span>. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#kix.6b1cgvgf1cyq">5:</a></span><span>Â Centralized discussion of implicit getters and setters.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.8qjw03x1t01o">6.4:</a></span><span>Â External functions added.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.o6h4ul6q3sru">7:</a></span><span>Â Abstract classes must now be declared explicitly.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.qd5b7xk45uot">7.1.1</a></span><span class="c5">:</span><span>Â Eliminate </span><span class="c0 c5">negate</span><span>Â in favor of overloaded unary minus. Eliminate </span><span class="c0 c5">equals</span><span>Â in favor of operator </span><span class="c0">==</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#kix.i4xvz9z9edz">7.3:</a></span><span>Â Setter syntax no longer includes = sign after the name. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#kix.msu37n3bbx21">7.4:</a></span><span>Â Clarify that getters and setters may be abstract. Eliminate </span><span class="c0 c5">abstract</span><span>Â modifier for abstract members. Added static warning if abstract class has abstract member.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.x0c4e7xfkarq">7.5:</a></span><span class="c5">Â </span><span>Instance variables can be initialized to non-constants. Moved discussion of implicit getters and setters to section </span><span class="c6"><a class="c4" href="#kix.6b1cgvgf1cyq">5</a></span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.e2bn3056d7ls">7.6.1:</a></span><span class="c5">Â </span><span>Clarify that finals can only be set once.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.l359w0dwudiw">7.6.2:</a></span><span>Â Added redirecting factories.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.4vjq3uijqjm">7.8:</a></span><span>Â Moved discussion of implicit getters and setters to section </span><span class="c6"><a class="c4" href="#kix.6b1cgvgf1cyq">5</a></span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.obndo59vaebw">8:</a></span><span>Â Eliminated interface declarations.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.iwjln3dq9jqj">10:</a></span><span>Â Added metadata.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.hzs87hup8wb">11.1:</a></span><span>Â Refined definition constant identity/caching.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.2p1bowyir5aa">11.8:</a></span><span class="c5">Â </span><span>Stack traces moved to </span><span class="c6"><a class="c4" href="#id.vlflmf5cnfa1">12.9</a></span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.pp0ymlz8g03s">11.11.1:</a></span><span>Â  Creating an instance via </span><span class="c0 c5">new</span><span>Â using an undefined class or constructor is a dynamic error and a static warning, not a compile-time error. Evaluation rules to allow instance variables with non-constant initializers. Instantiating an abstract class via a generative constructor is now a dynamic error.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.i3yv71am0yah">11.22:</a></span><span>Â Replaced </span><span class="c0">===</span><span>Â with built-in function </span><span class="c0">identical()</span><span>. Equality does not special case identity.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.ayq1ul833tkz">11.30:</a></span><span>Â Type names have meaning as expressions. </span><span class="c0 c5">assert</span><span>Â is no longer a built-in identifier, but </span><span class="c0 c5">export</span><span>, </span><span class="c0 c5">import</span><span>, </span><span class="c0 c5">library</span><span>Â and </span><span class="c0 c5">part</span><span>Â are. Removed warning on use of built-in identifiers as variable/function names.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.y1kn7e2pvkf4">11.32:</a></span><span>Â Type cast expression accepts </span><span class="c0 c5">null</span><span>. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.o0w0gbeh8j5q">11.33: </a></span><span>Added operation to determine if optional argument was actually passed.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.cvqb48le1je">12.4:</a></span><span>Â Added section on local functions.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.9tgfidrdlcan">12.8:</a></span><span>Â Allow switch on compile-time constants of any one type.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.vlflmf5cnfa1">12.9:</a></span><span>Â Revised syntax for catch clauses. Specification of stack traces moved from </span><span class="c6"><a class="c4" href="#id.2p1bowyir5aa">12.14</a></span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.963bggxlx5wo">12:10:</a></span><span>Â Made explicit that checked mode tests returns.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.d0t8no72xrno">12.14:</a></span><span>Â </span><span class="c0 c5">assert</span><span>Â is now a reserved word.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.3o1inam4xp4c">13:</a></span><span>Â Revised library syntax and semantics. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#kix.5kehb35oxqwh">14.7:</a></span><span>Â Renamed </span><span class="c0 c5">Dynamic</span><span>Â to </span><span class="c0 c5">dynamic</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.ezhiwl56w9dj">15.1.1:</a></span><span>Â </span><span class="c0 c5">assert</span><span>Â is a reserved word.</span></p><p class="c8"><span></span></p><h5 class="c8"><a name="h.bzm8n2z1qenh"></a></h5><h5 class="c13"><a name="h.genut37d8x7s"></a><span>Changes since Version 0.11</span></h5><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.7zsvgjszhvsx">2: </a></span><span>Â Moved discussion of tokenization to section 15.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.qjvme5fkz60x">11.3:</a></span><span>Â Removed unary plus.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.3o1inam4xp4c">13:</a></span><span>Â Refined definition of show and hide to handle getters and setters in pairs.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.mmt307l7ge76">14.5:</a></span><span>Â All function types are subtypes of Function.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.72xk08vpsgpx">15:</a></span><span>Â  Added discussion of tokenization.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.ezhiwl56w9dj">15.1.1:</a></span><span>Â  Defined meaning of reserved word.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.itswtk9lwkoq">15.1.2:</a></span><span>Â Added initial discussion of dartdoc comments.</span></p><p class="c8"><span></span></p><h5 class="c13"><a name="h.stx9ay3afbnv"></a><span>Changes since Version 0.12</span></h5><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.o6h4ul6q3sru">7:</a></span><span>Â Removed </span><span class="c0 c5">abstract</span><span>Â modifier from grammar of members.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.7ugexyrtn1zr">7.9:</a></span><span>Â Added discussion of new </span><span class="c0 c5">with</span><span>Â clause for mixins.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.hfiy4m46snbm">9:</a></span><span>Â Added tentative specification of mixins.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.hzs87hup8wb">12.1:</a></span><span>Â Revised description of </span><span class="c0">identical()</span><span>Â so that it always returns </span><span class="c0 c5">true</span><span>Â on numbers with the same class and value. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.y33m1d6n2h6f">12.2:</a></span><span>Â Invocations on </span><span class="c0 c5">null</span><span>Â throw </span><span class="c0">NoSuchMethodError</span><span>Â only.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#kix.s2h8t3rjj21s">12.8:</a></span><span>Â </span><span class="c0 c5">throw</span><span>Â of </span><span class="c0 c5">null</span><span>Â raises </span><span class="c0">NullThrownError</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.hvkbnlui8uvu">12.11:</a></span><span>Â Using undefined types as type arguments to a constructor is a dynamic failure.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.3o1inam4xp4c">13:</a></span><span>Â Added discussion of compilation units. Â Allow name clause to be optional for libraries, allow export clauses in scripts. Support fully qualified name for libraries. Allow different imports to share same prefix.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.cogei5ciyfcy">15.3.1:</a></span><span>Â Typedefs for mixin applications added.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.sos77naoaj3x">15.4:</a></span><span>Â Add effects of </span><span class="c0 c5">with</span><span>Â clause on subtyping.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.az0dpdfffqt3">15.8.2:</a></span><span>Â Corrected definition of LUBs.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c6 c5"><a class="c4" href="#id.ezhiwl56w9dj">16.1:</a></span><span>Â Added keyword </span><span class="c0 c5">with</span><span>.</span></p><p class="c8"><span></span></p><a href="#" name="id.7zsvgjszhvsx"></a><h3 class="c13"><a name="h.e59lyipdamf1"></a><span>Notation</span></h3><p class="c8"><span></span></p><p class="c13"><span>We distinguish between normative and non-normative text. Normative text defines the rules of Dart. It is given in this font (black </span><span>Arial</span><span>Â 11pt). At this time, non-normative text includes:</span></p><ol class="c16" start="1"><li class="c9"><span>Â Rationale. Discussion of the motivation for language design decisions appears in </span><span class="c12 c2">blue</span><span class="c12 c2">Â italics</span><span>. Â </span><span class="c12 c2">Distinguishing normative from non-normative helps clarify what part of the text is binding and what part is merely expository. Â </span></li><li class="c9"><span>Commentary, given </span><span>in </span><span class="c3">green</span><span>Â (Arial, 11pt) . Comments such as â</span><span class="c3">The careful reader will have noticed that the name Dart Â has four characters</span><span>â</span><span>Â serve to illustrate or clarify the specification, but are redundant with the normative text. Â </span><span class="c3">The difference between commentary and rationale can be subtle.</span><span class="c25">Â </span><span class="c12 c2">Commentary is more general than rationale, and may include illustrative examples or clarifications.</span></li><li class="c9"><span>Open questions (</span><span class="c18">in red</span><span>). Open questions are points that are unsettled in the mind of the author(s) of the specification; expect them Â (the questions, not the authors; precision is important in a specification) to be eliminated in the final specification. </span><span class="c18">Should the text at the end of the previous bullet be rationale or commentary?</span></li></ol><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span>Reserved words and built-in identifiers appear in </span><span class="c0 c5">this font. </span></p><p class="c13"><span class="c3">Examples would be </span><span class="c0 c3 c5">switch</span><span class="c3">Â or </span><span class="c0 c3 c5">class. </span></p><p class="c8"><span class="c0 c5"></span></p><p class="c13"><span>Grammar productions are given in a common variant of EBNF. The left</span></p><p class="c13"><span>hand side of a production ends with a colon. On the right hand side, alternation is represented by vertical bars, and sequencing by spacing. Â As in PEGs, alternation gives priority to the left. Â Optional elements of a production are suffixed by a question mark like so: </span><span class="c0">anElephant?</span><span>Â . Appending a star to an element of a production means it may be repeated zero or more times. Appending a plus sign to a production means it occurs one or more times. Parentheses are used for grouping. Negation (the </span><span class="c5">not</span><span>Â combinator of PEGs) is represented by prefixing an element of a production with a tilde. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">An example would be:</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3 c2 c5">AProduction:</span><span class="c3">Â </span></p><p class="c13"><span class="c3 c2">Â  Â  Â  AnAlternative</span></p><p class="c13"><span class="c3 c2">Â  Â  | AnotherAlternative</span></p><p class="c13"><span class="c3 c2">Â  Â  | Â OneThing After Another</span></p><p class="c13"><span class="c3">Â  </span><span class="c3 c2">| ZeroOrMoreThings*</span></p><p class="c13"><span class="c3 c2">Â  | OneOrMoreThings+</span></p><p class="c13"><span class="c3 c2">Â  | AnOptionalThing?</span></p><p class="c13"><span class="c3 c2">Â  | (</span><span class="c3 c2">Some Grouped Things</span><span class="c3 c2">)</span></p><p class="c13"><span class="c3 c2">Â  | ~NotAThing</span></p><p class="c13"><span class="c3 c2">Â  | A_LEXICAL_THING </span></p><p class="c13"><span class="c3 c2">Â  ;</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span>Both syntactic and lexical productions are represented this way. Lexical productions are distinguished by their names. The names of lexical productions consist exclusively of upper case characters and underscores. As always, within grammatical productions, whitespace and comments between elements of the production are implicitly ignored unless stated otherwise.</span></p><p class="c13"><span>Productions are embedded, as much as possible, in the discussion of the constructs they represent. Punctuation tokens appear in quotes. Â  </span></p><p class="c8"><span></span></p><p class="c13"><span>A list </span><span class="c2">x</span><span class="c1">1</span><span class="c2">,..., x</span><span class="c1">n</span><span>Â denotes any list of </span><span class="c2">n</span><span>Â elements of the form </span><span class="c2">x</span><span class="c1">i</span><span class="c2">, 1 &lt;= i &lt;= n.</span><span>Â Note that </span><span class="c2">n</span><span>Â may be zero, in which case the list is empty. We use such lists extensively throughout this specification.</span></p><p class="c8"><span></span></p><p class="c13"><span>The notation </span><span class="c2">[x</span><span class="c1">1</span><span class="c2">, ..., x</span><span class="c1">n</span><span class="c2">/y</span><span class="c1">1</span><span class="c2">, ..., y</span><span class="c1">n</span><span class="c2">]E</span><span>Â  denotes a copy of </span><span class="c2">E</span><span>Â in which all occurrences of </span><span class="c2">y</span><span class="c1">i</span><span class="c2">, 1 &lt;= i &lt;= n</span><span>Â have been replaced with </span><span class="c2">x</span><span class="c1">i</span><span class="c2">.</span></p><p class="c8"><span></span></p><p class="c13"><span>We sometimes abuse list or map literal syntax, writing </span><span class="c2">[o</span><span class="c1">1</span><span class="c2">, ..., o</span><span class="c1">n</span><span class="c2">] Â </span><span>(respectively</span><span class="c2">Â {k</span><span class="c1">1</span><span class="c2">: o</span><span class="c1">1</span><span class="c2">, ..., k</span><span class="c1">n</span><span class="c2">: o</span><span class="c1">n</span><span class="c2">}</span><span>)</span><span class="c2">Â </span><span>where the </span><span class="c2">o</span><span class="c1">i</span><span>Â and </span><span class="c2">k</span><span class="c1">i</span><span>Â may be objects rather than expressions. The intent is to denote a list (respectively map) object whose elements are the </span><span class="c2">o</span><span class="c1">i</span><span>Â (respectively, whose keys are the </span><span class="c2">k</span><span class="c1">i</span><span>Â and values are the </span><span class="c2">o</span><span class="c1">i</span><span>).</span></p><p class="c8"><span></span></p><p class="c13"><span>The specifications of operators often involve statements such as </span><span class="c2">x op y is equivalent to the method invocation x.op(y).</span><span>Â Such specifications should be understood as a shorthand for:</span></p><p class="c13"><span>Â </span><span class="c2">x op y is equivalent to the method invocation x.op</span><span class="c2">â</span><span class="c2">(y), assuming the class of x actually declared a non-operator method named opâ defining the same function as the operator op</span><span class="c2">.</span><span class="c2">Â </span><span class="c12 c2">This circumlocution is required because x.op(y), where op is an operator, is not legal syntax. However, it is painfully verbose, and we prefer to state this rule once here, and use a concise and clear notation across the specification.</span></p><p class="c8"><span></span></p><p class="c13"><span>When the specification refers to</span><span class="c2">Â the order given in the program,</span><span>Â it means the order of the program source code text, scanning left-to-right and top-to-bottom.</span></p><p class="c8"><span class="c0 c5"></span></p><p class="c13"><span>References to otherwise unspecified names of program entities (such as classes or functions) are interpreted as the names of members of the Dart core library.</span></p><p class="c8"><span class="c5"></span></p><p class="c13"><span class="c3">Examples would be the classes </span><span class="c0 c3">Object</span><span class="c3">Â and </span><span class="c0 c3">Type</span><span class="c3">Â representing the root of the class hierarchy and the reification of runtime types respectively. </span></p><p class="c8"><span></span></p><a href="#" name="id.nr0objucb6zv"></a><h2 class="c13"><a name="h.p51fkz19s0b2"></a><span>Overview</span></h2><p class="c8"><span></span></p><p class="c13"><span>Dart is a class-based, single-inheritance, pure object-oriented programming language. Dart is optionally </span><span class="c7"><a class="c4" href="#id.438ffsdvzkfw">typed</a></span><span>Â and supports reified generics. Â The runtime type of every object is represented as an instance of class </span><span class="c0">Type</span><span>Â which can be obtained by calling the getter Â </span><span class="c0">runtimeType</span><span>Â declared in class </span><span class="c0">Object</span><span>, the root of the Dart class hierarchy.</span></p><p class="c8"><span class="c18"></span></p><p class="c13"><span>Dart</span><span>Â programs can be statically checked. The </span><span class="c7"><a class="c4" href="#id.hiljskbmppmb">static checker</a></span><span>Â will report some violations of the type rules, but such violations do not abort compilation or preclude execution. </span></p><p class="c8"><span></span></p><p class="c13"><span>Dart programs may be executed in one of two modes: production mode or checked mode. In production mode, </span><span class="c7"><a class="c4" href="#id.hiljskbmppmb">static type annotations</a></span><span>Â have absolutely no effect on execution. Â In checked mode, </span><span>assignments</span><span>Â are dynamically checked, and certain violations of the type system raise exceptions at run time.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span class="c25">The coexistence between optional typing and reification is based on the following:</span></p><ol class="c16" start="1"><li class="c9"><span class="c25">Reified type information reflects the types of objects at runtime and may always be queried by dynamic typechecking constructs (the analogs of instanceOf, casts, typecase etc. in other languages). Reified type information includes class declarations, the the runtime type (aka class) of of an object, and type arguments to constructors. </span></li><li class="c9"><span class="c25">Static type annotations determine the types of variables and function declarations (including methods and constructors). </span></li><li class="c9"><span class="c25">Production mode respects optional typing. Static type annotations do not a</span><span class="c25">ffect</span><span class="c25">Â runtime behavior.</span></li><li class="c9"><span class="c25">Checked mode utilizes static type annotations and dynamic type information aggressively yet selectively to provide early error detection during development.</span></li></ol><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span>Dart programs are organized in a modular fashion into units called </span><span class="c7"><a class="c4" href="#id.3o1inam4xp4c">libraries</a></span><span>. Libraries are units of encapsulation and may be mutually recursive. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">However they are not first class. Â To get multiple copies of a library running simultaneously, one needs to spawn an isolate.</span><span class="c18">Â  </span></p><p class="c8"><span class="c18"></span></p><a href="#" name="id.ph0zb6qp0qlw"></a><h3 class="c13"><a name="h.jb82efuudrc5"></a><span>Scoping</span></h3><p class="c8"><span></span></p><p class="c8"><span class="c18"></span></p><p class="c13"><span>A </span><span class="c2">namespace</span><span>Â is a mapping of identifiers to declarations. Â Let </span><span class="c2">NS</span><span>Â be a namespace. We say that a </span><span class="c2">name n is in NS</span><span>Â if </span><span class="c2">n</span><span>Â is a key of </span><span class="c2">NS</span><span>. We say a </span><span class="c2">declaration d is in NS</span><span>Â if a key of </span><span class="c2">NS</span><span>Â maps to </span><span class="c2">d.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>A scope </span><span class="c2">S</span><span class="c10 c2">0</span><span>Â induces a namespace </span><span class="c2">NS</span><span class="c10 c2">0</span><span>Â that maps the simple name of each variable, type or function declaration </span><span class="c2">d</span><span>Â declared in </span><span class="c2">S</span><span class="c10 c2">0</span><span>Â to </span><span class="c2">d</span><span>. Â Labels are not included in the induced namespace of a scope; instead they have their own dedicated namespace.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">It is therefore impossible, e.g., Â to define a class that declares a method and a field with the same name in Dart. Similarly one cannot declare a top level function with the same name as a library variable or class.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span>It is a compile-time error if there is more than one entity with the same name declared in the same scope</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">In some cases, the name of the declaration differs from the identifier used to declare it. </span><span class="c3">Â Setters have names that are distinct from the corresponding getters because they always have an = automatically added at the end, and unary minus has the special name unary-.</span></p><p class="c8"><span></span></p><p class="c13"><span>Dart is lexically scoped. Â  Scopes may nest. A name or declaration </span><span class="c2">d</span><span>Â  is </span><span class="c2">available in scope S</span><span>Â if </span><span class="c2">d</span><span>Â  is in the namespace induced by </span><span class="c2">S</span><span>Â or if </span><span class="c2">d</span><span>Â  is available in the lexically enclosing scope of </span><span class="c2">S.</span><span>Â We Â say that a name or declaration </span><span class="c2">d</span><span>Â  is </span><span class="c2">in scope</span><span>Â if </span><span class="c2">d</span><span>Â  is available in the current scope. </span></p><p class="c8"><span></span></p><p class="c13"><span>If a Â declaration </span><span class="c2">d</span><span>Â named </span><span class="c2">n</span><span>Â is in the namespace induced by a scope S, then </span><span class="c2">d hides</span><span>Â any declaration named </span><span class="c2">n</span><span>Â that is available in the lexically enclosing scope of S. </span></p><p class="c8"><span></span></p><p class="c13"><span>Names may be introduced into a scope by Â declarations within the scope or by other mechanisms such as imports or inheritance.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">The interaction of lexical scoping and inheritance is a subtle one. Â Ultimately, the question is whether lexical scoping takes precedence over inheritance or vice versa. Dart chooses the former.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">Allowing inherited names to take precedence over locally declared names can create unexpected situations as code evolves. Specifically, the behavior of code in a subclass can change without warning Â if a new name is introduced in a superclass. Â Consider:</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c0 c2 c5">library</span><span class="c12 c0 c2">Â âL1â;</span></p><p class="c13"><span class="c12 c0 c2 c5">class</span><span class="c12 c0 c2">Â S {}</span></p><p class="c8"><span class="c12 c0 c2"></span></p><p class="c13"><span class="c12 c0 c2 c5">library</span><span class="c12 c0 c2">Â âL2â;</span></p><p class="c13"><span class="c12 c0 c2 c5">import</span><span class="c12 c0 c2">Â âL1.dartâ;</span></p><p class="c13"><span class="c12 c0 c2">foo() =&gt; 42;</span></p><p class="c13"><span class="c12 c0 c2 c5">class</span><span class="c12 c0 c2">Â C </span><span class="c12 c0 c2 c5">extends</span><span class="c12 c0 c2">Â S{ bar() =&gt; foo();}</span></p><p class="c8"><span class="c12 c0 c2"></span></p><p class="c13"><span class="c12 c2">Now assume a method </span><span class="c12 c0 c2">foo()</span><span class="c12 c2">Â is added to </span><span class="c12 c0 c2">S</span><span class="c12 c2">. </span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c0 c2 c5">library</span><span class="c12 c0 c2">Â âl1â;</span></p><p class="c13"><span class="c12 c0 c2 c5">class</span><span class="c12 c0 c2">Â S {foo() =&gt; 91;}</span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">If inheritance took precedence over the lexical scope, the behavior of C would change in an unexpected way. Neither the author of </span><span class="c12 c0 c2">S</span><span class="c12 c2">Â nor the author of </span><span class="c12 c0 c2">C</span><span class="c12 c2">Â are necessarily aware of this. In Dart, if there is a lexically visible method </span><span class="c12 c0 c2">foo()</span><span class="c12 c2">, it will always be called.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">Now consider the opposite scenario. We start with a version of </span><span class="c12 c0 c2">S</span><span class="c12 c2">Â that contains </span><span class="c12 c0 c2">foo()</span><span class="c12 c2">, but do not declare </span><span class="c12 c0 c2">foo()</span><span class="c12 c2">Â in library </span><span class="c12 c0 c2">L2</span><span class="c12 c2">. Â Again, there is a change in behavior - but the author of </span><span class="c12 c0 c2">L2</span><span class="c12 c2">Â is the one who introduced the discrepancy that effects their code, and the new code is lexically visible. Both these factors make it more likely that the problem will be detected.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">These considerations become even more important if one introduces constructs such as nested classes, which might be considered in future versions of the language.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">Good tooling should of course endeavor to inform programmers of such situations (discretely). For example, an identifier that is both inherited and lexically visible could be highlighted (via underlining or colorization). Better yet, tight integration of source control with language aware tools would detect such changes when they occur. </span></p><p class="c8"><span class="c12 c2"></span></p><p class="c8"><span class="c18"></span></p><a href="#" name="id.zeletzevxf8t"></a><h3 class="c13"><a name="h.9oi5o1gdzoe8"></a><span>Privacy</span></h3><p class="c13"><span>Dart supports two levels of privacy: </span><span class="c2">public</span><span>Â and </span><span class="c2">private</span><span>. A declaration is private if its name begins with an underscore (the _ character) otherwise it is public. </span></p><p class="c8"><span></span></p><p class="c13"><span>A declaration </span><span class="c2">m</span><span>Â is </span><span class="c2">accessible to library L</span><span>Â </span><span>if </span><span class="c2">m</span><span>Â is declared in </span><span class="c2">L</span><span>Â </span><span>or if </span><span class="c2">m</span><span>Â is public</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">Private declarations may only be accessed within the library in which they are declared.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">Privacy is, at this point, a static notion tied to a particular piece of code (a library). It is designed to support software engineering concerns rather than security concerns. Untrusted code should always run in an another isolate. Â It is possible that libraries will become first class objects and privacy will be a dynamic notion tied to a library instance.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">Privacy is indicated by the name of a declaration - hence privacy and naming are not orthogonal. This has the advantage that both humans and machines can recognize access to private declarations at the point of use without knowledge of the context from which the declaration is derived.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c8"><span></span></p><a href="#" name="id.wd33q1u3sguh"></a><h3 class="c13"><a name="h.a21lfdy211x8"></a><span>Concurrency</span></h3><p class="c13"><span>Dart code is always single threaded. There is no shared-state concurrency in Dart. Concurrency is supported via actor-like entities called </span><span class="c2">isolates</span><span>.</span></p><p class="c13"><span>An </span><span class="c2">isolate</span><span>Â is a unit of concurrency. It has its own memory and its own thread of control. Isolates communicate by </span><span class="c7"><a class="c4" href="#id.3drgiqgu864y">message passing</a></span><span>. </span><span>No mutable state </span><span>is ever shared between isolates. Isolates are created by </span><span class="c7"><a class="c4" href="#id.x6lx0jb4kti5">spawning</a></span><span>.</span></p><p class="c8"><span></span></p><a href="#" name="id.l4twf9coi3a3"></a><h3 class="c13"><a name="h.n3lq43t151ad"></a><span>Errors</span><span>Â and Warnings</span></h3><p class="c13"><span>This specification distinguishes between several kinds of errors.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c2">Compile-time errors</span><span>Â are </span><span>errors that preclude execution</span><span>. A compile time error must be reported by a Dart compiler before the erroneous code is executed. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">A Dart implementation has considerable freedom as to when compilation takes place. Modern programming language implementations often interleave compilation and execution, so that compilation of a method may be delayed, e.g., Â until it is first invoked. Consequently, compile-time errors in a method m </span><span class="c12 c2">may be reported as late as the time of mâs first invocation</span><span class="c12 c2">.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">As a web language, Dart is often loaded directly from source, with no intermediate binary representation. In the interests of rapid loading, Dart implementations may choose to avoid full parsing of method bodies, for example. This can be done by tokenizing the input and checking for balanced curly braces on method body entry. In such an implementation, even syntax errors will be detected only when the method needs to be executed, at which time it will be compiled (JITed).</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">In a development environment a compiler should of course report compilation errors eagerly so as to Â best serve the programmer.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span>If a compile-time error occurs within the code of a running isolate </span><span class="c2">A</span><span>, </span><span class="c2">A</span><span>Â is immediately suspended.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">Typically, </span><span class="c12 c2 c5">A</span><span class="c12 c2">Â will then be terminated. However, this depends on the overall environment. A Dart engine runs in the context of an </span><span class="c12 c2 c5">embedder</span><span class="c12 c2">, a program that interfaces between the engine and the surrounding computing environment. The embedder will often be a web browser, but need not be; it may be a C++ program on the server for example. When an isolate fails with a compile-time error as described above, control returns to the embedder, along with an exception describing the problem. Â This is necessary so that the embedder can clean up resources etc. It is then the embedderâs decision whether to terminate the isolate or not.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c2">Static warnings</span><span>Â are those warnings reported by the static checker. They have no effect on execution. Many, but not all, static warnings relate to types, in which case they are known as </span><span class="c2">static type warnings. </span><span>Static warnings must be provided by Dart compilers used during development.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c2">Dynamic type errors</span><span>Â are type errors reported in </span><span class="c7"><a class="c4" href="#id.xmnezjjgjrld">checked mode</a></span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c2">Run time errors</span><span>Â are exceptions raised during execution. Whenever we say that an exception </span><span class="c2">ex</span><span>Â is </span><span class="c2">raised</span><span>Â or </span><span class="c2">thrown</span><span>, we mean that Â a </span><span class="c6"><a class="c4" href="#kix.s2h8t3rjj21s">throw expression </a></span><span>of the form</span><span>: </span><span class="c0 c5">throw</span><span>Â </span><span class="c2">ex</span><span class="c0">;</span><span>Â was implicitly evaluated. When we say that </span><span class="c2">a C is thrown</span><span>, where </span><span class="c2">C</span><span>Â is an exception class, we mean that an instance of class</span><span class="c0">Â </span><span class="c0 c2">C</span><span class="c0">Â </span><span>is thrown.</span></p><p class="c8"><span></span></p><p class="c13"><span>If an uncaught exception is thrown by a running isolate </span><span class="c2">A</span><span>, </span><span class="c2">A</span><span>Â is immediately suspended. </span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="kix.6b1cgvgf1cyq"></a><h2 class="c13"><a name="h.55kzc4r0q21p"></a><span>Variables</span></h2><p class="c13"><span>Variables are storage locations in memory. Â </span></p><p class="c8"><span></span></p><a href="#" name="id.prmcvifr6l2h"></a><p class="c13"><span class="c2 c5">variableDeclaration:</span><span class="c2"><br> Â  Â  Â </span><span class="c7 c2"><a class="c4" href="#id.2xe95ykmes0u">declaredIdentifier</a></span><span class="c2">Â (&#39;,&#39; </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2">)*<br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><a href="#" name="kix.iu109k4qkx9w"></a><p class="c13"><span class="c2 c5">declaredIdentifier:</span><span class="c2"><br> Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#id.gtr1evk47jqd">metadata</a></span><span class="c2">Â  </span><span class="c6 c2"><a class="c4" href="#id.w1smn1f9ij10">finalConstVarOrType</a></span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2"><br> Â  Â ;</span></p><a href="#" name="kix.5zp8idcc6g9d"></a><p class="c8"><span class="c2"></span></p><p class="c8"><span class="c2"></span></p><a href="#" name="kix.91nttucqea2m"></a><p class="c13"><span class="c2 c5">finalConstVarOrType:</span><span class="c2"><br> Â  Â  Â </span><span class="c0 c5">final</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.qv2a3rupuer9">type</a></span><span class="c2">?</span></p><p class="c13"><span class="c2">Â  Â  | </span><span class="c0 c5">const</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.qv2a3rupuer9">type</a></span><span class="c2">?<br> Â  Â | varOrType<br> Â  Â ;<br></span></p><p class="c13"><span class="c2 c5">varOrType:</span><span class="c2"><br> Â  Â </span><span class="c0 c5">var</span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.qv2a3rupuer9">type</a></span><span class="c2"><br> Â  Â ;<br><br><br></span><a href="#" name="id.m3rhzz9horb4"></a><span class="c2 c5">initializedVariableDeclaration:</span><span class="c2"><br> Â  Â  Â </span><span class="c7 c2"><a class="c4" href="#id.2xe95ykmes0u">declaredIdentifier</a></span><span class="c2">Â (&#39;=&#39; </span><span class="c6 c2"><a class="c4" href="#id.1u3vxuwrz6py">expression</a></span><span class="c2">)? (&#39;,&#39; </span><span class="c7 c2"><a class="c4" href="#id.cjgl4bau1n1l">initializedIdentifier</a></span><span class="c2">)*<br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span class="c2"><br></span><a href="#" name="kix.6x4eeu7fxy9w"></a><span class="c2 c5">initializedIdentifier:</span><span class="c2"><br> Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2">Â (&#39;=&#39; </span><span class="c6 c2"><a class="c4" href="#id.1u3vxuwrz6py">expression</a></span><span class="c2">)?<br> Â  Â ;<br><br></span><a href="#" name="id.2slkn210dwxm"></a><span class="c2 c5">initializedIdentifierList</span><span class="c2 c5">:</span><span class="c2"><br> Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#id.cjgl4bau1n1l">initializedIdentifier</a></span><span class="c2">Â (&#39;,&#39; </span><span class="c7 c2"><a class="c4" href="#id.cjgl4bau1n1l">initializedIdentifier</a></span><span class="c2">)*<br> Â  Â ;<br></span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span>A variable that has not been initialized has the initial value </span><span class="c6 c0 c5"><a class="c4" href="#id.y33m1d6n2h6f">null</a></span><span class="c5">.</span></p><p class="c8"><span></span></p><p class="c13"><span>A </span><span class="c2">static variable</span><span>Â is a variable that is not associated with a particular instance, but rather with an entire library or class. Â A variable declared at the top-level of a library is referred to as either a </span><span class="c2">library variable</span><span>Â or simply as a top-level variable.</span></p><p class="c8"><span></span></p><p class="c13"><span>Static variable declarations are initialized lazily. When a static variable </span><span class="c2">v</span><span>Â is read, iff it has not yet been assigned, it is set to the result of evaluating its initializer. The precise rules are given in sections </span><span class="c6"><a class="c4" href="#id.8ndy65nal9vg">5.1</a></span><span>Â and</span><span class="c6"><a class="c4" href="#id.ayq1ul833tkz">Â 11.30</a></span><span>.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c12 c2">The lazy semantics are given because we do not want a language where one tends to define expensive initialization computations, causing long application startup times. This is especially crucial for Dart, which must support the coding of client applications.</span></p><p class="c8"><span></span></p><p class="c13"><span>A </span><span class="c2">final variable</span><span>Â is a variable whose declaration includes the modifier </span><span class="c0 c5">final.</span><span>Â </span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error if a final instance variable that has been initialized at its point of declaration Â is Â also initialized in a constructor. It is a compile-time error if a final instance variable that has is initialized by means of an initializing formal of a constructor is Â also initialized elsewhere in the same constructor.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error if a library, static or local variable </span><span class="c2">v</span><span>Â is final and </span><span class="c2">v</span><span>Â is not initialized at its point of declaration.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">Attempting to assign to a final variable elsewhere will cause a NoSuchMethodError to be thrown, because no setter is defined for it. The assignment will also give rise to a static warning for the same reason. </span></p><p class="c8"><span class="c18"></span></p><p class="c13"><span>A </span><span class="c2">constant variable</span><span>Â is a variable whose declaration includes the modifier </span><span class="c0 c5">const.</span><span>Â A constant variable is always implicitly final. A constant variable must be initialized to a </span><span class="c6"><a class="c4" href="#id.hzs87hup8wb">compile-time constant</a></span><span>Â or a compile-time error occurs.</span><span class="c3">Â </span></p><p class="c8"><span></span></p><p class="c13"><span>If a variable declaration does not explicitly specify a type, the type of the declared variable(s) is </span><span class="c0 c5">dynamic</span><span class="c7"><a class="c4" href="#kix.5kehb35oxqwh">, the unknown type</a></span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>A library variable is implicitly static. It is a compile-time error to preface a top level variable declaration with the built-in identifier </span><span class="c0 c5">static.</span><span>Â  </span></p><p class="c8"><span></span></p><p class="c13"><span>Variable declarations always induce implicit getters. Mutable variables also induce implicit setters. The scope into which the implicit getters and setters are introduced depends on the kind of variable declaration involved. </span></p><p class="c8"><span></span></p><p class="c13"><span>A variable declaration of one of the forms </span><span class="c2">T v;</span><span>, </span><span class="c2">T v = e;</span><span>, </span><span class="c0 c2 c5">const</span><span class="c2">Â T v = e;</span><span>,</span><span class="c2">Â </span><span class="c0 c5">final</span><span>Â </span><span class="c2">T v;</span><span>Â </span><span class="c2">Â  </span><span>or</span><span class="c2">Â </span><span class="c0 c2 c5">final</span><span class="c2">Â T v = e;</span><span class="c2">Â </span><span>always induces an implicit </span><span class="c7"><a class="c4" href="#kix.wlocpej6rvqa">getter function</a></span><span>Â with signature</span></p><p class="c8"><span></span></p><p class="c13"><span class="c2">T get v</span></p><p class="c8"><span></span></p><p class="c13"><span>whose invocation evaluates as described </span><span class="c6"><a class="c4" href="#id.8ndy65nal9vg">below</a></span><span class="c2">.</span></p><p class="c8"><span></span></p><p class="c13"><span>A variable declaration of one of the forms </span><span class="c0 c2 c5">var</span><span class="c2">Â v;</span><span>,</span><span class="c2">Â </span><span class="c0 c2 c5">var</span><span class="c2">Â v = e;</span><span>, </span><span class="c0 c2 c5">const</span><span class="c2">Â  v = e;</span><span class="c2">, Â </span><span class="c0 c2 c5">final</span><span class="c2">Â v; Â </span><span>Â or</span><span class="c2">Â </span><span class="c0 c2 c5">final</span><span class="c2">Â v = e;</span><span>Â always induces an implicit </span><span class="c7"><a class="c4" href="#kix.wlocpej6rvqa">getter function</a></span><span>Â with signature</span></p><p class="c8"><span></span></p><p class="c13"><span class="c2">get v</span></p><p class="c8"><span></span></p><p class="c13"><span>whose invocation evaluates as described </span><span class="c6"><a class="c4" href="#id.8ndy65nal9vg">below</a></span><span class="c2">.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span>A non-final variable declaration of the form </span><span class="c2">T v;</span><span>Â or the form </span><span class="c2">T v = e; </span><span>always induces an implicit </span><span class="c7"><a class="c4" href="#kix.i4xvz9z9edz">setter function</a></span><span>Â with signature</span></p><p class="c8"><span></span></p><p class="c13"><span class="c0 c2 c5">void</span><span class="c2">Â set v=(T x)</span></p><p class="c8"><span></span></p><p class="c13"><span>whose execution sets the value of </span><span class="c2">v</span><span>Â to the incoming argument </span><span class="c2">x.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>A non-final variable declaration of the form </span><span class="c0 c2 c5">var </span><span class="c2">v;</span><span>Â or the form </span><span class="c0 c2 c5">var</span><span class="c2">Â v = e; </span><span>always induces an implicit </span><span class="c7"><a class="c4" href="#kix.i4xvz9z9edz">setter function</a></span><span>Â with signature</span></p><p class="c8"><span></span></p><p class="c13"><span class="c2">set v=(x)</span></p><p class="c8"><span></span></p><p class="c13"><span>whose execution sets the value of </span><span class="c2">v</span><span>Â to the incoming argument </span><span class="c2">x.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.8ndy65nal9vg"></a><h3 class="c13"><a name="h.8rl9lqgqtly"></a><span>Evaluation of Implicit Â Variable Getters</span></h3><p class="c8"><span></span></p><p class="c13"><span>Let </span><span class="c2">d</span><span>Â be the declaration of a static or library variable </span><span class="c2">v</span><span>. Â If </span><span class="c2">d</span><span>Â is a local or instance variable, then the invocation of the implicit getter of </span><span class="c2">v</span><span>Â evaluates to the value stored in </span><span class="c2">v</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>If </span><span class="c2">d</span><span>Â is a static or library variable then the implicit getter method of </span><span class="c2">v</span><span>Â executes as follows: </span></p><p class="c8"><span></span></p><ol class="c16" start="1"><li class="c9"><span>If </span><span class="c2">d</span><span>Â is of one of the forms </span><span class="c0 c2 c5">var</span><span class="c0 c2">Â v = e;</span><span>Â , </span><span class="c0 c2 c5">static</span><span class="c0 c2">Â T v = e;</span><span>Â , </span><span class="c0 c2 c5">static</span><span class="c0 c2">Â </span><span class="c0 c2 c5">final</span><span class="c0 c2">Â v = e;</span><span class="c2">Â </span><span>Â or </span><span class="c0 c2 c5">final</span><span class="c0 c2">Â T v = e;</span><span class="c2">Â </span><span>and no value has yet been stored into </span><span class="c2">v</span><span>Â then the initializer expression </span><span class="c2">e</span><span>Â is evaluated. If, during the evaluation of </span><span class="c2">e</span><span>, the getter for </span><span class="c2">v</span><span>Â is referenced, </span><span>a </span><span class="c0">CyclicInitializationError</span><span>Â is thrown. If the evaluation succeeded yielding an object </span><span class="c2">o</span><span>, let </span><span class="c2">r = o</span><span>, otherwise let </span><span class="c2">r = </span><span class="c0 c2 c5">null</span><span>. In any case, </span><span class="c2">r</span><span>Â is stored into </span><span class="c2">v</span><span>. The result of executing the getter is </span><span class="c2">r</span><span>. </span></li><li class="c9"><span>If </span><span class="c2">d</span><span>Â is of one of the forms </span><span class="c0 c2 c5">const</span><span class="c0 c2">Â v = e;</span><span>Â  or </span><span class="c0 c2 c5">const</span><span class="c0">Â </span><span class="c0 c2">T v = e;</span><span>Â the result of the getter is the value of the compile time constant </span><span class="c2">e</span><span>. Otherwise</span></li><li class="c9"><span>The result of executing the getter method is the value stored in </span><span class="c2">v</span><span>. Â </span></li></ol><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="kix.v3h5pp33ioek"></a><h2 class="c13"><a name="h.kt174mfrzv4a"></a><span>Functions</span></h2><p class="c8"><span></span></p><p class="c13"><span>Functions abstract over executable actions.</span></p><p class="c8"><span></span></p><a href="#" name="id.7ttlaph5nhkh"></a><p class="c13"><span class="c2 c5">functionSignature:</span><span class="c2"><br> Â  Â </span><span class="c6 c2"><a class="c4" href="#id.gtr1evk47jqd">metadata</a></span><span class="c0 c5"><a class="c4" href="#id.gtr1evk47jqd">Â </a></span><span class="c6 c2"><a class="c4" href="#id.mriqqq9dwbm5">returnType</a></span><span class="c2">? </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.6xer2paz3k7q">formalParameterList</a></span><span class="c2"><br> Â  Â ;<br></span></p><a href="#" name="id.mriqqq9dwbm5"></a><p class="c13"><span class="c2 c5">returnType:</span><span class="c2"><br> Â  Â  Â </span><span class="c0 c5">void</span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.qv2a3rupuer9">type</a></span></p><p class="c13"><span class="c2">Â  Â  ;<br><br><br></span><a href="#" name="id.twypn7sgnd3j"></a><span class="c2 c5">functionBody:</span><span class="c2"><br> Â  Â  Â </span><span class="c2">&#39;</span><span class="c0 c2">=&gt;</span><span class="c2">&#39; </span><span class="c6 c2"><a class="c4" href="#id.1u3vxuwrz6py">expression</a></span><span class="c2">Â &#39;;&#39;<br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#kix.kx7urn183i41">block</a></span><span class="c2"><br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><a href="#" name="kix.kx7urn183i41"></a><p class="c13"><span class="c2 c5">block:</span><span class="c2"><br> Â  Â  Â &#39;{&#39; </span><span class="c6 c2"><a class="c4" href="#id.mfp056u1wxhj">statements</a></span><span class="c2">Â &#39;}&#39;<br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span></span></p><p class="c13"><span>Functions include Â function declarations, methods, getters, setters and function literals. </span></p><p class="c8"><span></span></p><p class="c13"><span>All functions have a signature and a body. The signature describes the formal parameters of the function, and possibly its name and return type. The body is a block statement containing the statements executed by the function. A function body of the form Â </span><span class="c0">=&gt; e</span><span>Â is equivalent to a body of the form {</span><span class="c0 c5">return</span><span class="c0">Â e;}</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>If the last statement of a function is not a return statement, the statement </span><span class="c0 c5">return null</span><span class="c0">;</span><span>Â is implicitly appended to the function body.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">Because Dart is optionally typed, we cannot guarantee that a function that does not return a value will not be used in the context of an expression. Therefore, every function must return a value. See the </span><span class="c7 c2"><a class="c4" href="#id.963bggxlx5wo">discussion</a></span><span class="c2">Â </span><span class="c12 c2">around the return statement</span><span class="c12 c2">. </span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.2nytwox3z8kr"></a><h3 class="c13"><a name="h.yntwge6nalyc"></a><span>Function Declarations</span></h3><p class="c8"><span></span></p><p class="c13"><span>A </span><span class="c2">function declaration</span><span>Â is a function that is not a method, getter, setter or function literal. Function declarations include </span><span class="c2">library functions,</span><span>Â which are function declarations at the top level of a library, and </span><span class="c2">local functions,</span><span>Â which are functions declarations declared inside other functions. Â Library functions are often referred to simply as top-level functions.</span></p><p class="c8"><span></span></p><p class="c13"><span>A function declaration consists of an identifier indicating the function&#39;s name, followed by a signature and body.</span></p><p class="c8"><span></span></p><p class="c13"><span>The scope of a library function is the scope of the enclosing library. The scope of a local function is Â described below. In both cases, the name of the function is in scope in the formal parameters scope of the function.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error to preface a function declaration with the built-in identifier </span><span class="c0 c5">static.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.dbnqav8zbk9d"></a><h3 class="c13"><a name="h.1ng1g7im8ubk"></a><span>Formal Parameters</span></h3><p class="c13"><span>Every function includes a </span><span class="c2">formal parameter list,</span><span>Â which consists of a list of</span><span>Â required </span><span class="c6"><a class="c4" href="#id.lzl30mluk4sf">positional parameters</a></span><span>, followed by any optional parameters. </span><span>The optional parameters may be specified either as a set of named parameters or as a list of positional parameters, but not both.</span></p><p class="c8"><span></span></p><p class="c13"><span>The formal parameter list of a function introduces a new scope known as the function`s formal parameter scope. The formal parameter scope of a function </span><span class="c2">f</span><span>Â  is enclosed in the scope where </span><span class="c2">f</span><span>Â is declared. Â </span></p><p class="c8"><span></span></p><p class="c13"><span>The body of a function introduces a new scope known as the function`s body scope. The body of a function </span><span class="c2">f</span><span>Â  is enclosed Â in the scope introduced by the formal parameter scope of </span><span class="c2">f</span><span>. Every formal parameter introduces a local variable into the formal parameter scope.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error if a formal parameter is declared as a constant variable.</span></p><p class="c8"><span class="c18"></span></p><p class="c13"><span><br><br></span><a href="#" name="id.6xer2paz3k7q"></a><span class="c2 c5">formalParameterList:</span><span class="c2">Â  Â  Â </span></p><p class="c13"><span class="c2">Â  Â  </span><span class="c18 c2">Â </span><span class="c2">Â  &#39;(&#39; &#39;)&#39; </span></p><p class="c13"><span class="c2">Â  Â  | &#39;(&#39; </span><span class="c7 c2"><a class="c4" href="#id.fwj9r1x9ultc">normalFormalParameters</a></span><span class="c2">Â ( â,â </span><span class="c2">optionalFormalParameters</span><span class="c2">)? &#39;)&#39;</span></p><p class="c13"><span class="c2">Â  | Â &#39;(&#39; </span><span class="c2">optionalFormalParameters</span><span class="c2">Â &#39;)&#39;<br> Â  Â ;<br></span></p><a href="#" name="id.fwj9r1x9ultc"></a><p class="c13"><span class="c2 c5">normalFormalParameters:<br></span><span class="c2">Â  Â  Â  </span><span class="c7 c2"><a class="c4" href="#id.nu20924aw7uh">normalFormalParameter</a></span><span class="c2">Â (&#39;,&#39; </span><span class="c7 c2"><a class="c4" href="#id.nu20924aw7uh">normalFormalParameter</a></span><span class="c2">)* <br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span class="c2 c5">optionalFormalParameters:<br></span><span class="c2">Â  Â  Â  optionalPositionalFormalParameters |</span></p><p class="c13"><span class="c2">Â  Â  Â namedFormalParameters<br> Â  Â ;<br></span></p><p class="c13"><span class="c2 c5">optionalPositionalFormalParameters:<br></span><span class="c2">Â  Â  Â  &#39;[&#39;</span><span class="c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.hnv76i7pvtkk">Â </a></span><span class="c7 c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.hnv76i7pvtkk">defaultFormalParameter</a></span><span class="c2">Â (&#39;,&#39;</span><span class="c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.hnv76i7pvtkk">Â </a></span><span class="c7 c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.hnv76i7pvtkk">defaultFormalParameter</a></span><span class="c2">)* &#39;]&#39;<br> Â  Â ;<br><br><br></span><a href="#" name="id.ha46vgashw72"></a><span class="c2 c5">namedFormalParameters:</span><span class="c2"><br> Â  Â  Â &#39;{&#39; </span><span class="c2">defaultNamedParameter</span><span class="c2">(&#39;,&#39; </span><span class="c2">defaultNamedParameter</span><span class="c2">)* &#39;}&#39;<br> Â  Â ;<br></span><span><br><br></span></p><h4 class="c13"><a name="h.co9rbd1pkdlm"></a><span>Required Formals </span></h4><p class="c13"><span>A </span><span class="c2">required formal parameter</span><span>Â is a simple </span><span class="c7"><a class="c4" href="#kix.6b1cgvgf1cyq">variable declaration</a></span><span>.</span></p><p class="c13"><span><br></span><a href="#" name="id.nu20924aw7uh"></a><span class="c2 c5">normalFormalParameter:</span><span class="c2"><br> Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#id.7ttlaph5nhkh">functionSignature</a></span><span class="c2"><br> Â  Â | </span><span class="c7 c2"><a class="c4" href="#id.1nhs5plthzz2">fieldFormalParameter</a></span><span class="c2"><br> Â  Â | </span><span class="c7 c2"><a class="c4" href="#id.g51um5hg0av">simpleFormalParameter</a></span><span class="c2"><br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.g51um5hg0av"></a><p class="c13"><span class="c2 c5">simpleFormalParameter:</span><span class="c2"><br> Â  Â  Â </span><span class="c7 c2"><a class="c4" href="#id.2xe95ykmes0u">declaredIdentifier</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.gtr1evk47jqd">metadata</a></span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2"><br> Â  Â ;<br><br></span><a href="#" name="id.1nhs5plthzz2"></a><span class="c2 c5">fieldFormalParameter</span><span class="c2 c5">:</span><span class="c2"><br> Â  </span><span class="c6 c2"><a class="c4" href="#id.gtr1evk47jqd">metadata</a></span><span>Â </span><span class="c6 c2"><a class="c4" href="#id.w1smn1f9ij10">finalConstVarOrType</a></span><span class="c2">? </span><span class="c0 c5">this</span><span class="c2">Â &#39;.&#39; </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2"><br> Â  ;<br></span></p><h4 class="c13"><a name="h.lqef8gma6oso"></a><span>Optional Formals</span></h4><p class="c8"><span></span></p><p class="c13"><span>Optional parameters may be specified and provided with default values.</span></p><p class="c8"><span></span></p><a href="#" name="id.hnv76i7pvtkk"></a><p class="c13"><span class="c2 c5">defaultFormalParameter:</span><span class="c2"><br> Â  Â  Â </span><span class="c7 c2"><a class="c4" href="#id.nu20924aw7uh">normalFormalParameter</a></span><span class="c2">Â (&#39;</span><span class="c2">=</span><span class="c2">&#39; expression)?<br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span class="c2 c5">defaultNamedParameter:</span><span class="c2"><br> Â  Â  Â </span><span class="c7 c2"><a class="c4" href="#id.nu20924aw7uh">normalFormalParameter</a></span><span class="c2">Â (&#39;:&#39; expression)?<br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>It is a compile-time error if the default value of an optional parameter is not a </span><span>compile-time constant</span><span>. </span></p><p class="c13"><span>Â If no default is explicitly specified for an optional parameter an implicit default of </span><span class="c0 c5">null</span><span>Â is provided.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span>Â </span><span>It is a compile-time error if the name of a named optional parameter begins with an â_â character.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">The need for this restriction is a direct consequence of the fact that naming and privacy are not orthogonal. If we allowed named parameters to begin with an underscore, they would be considered private and inaccessible to callers from outside the library where it was defined. If a method outside the library overrode a method with a private optional name, it would not be a subtype of the original method. The static checker would of course flag such situations, but the consequence would be that adding a private named formal would break clients outside the library in a way they could not easily correct.<br></span></p><a href="#" name="id.a7h0wsr8vps9"></a><h3 class="c13"><a name="h.c2phpmj3ikev"></a><span>Type of a Function</span></h3><p class="c8"><span></span></p><p class="c13"><span>If a function does not declare a return type explicitly, its return type is </span><span class="c0 c5">dynamic</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>Let </span><span class="c2">F</span><span>Â be a function with required formal parameters </span><span class="c2">T</span><span class="c10 c2">1</span><span class="c2">Â p</span><span class="c10 c2">1</span><span class="c2">, â¦, T</span><span class="c10 c2">n</span><span class="c2">Â p</span><span class="c10 c2">n</span><span>., return type </span><span class="c2">T</span><span class="c10 c2">0</span><span>Â and no optional parameters</span><span class="c2">.</span><span class="c5">Â </span><span>Then the type of </span><span class="c2">F</span><span>Â is</span></p><p class="c13"><span>(</span><span class="c2">T</span><span class="c10 c2">1</span><span class="c2">Â , â¦, T</span><span class="c10 c2">n</span><span>)</span><span class="c2">Â â T</span><span class="c10 c2">0</span><span class="c2">.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>Let </span><span class="c2">F</span><span>Â be a function with required formal parameters </span><span class="c2">T</span><span class="c10 c2">1</span><span class="c2">Â p</span><span class="c10 c2">1</span><span class="c2">, â¦, T</span><span class="c10 c2">n</span><span class="c2">Â p</span><span class="c10 c2">n</span><span>., return type </span><span class="c2">T</span><span class="c10 c2">0</span><span>Â and positional optional parameters </span><span class="c2">T</span><span class="c10 c2">n+1</span><span class="c2">Â p</span><span class="c10 c2">n+1</span><span class="c2">, . . . , T</span><span class="c10 c2">n+k</span><span class="c2">Â p</span><span class="c10 c2">n+k</span><span class="c2">.</span><span class="c5">Â </span><span>Then the type of </span><span class="c2">F</span><span>Â is</span></p><p class="c13"><span>(</span><span class="c2">T</span><span class="c10 c2">1</span><span class="c2">Â , â¦, T</span><span class="c10 c2">n</span><span class="c2">, [T</span><span class="c10 c2">n+1</span><span class="c2">, â¦,T</span><span class="c10 c2">n+k</span><span class="c2">]</span><span>)</span><span class="c2">Â â T</span><span class="c10 c2">0</span><span class="c2">.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>Let </span><span class="c2">F</span><span>Â be a function with required formal parameters </span><span class="c2">T</span><span class="c10 c2">1</span><span class="c2">Â p</span><span class="c10 c2">1</span><span class="c2">, â¦, T</span><span class="c10 c2">n</span><span class="c2">Â p</span><span class="c10 c2">n</span><span>., return type </span><span class="c2">T</span><span class="c10 c2">0</span><span>Â and named optional parameters </span><span class="c2">T</span><span class="c10 c2">n+1</span><span class="c2">Â p</span><span class="c10 c2">n+1</span><span class="c2">, . . . , T</span><span class="c10 c2">n+k</span><span class="c2">Â p</span><span class="c10 c2">n+k</span><span class="c2">.</span><span class="c5">Â </span><span>Then the type of </span><span class="c2">F</span><span>Â is</span></p><p class="c13"><span>(</span><span class="c2">T</span><span class="c10 c2">1</span><span class="c2">Â , â¦, T</span><span class="c10 c2">n</span><span class="c2">, </span><span class="c2">{</span><span class="c2">p</span><span class="c10 c2">n+1</span><span class="c2">:T</span><span class="c10 c2">n+1</span><span class="c2">, â¦, p</span><span class="c10 c2">n+k</span><span class="c2">:T</span><span class="c10 c2">n+k</span><span class="c2">}</span><span>)</span><span class="c2">Â â T</span><span class="c10 c2">0</span><span class="c2">.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.8qjw03x1t01o"></a><h3 class="c13"><a name="h.lkkt75qhbiwh"></a><span>External Functions</span></h3><p class="c8"><span class="c27 c5"></span></p><p class="c13"><span>An </span><span class="c2">external function</span><span>Â is a function whose body is provided separately from its declaration. An external function may be a top-level function, a method, a getter, a setter or a non-redirecting constructor. External functions are introduced via the built-in identifier </span><span class="c0 c5">external</span><span>Â followed by the function signature. Â </span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">External functions allow us to introduce Â type information Â for code that is not statically known to the Dart compiler. </span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">Examples of external functions might be foreign functions (defined in C, or Javascript etc.), primitives of the implementation (as defined by the Dart runtime), or code that was dynamically generated but whose interface is statically known. However, an abstract method is different from an external function, as it has </span><span class="c3 c5">no</span><span class="c3">Â body.</span></p><p class="c8"><span></span></p><p class="c13"><span>An external function is connected to its body by an implementation specific mechanism. Attempting to invoke an external function that has not been connected to its body will raise a </span><span class="c0">NoSuchMethodError</span><span>Â or some subclass thereof.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">The actual syntax is given in the sections on </span><span class="c6"><a class="c4" href="#id.o6h4ul6q3sru">classes</a></span><span class="c3">Â and </span><span class="c6"><a class="c4" href="#id.3o1inam4xp4c">libraries</a></span><span class="c3">Â below.</span></p><p class="c8"><span></span></p><a href="#" name="id.o6h4ul6q3sru"></a><h2 class="c13"><a name="h.ed5f44k6gfp"></a><span>Classes</span></h2><p class="c13"><span>A class defines the form and behavior of a set of objects which are its </span><span class="c2">instances</span><span>. </span></p><p class="c8"><span></span></p><a href="#" name="id.64pqsyyi6upg"></a><p class="c13"><span class="c2 c5">classDefinition:</span><span class="c2"><br> Â  Â  </span><span class="c6 c2"><a class="c4" href="#id.gtr1evk47jqd">metadata</a></span><span class="c0 c5">Â </span><span class="c0 c5">abstract</span><span class="c2">? </span><span class="c0 c5">class</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.p9q99pefxn6v">typeParameters</a></span><span class="c2">? (</span><span class="c6 c2"><a class="c4" href="#id.frtqvspfkgww">superclass</a></span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.g3i7hntbrzmw">mixins</a></span><span class="c2">?)? </span><span class="c6 c2"><a class="c4" href="#id.5h6h28b15vp8">interfaces</a></span><span class="c2">?<br> Â  Â  Â &#39;{&#39; (</span><span class="c6 c2"><a class="c4" href="#id.gtr1evk47jqd">metadata</a></span><span class="c0 c5"><a class="c4" href="#id.gtr1evk47jqd">Â </a></span><span class="c6 c2"><a class="c4" href="#id.gi9xowfrmnlw">classMemberDefinition</a></span><span class="c2">)</span><span class="c2">*</span><span class="c2">Â &#39;}&#39;<br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.g3i7hntbrzmw"></a><p class="c13"><span class="c2 c5">mixins:<br></span><span class="c2">Â  Â  Â  </span><span class="c0 c2 c5">with</span><span class="c32 c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.adfwlw3tslsh">Â </a></span><span class="c7 c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.adfwlw3tslsh">typeList<br></a></span><span class="c2">Â  Â  ;</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span class="c3 c2">Mixin clauses are not yet supported.</span><span class="c3 c2"><br></span><span class="c2"><br></span><a href="#" name="id.gi9xowfrmnlw"></a><span class="c2 c5">classMemberDefinition:</span><span class="c2"><br> Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#id.723wzts63cdy">declaration</a></span><span class="c2">Â &#39;;&#39;<br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.z6otqtmvmk16">methodSignature</a></span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.twypn7sgnd3j">functionBody</a></span><span class="c2"><br> Â  Â ;<br></span></p><p class="c8"><span></span></p><a href="#" name="id.z6otqtmvmk16"></a><p class="c13"><span class="c2 c5">methodSignature:</span></p><p class="c13"><span class="c2">Â  Â  Â  </span><span class="c6 c2"><a class="c4" href="#kix.hw33d2of06k2">constructorSignature</a></span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.rzzedc987gnp">initializers</a></span><span class="c2">?</span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.xcry94lhv85u">factoryConstructorSignature</a></span><span class="c2"><br> Â  Â | </span><span class="c0 c5">static</span><span class="c2">? </span><span class="c6 c2"><a class="c4" href="#id.7ttlaph5nhkh">functionSignature</a></span><span class="c2"><br> Â  Â | </span><span class="c0 c5">static</span><span class="c2">? </span><span class="c6 c2"><a class="c4" href="#id.utm3o466r3od">getterSignature</a></span></p><p class="c13"><span class="c2">Â  Â  | </span><span class="c0 c5">static</span><span class="c2">? </span><span class="c6 c2"><a class="c4" href="#id.qdrk084cdrn3">setterSignature</a></span></p><p class="c13"><span class="c2">Â  Â  | </span><span class="c6 c2"><a class="c4" href="#id.6nkf54b7sdlk">operatorSignature</a></span><span class="c2"><br> Â  Â ;<br><br></span><a href="#" name="id.723wzts63cdy"></a><span class="c2 c5">declaration</span><span class="c2 c5">:</span><span class="c2"><br> Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#id.v89lf7v68kxd">constantConstructorSignature</a></span><span class="c2">Â (</span><span class="c6 c2"><a class="c4" href="#id.esidjylk5k5o">redirection</a></span><span class="c2">Â | </span><span class="c6 c2"><a class="c4" href="#id.rzzedc987gnp">initializers</a></span><span class="c2">)?<br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#kix.hw33d2of06k2">constructorSignature</a></span><span class="c2">Â (</span><span class="c6 c2"><a class="c4" href="#id.esidjylk5k5o">redirection</a></span><span class="c2">Â | </span><span class="c6 c2"><a class="c4" href="#id.rzzedc987gnp">initializers</a></span><span class="c2">)?</span></p><p class="c13"><span class="c2">Â  Â  |</span><span class="c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.utm3o466r3od">Â </a></span><span class="c0 c5"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.utm3o466r3od">external</a></span><span class="c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.v89lf7v68kxd">Â </a></span><span class="c6 c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.v89lf7v68kxd">constantConstructorSignature</a></span></p><p class="c13"><span class="c2">Â  Â  |</span><span class="c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.utm3o466r3od">Â </a></span><span class="c0 c5"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.utm3o466r3od">external</a></span><span><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=kix.hw33d2of06k2">Â </a></span><span class="c6 c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=kix.hw33d2of06k2">constructorSignature</a></span></p><p class="c13"><span class="c2">Â  Â  |</span><span class="c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.utm3o466r3od">Â </a></span><span class="c0 c5"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.utm3o466r3od">external</a></span><span class="c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.xcry94lhv85u">Â </a></span><span class="c6 c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.xcry94lhv85u">factoryConstructorSignature<br></a></span><span class="c2">Â  Â  |</span><span class="c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.utm3o466r3od">Â </a></span><span>(</span><span>(</span><span class="c0 c5"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.utm3o466r3od">external static</a></span><span><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.utm3o466r3od">?))?</a></span><span class="c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.utm3o466r3od">Â </a></span><span class="c6 c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.utm3o466r3od">getterSignature</a></span></p><p class="c13"><span class="c2">Â </span><span class="c2">Â  Â |</span><span class="c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.utm3o466r3od">Â </a></span><span>((</span><span class="c0 c5"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.utm3o466r3od">external static</a></span><span><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.utm3o466r3od">?))?</a></span><span class="c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.utm3o466r3od">Â </a></span><span class="c6 c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.qdrk084cdrn3">setterSignature</a></span></p><p class="c13"><span class="c2">Â </span><span class="c2">Â  Â |</span><span class="c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.utm3o466r3od">Â </a></span><span class="c0 c5"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.utm3o466r3od">external</a></span><span><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.utm3o466r3od">?</a></span><span class="c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.6nkf54b7sdlk">Â </a></span><span class="c6 c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.6nkf54b7sdlk">operatorSignature<br></a></span><span class="c2">Â  Â  | </span><span>((</span><span class="c0 c5"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.utm3o466r3od">external static</a></span><span><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.utm3o466r3od">?))?</a></span><span class="c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.utm3o466r3od">Â </a></span><span class="c6 c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.7ttlaph5nhkh">functionSignature</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.utm3o466r3od">getterSignature</a></span></p><p class="c13"><span class="c2">Â  Â  | </span><span class="c6 c2"><a class="c4" href="#id.qdrk084cdrn3">setterSignature</a></span></p><p class="c13"><span class="c2">Â  Â  | </span><span class="c6 c2"><a class="c4" href="#id.6nkf54b7sdlk">operatorSignature</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.7ttlaph5nhkh">functionSignature</a></span><span class="c2"><br> Â  Â | </span><span class="c0 c5">static</span><span class="c0">Â (</span><span class="c0 c5">final </span><span class="c0">|</span><span class="c0 c5">Â const</span><span class="c0">)</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.qv2a3rupuer9">type</a></span><span class="c2">? </span><span class="c6 c2"><a class="c4" href="#id.uz2qeuvvrq3r">staticFinalDeclarationList</a></span></p><p class="c13"><span class="c2">Â  Â  | </span><span class="c0 c5">const</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.qv2a3rupuer9">type</a></span><span class="c2">? </span><span class="c6 c2"><a class="c4" href="#id.uz2qeuvvrq3r">staticFinalDeclarationList</a></span><span class="c2">Â  </span></p><p class="c13"><span class="c2">Â  Â  | </span><span class="c0 c5">final</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.qv2a3rupuer9">type</a></span><span class="c2">? </span><span class="c6 c2"><a class="c4" href="#id.cjgl4bau1n1l">initialized</a></span><span class="c6 c2"><a class="c4" href="#id.cjgl4bau1n1l">IdentifierList</a></span><span class="c2"><br> Â  Â | </span><span class="c0 c5">static</span><span class="c2">? (</span><span class="c0 c5">var</span><span class="c2">Â | </span><span class="c6 c2"><a class="c4" href="#id.qv2a3rupuer9">type</a></span><span class="c2">) </span><span class="c6 c2"><a class="c4" href="#id.cjgl4bau1n1l">initialized</a></span><span class="c6 c2"><a class="c4" href="#id.cjgl4bau1n1l">IdentifierList</a></span><span class="c2"><br> Â  Â ;<br></span></p><a href="#" name="id.uz2qeuvvrq3r"></a><p class="c13"><span class="c2 c5">staticFinalDeclarationList:</span><span class="c2"><br> Â  Â : </span><span class="c6 c2"><a class="c4" href="#id.ljxm87kv8in9">staticFinalDeclaration</a></span><span class="c2">Â (&#39;,&#39; </span><span class="c6 c2"><a class="c4" href="#id.ljxm87kv8in9">staticFinalDeclaration</a></span><span class="c2">)*<br> Â  Â ;<br><br></span><a href="#" name="id.ljxm87kv8in9"></a><span class="c2 c5">staticFinalDeclaration</span><span class="c2 c5">:</span><span class="c2"><br> Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2">Â &#39;=&#39; </span><span class="c6 c2"><a class="c4" href="#id.1u3vxuwrz6py">expression</a></span><span class="c2"><br> Â  Â ;<br><br><br></span><span>A</span><span>Â class has constructors, Â instance members and static members. The</span><span>Â instance members</span><span>Â of a class are its instance methods, getters, setters and instance variables. The static members of a class are its static methods, getters, setters and static variables. Â The members of a class are its static and instance members.</span></p><p class="c8"><span></span></p><p class="c13"><span>Every class has a single superclass except class </span><span class="c0">Object</span><span>Â which has no superclass. A class may implement a </span><span>number of interfaces</span><span>Â by declaring them in its </span><span class="c0 c5">implements</span><span>Â clause.</span></p><p class="c8"><span></span></p><p class="c13"><span>An </span><span class="c2">abstract class</span><span>Â is a class that is explicitly </span><span>declared</span><span>Â with the </span><span class="c0 c5">abstract</span><span>Â modifier, either by means of a class declaration or via a </span><span class="c6"><a class="c4" href="#id.cogei5ciyfcy">type alias</a></span><span>Â for a </span><span class="c6"><a class="c4" href="#id.irdsyrsz71yz">mixin application</a></span><span>. </span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c12 c2">We want different behavior for concrete classes and abstract classes. If A is intended to be abstract, we want the static checker to warn about any attempt to instantiate A, and we do not want the checker to complain about unimplemented methods in A. In contrast, if A is intended to be concrete, the checker should warn about all unimplemented methods, but allow clients to instantiate it freely.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span>The </span><span class="c2">interface of class C</span><span>Â is </span><span>an implicit interface</span><span>Â that declares instance members that correspond to the instance members declared by </span><span class="c2">C,</span><span>Â and whose direct superinterfaces are the direct superinterfaces of </span><span class="c2">C.</span><span>Â When a class name appears as a type or interface, that name denotes the interface of the class.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error if a class declares two members of the same name.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">What about a final instance variable and a setter? This case is illegal as well. If the setter is setting the variable, the variable should not be final. </span></p><p class="c13"><span class="c2"><br><br></span><span>It is a compile-time error if a class has an instance member and a static member with the same name.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">Here are simple examples, that illustrate the difference between âhas a memberâ and âdeclares a memberâ. For example, </span><span class="c0 c3">B</span><span class="c3">Â </span><span class="c3 c2">declares</span><span class="c3">Â one member named </span><span class="c0 c3">j</span><span class="c3">, but </span><span class="c3 c2">has</span><span class="c3">Â two such members - one it declares and one it inherits. The rules of inheritance determine what members a class has.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c0 c3 c5">class</span><span class="c0 c3">Â A {</span></p><p class="c13"><span class="c0 c3">Â  </span><span class="c0 c3 c5">var</span><span class="c0 c3">Â i = 0;</span></p><p class="c13"><span class="c0 c3">Â  </span><span class="c0 c3 c5">var</span><span class="c0 c3">Â j;</span></p><p class="c13"><span class="c0 c3">Â  f(x) =&gt; 3;</span></p><p class="c13"><span class="c0 c3">}</span></p><p class="c8"><span class="c0 c3"></span></p><p class="c13"><span class="c0 c3 c5">class</span><span class="c0 c3">Â B </span><span class="c0 c3 c5">extends</span><span class="c0 c3">Â A {</span></p><p class="c13"><span class="c0 c3">Â  int i = 1; // compile-time error: B has two variables with same name i</span></p><p class="c13"><span class="c0 c3">Â  </span><span class="c0 c3 c5">static</span><span class="c0 c3">Â j; // compile-time error: B has two variables with same name j</span></p><p class="c13"><span class="c0 c3">Â  </span><span class="c0 c3 c5">static</span><span class="c0 c3">Â f(x) =&gt; 3; // compile-time error: static method conflicts with instance method</span></p><p class="c13"><span class="c0 c3">}</span></p><p class="c8"><span class="c0 c3"></span></p><p class="c13"><span>It is a compile time error if a class </span><span class="c2">C</span><span>Â declares a member with the same name as </span><span class="c2">C</span><span>.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.6kuu1330zv2p"></a><h3 class="c13"><a name="h.ze2p6bhp40it"></a><span>Instance Methods</span></h3><p class="c8"><span></span></p><p class="c13"><span class="c2">Instance methods</span><span>Â are </span><span class="c7"><a class="c4" href="#kix.v3h5pp33ioek">functions</a></span><span>Â whose declarations are immediately contained within a class declaration and that are not declared </span><span class="c0 c5">static</span><span>. The instance methods of a class </span><span class="c2">C</span><span>Â are those instance methods declared by </span><span class="c2">C</span><span>Â and the instance methods inherited </span><span>by </span><span class="c2">C</span><span>Â from its superclass</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error if an instance method </span><span class="c2">m</span><span class="c1">1</span><span>Â overrides an instance member </span><span class="c2">m</span><span class="c1">2</span><span>Â and Â </span><span class="c2">m</span><span class="c1">1</span><span>Â has a different number of required parameters than </span><span class="c2">m</span><span class="c1">2</span><span>. It is a compile-time error if an instance method </span><span class="c2">m</span><span class="c1">1</span><span>Â overrides Â an instance member </span><span class="c2">m</span><span class="c1">2</span><span>Â and Â </span><span class="c2">m</span><span class="c1">1</span><span>Â has fewer optional positional parameters than </span><span class="c2">m</span><span class="c1">2</span><span>. It is a compile-time error if an instance method </span><span class="c2">m</span><span class="c1">1</span><span>Â overrides Â an instance member </span><span class="c2">m</span><span class="c1">2</span><span>Â and Â </span><span class="c2">m</span><span class="c1">1</span><span>Â does not declare all the named parameters declared by </span><span class="c2">m</span><span class="c1">2</span><span>. </span></p><p class="c8"><span></span></p><p class="c13"><span>Â It is a static warning if an instance method</span><span class="c2">Â m</span><span class="c1">1</span><span>Â overrides an instance method </span><span class="c2">m</span><span class="c1">2</span><span>Â and the type of </span><span class="c2">m</span><span class="c1">1</span><span>Â is not a </span><span>subtype</span><span>Â of the type of </span><span class="c2">m</span><span class="c1">2</span><span>. It is a static warning if an instance method </span><span class="c2">m</span><span class="c1">1</span><span>Â  overrides an instance member </span><span class="c2">m</span><span class="c1">2</span><span>, Â the signature of </span><span class="c2">m</span><span class="c1">2</span><span>Â explicitly specifies a default value for a formal parameter </span><span class="c2">p</span><span>Â and the</span><span>Â signature of </span><span class="c2">m</span><span class="c1">1</span><span>Â specifies a different default value for </span><span class="c2">p</span><span>. It is a static warning if a class </span><span class="c2">C</span><span>Â declares an instance method named </span><span class="c2">n</span><span>Â and an accessible static member named </span><span class="c2">n</span><span>Â is declared in a superclass of </span><span class="c2">C</span><span>.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c8"><span class="c25"></span></p><a href="#" name="id.qd5b7xk45uot"></a><h4 class="c13"><a name="h.8z01vn73qf90"></a><span>Operators</span></h4><p class="c8"><span></span></p><p class="c13"><span>Operators are instance methods with special names. </span></p><p class="c8"><span></span></p><a href="#" name="id.6nkf54b7sdlk"></a><p class="c13"><span class="c2 c5">operatorSignature:</span></p><p class="c13"><span class="c2">Â  Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#id.mriqqq9dwbm5">returnType</a></span><span class="c2">? </span><span class="c0 c5">operator</span><span class="c2">Â </span><span class="c2">operator</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.6xer2paz3k7q">formalParameterList</a></span><span class="c2"><br> Â  Â  Â  ;</span></p><p class="c13"><span class="c2"><br></span><a href="#" name="kix.24ocm01qa635"></a><span class="c2 c5">operator:</span><span class="c2"><br> Â  Â  Â &#39;~&#39;<br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#kix.2skk1yl46yms">binaryOperator</a></span><span class="c2"><br> Â  Â | &#39;[&#39; &#39;]&#39;<br> Â  Â | &#39;[&#39; &#39;]&#39; &#39;=&#39;</span><span class="c2"><br></span><span class="c2">Â  Â  ;<br><br></span><a href="#" name="kix.2skk1yl46yms"></a><span class="c2 c5">binaryOperator:</span><span class="c2"><br> Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#id.q23phy16kl7s">multiplicativeOperator</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.zg2oy42p83ut">additiveOperator</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.m87pll3ti0gq">shiftOperator</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.dqm1hvagt3y5">relationalOperator</a></span><span class="c2"><br> Â  Â |â==â<br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.mp6goh4wcueb">bitwiseOperator</a></span><span class="c2"><br> Â  Â ;<br></span></p><p class="c13"><span>An operator declaration is identified with built-in identifier </span><span class="c0 c5">operator.</span></p><p class="c8"><span></span></p><p class="c13"><span>The following names are allowed for user-defined operators: </span><span class="c0">&lt;, &gt;, &lt;=, &gt;=, ==, -, +, /, ~/, Â *, %, |, ^, &amp;, &lt;&lt;, &gt;&gt;, []=, [], ~. </span></p><p class="c8"><span class="c0"></span></p><p class="c13"><span>It is a compile-time error if the arity of the user-declared operator </span><span class="c0">[]=</span><span>Â is not 2.</span><span class="c0">Â </span><span>It is a compile time error if the arity of a user-declared operator with one of the names: Â </span><span class="c0">&lt;, &gt;, &lt;=, &gt;=, ==, +, /, ~/, *, %, |, ^, &amp;, &lt;&lt;, &gt;&gt;, []</span><span>Â is not 1. It is a compile time error if the arity of the user-declared operator </span><span class="c0">-</span><span>Â is not 0 or 1. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">The - operator is unique in that two overloaded versions are permitted. If the operator has no arguments, it denotes unary minus. If it h</span><span class="c3">as</span><span class="c3">Â an argument, it denotes binary subtraction. </span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span>The name of the unary operator </span><span class="c0">-</span><span>Â is </span><span class="c0">unary-</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">This device allows the two methods to be distinguished for purposes of method lookup, override and reflection.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile time error if the arity of the user-declared operator </span><span class="c0">~</span><span>Â is not 0.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error to declare an optional parameter in an operator. </span></p><p class="c8"><span class="c0"></span></p><p class="c13"><span>It is a static warning if the return type of the user-declared operator </span><span class="c0">[]=</span><span>Â is explicitly declared Â and not </span><span class="c0 c5">void</span><span>. </span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="kix.wlocpej6rvqa"></a><h3 class="c13"><a name="h.semn73yhmkb5"></a><span>Getters </span></h3><p class="c8"><span></span></p><p class="c13"><span>Getters are </span><span class="c7"><a class="c4" href="#kix.v3h5pp33ioek">functions</a></span><span>Â that are used to retrieve the values of object properties. </span></p><p class="c8"><span></span></p><a href="#" name="id.utm3o466r3od"></a><p class="c13"><span class="c2 c5">getterSignature:</span><span class="c2"><br> Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#id.mriqqq9dwbm5">returnType</a></span><span class="c2">? </span><span class="c0 c5">get</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2">Â </span></p><p class="c8"><span></span></p><p class="c13"><span>If no return type is specified, the return type of the getter </span><span>is </span><span class="c0 c5">dynamic</span><span class="c0">.</span></p><p class="c8"><span class="c0"></span></p><p class="c13"><span>A getter definition that is prefixed with the </span><span class="c0 c5">static</span><span>Â modifier defines a </span><span>static</span><span>Â getter. Otherwise, it defines an instance getter. The name of the getter is given by the identifier in the definition.</span></p><p class="c8"><span></span></p><p class="c13"><span>The instance getters of a class </span><span class="c2">C</span><span>Â are those instance getters declared by </span><span class="c2">C</span><span>Â and the instance getters inherited by </span><span class="c2">C</span><span>Â from its superclass. The static getters of a class </span><span class="c2">C</span><span>Â are those static getters declared by </span><span class="c2">C</span><span>.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error if a class has both a </span><span>getter and a method with the same name</span><span>. This restriction holds regardless of whether the getter is defined explicitly or implicitly, or whether the getter or the method are inherited or not.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">This implies that a getter can never override a method, and a method can never override a getter or field. </span></p><p class="c8"><span></span></p><p class="c13"><span>It is a static warning if a getter </span><span class="c2">m</span><span class="c1">1</span><span>Â overrides a getter </span><span class="c2">m</span><span class="c1">2</span><span>Â and the type of </span><span class="c2">m</span><span class="c1">1</span><span>Â is not a subtype of the type of </span><span class="c2">m</span><span class="c1">2</span><span>. Â It is a static warning if a class declares a static getter named </span><span class="c2">g</span><span>Â and also has a non-static setter named </span><span class="c2">v=</span><span>. It is a static warning if a class </span><span class="c2">C</span><span>Â declares an instance getter named </span><span class="c2">n</span><span>Â and an accessible static member named </span><span class="c2">v</span><span>Â or </span><span class="c2">v=</span><span>Â is declared in a superclass of </span><span class="c2">C</span><span>.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="kix.i4xvz9z9edz"></a><h3 class="c13"><a name="h.xn3nrcf01kbi"></a><span>Setters</span></h3><p class="c8"><span class="c27 c5"></span></p><p class="c13"><span>Setters are </span><span class="c7"><a class="c4" href="#kix.v3h5pp33ioek">functions</a></span><span>Â that are used to set the values of object properties.</span></p><p class="c8"><span></span></p><a href="#" name="id.qdrk084cdrn3"></a><p class="c13"><span class="c2 c5">setterSignature:</span><span class="c2"><br> Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#id.mriqqq9dwbm5">returnType</a></span><span class="c2">? </span><span class="c0 c5">set</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2">Â </span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.dbnqav8zbk9d">formalParameterList</a></span></p><p class="c8"><span></span></p><p class="c13"><span>If no return type is specified, the return type of the setter is </span><span class="c0 c5">dynamic</span><span class="c0">.</span></p><p class="c8"><span class="c0"></span></p><p class="c13"><span>A setter definition that is prefixed with the </span><span class="c0 c5">static</span><span>Â modifier defines a static setter. Otherwise, it defines an instance setter. The name of a setter is Â obtained by appending the Â string `=&#39; Â to the identifier given in its signature.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">Hence, a setter name can never conflict with, override or be overridden by a </span><span class="c3">getter or method</span><span class="c3">.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span>The instance setters of a class </span><span class="c2">C</span><span>Â are those instance setters declared by </span><span class="c2">C</span><span>Â and the instance setters inherited by </span><span class="c2">C</span><span>Â from its superclass. The static setters of a class </span><span class="c2">C</span><span>Â are those static setters declared by </span><span class="c2">C</span><span>.</span></p><p class="c8"><span class="c3"></span></p><p class="c8"><span class="c0"></span></p><p class="c13"><span>It is a compile-time error if a setterâs formal parameter list does not include exactly one required Â formal parameter </span><span class="c2">p.</span><span>Â </span><span class="c12 c2">We could enforce this via the grammar, but weâd have to specify the evaluation rules in that case.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a static warning if a setter declares a </span><span>return type </span><span>other than </span><span class="c0 c5">void</span><span>. </span><span>It is a static warning if a setter </span><span class="c2">m</span><span class="c1">1</span><span>Â overrides a setter </span><span class="c2">m</span><span class="c1">2</span><span>Â and the type of </span><span class="c2">m</span><span class="c1">1</span><span>Â is not a </span><span>subtype</span><span>Â of the type of </span><span class="c2">m</span><span class="c1">2</span><span>. It is a static warning if a class has a setter named </span><span class="c2">v=</span><span>Â with argument type </span><span class="c2">T</span><span>Â and a getter named </span><span class="c2">v</span><span>Â with return type </span><span class="c2">S</span><span>, and </span><span class="c2">T</span><span>Â may not be assigned to </span><span class="c2">S. </span><span>It is a static warning if a class Â declares a static setter named </span><span class="c2">v=</span><span>Â and also has a non-static member named </span><span class="c2">v</span><span>. It is a static warning if a class </span><span class="c2">C</span><span>Â declares an instance setter named </span><span class="c2">v=</span><span>Â and an accessible static member named </span><span class="c2">v=</span><span>Â or </span><span class="c2">v</span><span>Â is declared in a superclass of </span><span class="c2">C</span><span>.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="kix.msu37n3bbx21"></a><h4 class="c13"><a name="h.csqy2h5zh7b0"></a><span>Abstract Instance Members</span></h4><p class="c8"><span></span></p><p class="c13"><span>An </span><span class="c2">abstract method</span><span>Â (respectively </span><span class="c2">abstract getter</span><span>Â or </span><span class="c2">abstract setter</span><span>) is an instance method, getter or setter that is not declared </span><span class="c0 c5">external</span><span>Â and does not provide an implementation. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">Earlier versions of Dart required that abstract members be identified by prefixing them with an the modifier </span><span class="c12 c0 c2 c5">abstract</span><span class="c12 c2">. The elimination of this requirement is motivated by the desire to use abstract classes as interfaces. Every Dart class induces an implicit interface.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">Using an abstract class instead of an interface declaration has important advantages. An abstract class can provide default implementations; it can also provide static methods, obviating the need for service classes such as </span><span class="c12 c0">Collections</span><span class="c12 c2">Â or </span><span class="c12 c0">Lists</span><span class="c12 c2">, whose entire purpose is to group utilities related to a given type. </span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">Eliminating the requirement for an explicit modifier on members makes abstract classes more concise, making abstract classes an attractive substitute for interface declarations. </span></p><p class="c13"><span class="c12 c2">Â </span></p><p class="c8"><span></span></p><p class="c13"><span>I</span><span>nvoking an abstract method, getter or setter always results in a run-time error.</span><span>Â This must be an instance of Â </span><span class="c0">NoSuchMethodError</span><span>Â or an instance of a subclass of </span><span class="c0">NoSuchMethodError</span><span>, such as </span><span class="c0">AbstractMethodError</span><span>.</span><span class="c18">Â </span></p><p class="c8"><span class="c18"></span></p><p class="c13"><span class="c3">These errors are ordinary objects and are therefore catchable.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span>It is a static warning if an abstract member is declared or inherited in a concrete class.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c8"><span class="c12 c2"></span></p><a href="#" name="id.x0c4e7xfkarq"></a><h3 class="c13"><a name="h.vfjux7h3rxj7"></a><span>Instance Variables</span></h3><p class="c8"><span></span></p><p class="c13"><span class="c2">Instance variables</span><span>Â are </span><span class="c7"><a class="c4" href="#kix.6b1cgvgf1cyq">variables</a></span><span>Â whose declarations are immediately contained within a class declaration and that are not declared static. The instance variables of a class </span><span class="c2">C</span><span>Â are those instance variables declared by </span><span class="c2">C</span><span>Â and the instance variables inherited by </span><span class="c2">C</span><span>Â from its superclass.</span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.yh8ud94ky84"></a><h3 class="c13"><a name="h.500yt9xvog42"></a><span>Constructors</span></h3><p class="c8"><span></span></p><p class="c13"><span>A </span><span class="c2">constructor</span><span>Â is a special member that is used in instance creation expressions (</span><span class="c7"><a class="c4" href="#id.hvkbnlui8uvu">instanceCreation</a></span><span>) to produce objects. Constructors may be </span><span class="c6"><a class="c4" href="#id.e2bn3056d7ls">generative</a></span><span>Â or they may be </span><span class="c6"><a class="c4" href="#id.ue4n89yodj3k">factories</a></span><span>. </span></p><p class="c8"><span></span></p><p class="c13"><span>A </span><span class="c2">constructor name</span><span>Â always begins with the name of its immediately enclosing class, and may optionally be followed by a dot and an identifier </span><span class="c2">id.</span><span>Â It is a compile-time error if </span><span class="c2">id</span><span>Â is the name of a member declared in the immediately enclosing class. It is a compile-time error if the name of a constructor is not </span><span>a c</span><span>onstructor name. </span></p><p class="c8"><span></span></p><p class="c13"><span>Iff no constructor is specified for a class </span><span class="c2">C,</span><span>Â it implicitly has </span><span>a default constructor </span><span class="c0">C() : super() {}, , </span><span>unless </span><span class="c2">C</span><span>Â is class </span><span class="c0">Object.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.e2bn3056d7ls"></a><h4 class="c13"><a name="h.flm5xvbwhs6u"></a><span>Generative Constructors</span></h4><p class="c8"><span></span></p><p class="c13"><span>A </span><span class="c2">generative constructor</span><span>Â consists of a constructor name, a constructor parameter list, and either a redirect clause or an initializer list and </span><span>a</span><span>n optional body.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="kix.hw33d2of06k2"></a><p class="c13"><span class="c2 c5">constructorSignature:</span><span class="c2"><br> Â  Â  Â  Â  </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2">Â (&#39;.&#39; </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2">)?</span><span class="c2">Â </span><span class="c7 c2"><a class="c4" href="#id.6xer2paz3k7q">formalParameterList</a></span><span class="c2"><br> Â  Â  Â ;</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span>A </span><span class="c2">constructor parameter list </span><span>is a parenthesized, comma-separated list of formal constructor parameters. A </span><span class="c2">formal constructor parameter</span><span>Â is either a </span><span class="c7"><a class="c4" href="#id.dbnqav8zbk9d">formal parameter</a></span><span>Â or an initializing formal. An </span><span class="c2">initializing formal</span><span>Â has the form </span><span class="c0 c5">this</span><span class="c0">.id. </span><span>Â It is a compile-time error if </span><span class="c0">id</span><span>Â is not the name of an instance variable of the immediately enclosing class. It is a compile-time error if an initializing formal is used by a function other than a non-redirecting generative constructor. Â </span></p><p class="c8"><span></span></p><p class="c13"><span>If an explicit type is attached to the initializing formal, that is its static type. Otherwise, the type of an initializing formal named </span><span class="c0">id</span><span>Â is </span><span class="c2">T</span><span class="c1">id</span><span>, where </span><span class="c2">T</span><span class="c1">id </span><span>is the type of the field named </span><span class="c0">id </span><span>in the immediately enclosing class. Â It is a static warning if the static type of </span><span class="c0">id</span><span>Â is not assignable to </span><span class="c2">T</span><span class="c1">id</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>Using an initializing formal </span><span class="c0 c5">this</span><span class="c0">.id </span><span>in a formal parameter list does not introduce a formal parameter name into the scope of the constructor. However, the initializing formal does effect the type of the constructor function exactly as if </span><span>a formal parameter named </span><span class="c0">id</span><span>Â of the same type were introduced in the same position. </span></p><p class="c8"><span></span></p><p class="c13"><span>Initializing formals are executed during the execution of generative constructors detailed below. Executing an initializing formal </span><span class="c0 c5">this</span><span class="c0">.id</span><span>Â causes the field </span><span class="c0">id</span><span>Â of the immediately surrounding class to be assigned the value of the corresponding actual parameter.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">The above rule allows initializing formals to be used as optional parameters:</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">class A {</span></p><p class="c13"><span class="c3">Â  int x;</span></p><p class="c13"><span class="c3">Â  A([this.x]);</span></p><p class="c13"><span class="c3">}</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">is legal, and has the same effect as</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">class A { </span></p><p class="c13"><span class="c3">Â  int x;</span></p><p class="c13"><span class="c3">Â  A([int x]): this.x = x;</span></p><p class="c13"><span class="c3">}</span></p><p class="c13"><span class="c3">sc</span></p><p class="c8"><span></span></p><p class="c13"><span>A </span><span class="c2">fresh instance</span><span>Â is an instance whose identity is distinct from any previously allocated instance of its class. A generative constructor always operates on a </span><span>fresh instance </span><span>of its immediately enclosing class. </span><span class="c25">The above holds if the constructor is actually run, as it is by </span><span class="c0 c25 c5">new</span><span class="c0 c25">.</span><span class="c25">Â If a constructor </span><span class="c25 c2">c</span><span class="c25">Â is referenced by </span><span class="c0 c25 c5">const</span><span class="c0 c25">,</span><span class="c25">Â </span><span class="c25 c2">c</span><span class="c25">Â may not be run; instead, a canonical object may be looked up. See the section on </span><span class="c7"><a class="c4" href="#id.hvkbnlui8uvu">instance creation</a></span><span class="c25">.</span></p><p class="c8"><span class="c25"></span></p><p class="c13"><span>If a generative constructor </span><span class="c2">c</span><span>Â  is not a redirecting constructor and no body is provided, then </span><span class="c2">c</span><span>Â implicitly has an empty body {}.</span></p><p class="c8"><span></span></p><a href="#" name="id.joo06zfmou7z"></a><h5 class="c13"><a name="h.mnfuvjel4wl1"></a><span>Redirecting Constructors</span></h5><p class="c8"><span></span></p><p class="c13"><span>A generative constructor may be </span><span class="c2">redirecting</span><span>, in which case its only action is to invoke another generative constructor. A redirecting constructor has no body; instead, it has a redirect clause that specifies which constructor the invocation is redirected to, and with what arguments.</span></p><p class="c8"><span></span></p><a href="#" name="id.esidjylk5k5o"></a><p class="c13"><span class="c2 c5">redirection:</span><span class="c2"><br> Â  Â  &#39;:&#39; </span><span class="c0 c5">this</span><span class="c2">Â (&#39;.&#39; </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2">)? </span><span class="c7 c2"><a class="c4" href="#kix.xl2ewwstkqba">arguments</a></span><span class="c2"><br> Â  Â ;<br></span></p><p class="c8"><span></span></p><a href="#" name="id.9ffw73x9vb3v"></a><h5 class="c13"><a name="h.7ybyo5btajop"></a><span>Initializer Lists</span></h5><p class="c8"><span></span></p><p class="c13"><span>An </span><span class="c2">initializer list</span><span>Â begins with a colon, and consists of a comma-separated list of individual </span><span class="c2">initializers</span><span>. There are two kinds of initializers.</span></p><ol class="c16" start="1"><li class="c9"><span>A </span><span class="c2">superinitializer</span><span>Â identifies a </span><span class="c2">superconstructor</span><span>Â - that is, a specific constructor of the superclass. Â Execution of the superinitializer causes the initializer list of the superconstructor to be executed.</span></li><li class="c9"><span>An </span><span class="c2">instance variable initializer</span><span>Â assigns a value to an individual instance variable. </span></li></ol><p class="c8"><span></span></p><a href="#" name="id.rzzedc987gnp"></a><p class="c13"><span class="c2 c5">initializers:</span><span class="c2"><br> Â  Â  Â &#39;:&#39; </span><span class="c7 c2"><a class="c4" href="#id.yz2abulwugs9">superCallOrFieldInitializer</a></span><span class="c2">Â (&#39;,&#39; </span><span class="c7 c2"><a class="c4" href="#id.yz2abulwugs9">superCallOrFieldInitializer</a></span><span class="c2">)*<br> Â  Â ;<br></span></p><a href="#" name="id.yz2abulwugs9"></a><p class="c13"><span class="c2 c5">superCallOrFieldInitializer:</span><span class="c2"><br> Â  Â  Â </span><span class="c0 c5">super</span><span class="c2">Â </span><span class="c7 c2"><a class="c4" href="#kix.xl2ewwstkqba">arguments</a></span><span class="c2"><br> Â  Â | </span><span class="c0 c5">super</span><span class="c2">Â &#39;.&#39; </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2">Â </span><span class="c7 c2"><a class="c4" href="#kix.xl2ewwstkqba">arguments</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.4ncl8xtqfh3z">fieldInitializer</a></span><span class="c2"><br> Â  Â ;<br></span></p><a href="#" name="id.4ncl8xtqfh3z"></a><p class="c13"><span class="c2 c5">fieldInitializer:</span><span class="c2"><br> Â  Â  Â  Â (</span><span class="c0 c5">this</span><span class="c2">Â &#39;.&#39;)? </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2">Â &#39;=&#39; </span><span class="c6 c2"><a class="c4" href="#id.u42blbh7fdm7">conditionalExpression</a></span><span class="c2">Â cascadeSection*</span><span class="c2"><br> Â  Â ;</span></p><p class="c8"><span class="c2"><br></span></p><p class="c13"><span>Let </span><span class="c2">k</span><span>Â be a generative constructor. Then </span><span class="c2">k</span><span>Â may include at most one superinitializer in its initializer list or a compile time error occurs. Â If no superinitializer is provided, an implicit superinitializer of the form </span><span class="c0">super()</span><span>Â is added at the end of </span><span class="c2">k</span><span>âs Â initializer list, unless the enclosing class is class </span><span class="c0">Object</span><span>. It is </span><span>a</span><span>Â compile time error if </span><span>more than one initializer</span><span>Â corresponding to a given instance variable appears in </span><span class="c2">k</span><span>âs list. It is </span><span>a</span><span>Â compile time error if </span><span class="c2">k</span><span>âs Â initializer list contains an initializer for a variable that is initialized by means of an initializing formal of </span><span class="c2">k. </span><span>It is </span><span>a</span><span>Â compile time error if </span><span class="c2">k</span><span>âs Â initializer list contains an initializer for a final variable </span><span class="c2">f</span><span>Â whose declaration includes an initialization expression.</span></p><p class="c13"><span>Â </span></p><p class="c13"><span>E</span><span>ach final instance variable </span><span class="c2">f </span><span>declared in the immediately enclosing class must have an initializer in </span><span class="c2">k</span><span>&#39;s initializer list unless it has already been initialized by one of the following means:</span></p><ol class="c16" start="1"><li class="c9"><span>Initialization at the declaration of </span><span class="c2">f.</span></li><li class="c9"><span>Initialization by means of an initializing formal of </span><span class="c2">k.</span></li></ol><p class="c8"><span></span></p><p class="c13"><span>or a compile-time error occurs. It is a compile-time error if </span><span class="c2">k</span><span>&#39;s initializer list contains an initializer for a variable that is not an instance variable declared in the immediately surrounding class.</span></p><p class="c13"><span>Â </span></p><p class="c13"><span class="c3">The Â initializer list may of course contain an initializer for any instance variable declared by the immediately surrounding class, even if it is not final. </span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error if a generative constructor of class </span><span class="c0">Object</span><span>Â includes a superinitializer.</span></p><p class="c8"><span></span></p><p class="c13"><span>Execution of a generative constructor </span><span class="c2">k</span><span>Â is always done with respect to a set of bindings for its formal parameters and with </span><span class="c0 c5">this</span><span>Â bound to a fresh instance </span><span class="c2">i</span><span>Â and the type parameters of the immediately enclosing class bound to a set of actual type arguments </span><span class="c2">V</span><span class="c1">1</span><span class="c2">, ... , V</span><span class="c1">m</span><span>. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">These bindings are usually determined by the </span><span class="c12 c32"><a class="c4" href="#id.pp0ymlz8g03s">instance creation expression</a></span><span class="c12">Â </span><span class="c3">that invoked the constructor. Â However, they may also be determined by a reflective call, or by a call from another (redirecting) constructor.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span>If </span><span class="c2">k</span><span>Â is redirecting, , then its redirect clause has the form </span><span class="c0 c5">this</span><span>.</span><span class="c2">g(a</span><span class="c1">1</span><span class="c2">, â¦, a</span><span class="c1">n</span><span class="c2">, x</span><span class="c1">n+1</span><span class="c2">: a</span><span class="c1">n+1</span><span class="c2">, â¦, x</span><span class="c1">n+k</span><span class="c2">: a</span><span class="c1">n+k</span><span class="c2">)</span><span>Â where </span><span class="c2">g</span><span>Â identifies another generative constructor of the immediately surrounding class. Then execution of </span><span class="c2">k</span><span>Â proceeds by evaluating the argument list </span><span class="c2">(a</span><span class="c1">1</span><span class="c2">, â¦, a</span><span class="c1">n</span><span class="c2">, x</span><span class="c1">n+1</span><span class="c2">: a</span><span class="c1">n+1</span><span class="c2">, â¦, x</span><span class="c1">n+k</span><span class="c2">: a</span><span class="c1">n+k</span><span class="c2">)</span><span>, and then executing </span><span class="c2">g</span><span>Â with respect to the bindings resulting from the evaluation of </span><span class="c2">(a</span><span class="c1">1</span><span class="c2">, â¦, a</span><span class="c1">n</span><span class="c2">, x</span><span class="c1">n+1</span><span class="c2">: a</span><span class="c1">n+1</span><span class="c2">, â¦, x</span><span class="c1">n+k</span><span class="c2">: a</span><span class="c1">n+k</span><span class="c2">)</span><span>Â and with </span><span class="c0 c5">this</span><span>Â bound to </span><span class="c2">i</span><span>Â and the type parameters of the immediately enclosing class bound to </span><span class="c2">V</span><span class="c1">1</span><span class="c2">, ... , V</span><span class="c1">m</span><span>. </span></p><p class="c8"><span></span></p><p class="c13"><span>Otherwise, execution Â proceeds as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>Any initializing formals declared in </span><span class="c2">k</span><span>&#39;s parameter list are executed in the order they appear in the program. Â Then, </span><span class="c2">k</span><span>&#39;</span><span>s</span><span>Â initializers are executed in the order they appear in the program.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">We could observe the order by side effecting external routines called. So we need to specify the order.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span>After all the </span><span>initializers</span><span>Â have completed, the body of </span><span class="c2">k</span><span>Â is executed in a scope where </span><span class="c0 c5">this</span><span>Â is bound to </span><span class="c2">i.</span><span>Â Execution of the body begins with execution of the body of the superconstructor with </span><span class="c0 c5">this</span><span>Â bound to </span><span class="c2">i,</span><span>Â the type parameters of the immediately enclosing class bound to a set of actual type arguments </span><span class="c2">V</span><span class="c1">1</span><span class="c2">, ... , V</span><span class="c1">m</span><span>Â  and the formal parameter </span><span>bindings determined by the argument list of the superinitializer</span><span>Â of </span><span class="c2">k.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">This process ensures that no uninitialized final field is ever seen by code. Note that </span><span class="c0 c5 c7"><a class="c4" href="#id.v2khzso6nh04">this</a></span><span class="c12 c2">Â </span><span class="c12 c2">Â is not in scope on the right hand side of an initializer so no instance method can execute during initialization: an instance method cannot be directly invoked, nor can </span><span class="c12 c0 c5">this</span><span class="c12 c2">Â be passed into any other code being invoked in the initializer. </span></p><p class="c8"><span></span></p><p class="c13"><span>Execution of an initializer of the form </span><span class="c0 c5">this</span><span class="c2">.v = e</span><span>Â proceeds as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>First, the expression </span><span class="c2">e</span><span>Â is evaluated to an object </span><span class="c2">o.</span><span>Â Then, the instance variable </span><span class="c2">v</span><span>Â of the object denoted by </span><span class="c0 c5">this</span><span>Â is bound to </span><span class="c2">o.</span><span>Â In checked mode, it is a dynamic type error if </span><span class="c2">o</span><span>Â is not </span><span class="c0 c5">null</span><span>Â and the interface of the class of </span><span class="c2">o</span><span>Â is not a subtype of the </span><span class="c7"><a class="c4" href="#id.93yudg3nk9o1">actual type</a></span><span>Â of the field </span><span class="c2">v</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>An initializer of the form </span><span class="c2">v = e</span><span>Â is equivalent to an initializer of the form </span><span class="c0 c5">this</span><span class="c2">.v = e.</span><span>Â </span></p><p class="c8"><span></span></p><p class="c13"><span>Execution of a superinitializer of the form </span><span class="c0 c5">super</span><span class="c2">(a</span><span class="c1">1</span><span class="c2">, â¦, a</span><span class="c1">n</span><span class="c2">, x</span><span class="c1">n+1</span><span class="c2">: a</span><span class="c1">n+1</span><span class="c2">, â¦, x</span><span class="c1">n+k</span><span class="c2">: a</span><span class="c1">n+k</span><span class="c2">) </span><span>(respectively </span><span class="c0 c5">super</span><span class="c0 c2">.id</span><span class="c2">(a</span><span class="c1">1</span><span class="c2">, â¦, a</span><span class="c1">n</span><span class="c2">, x</span><span class="c1">n+1</span><span class="c2">: an+1, â¦, x</span><span class="c1">n+k</span><span class="c2">: a</span><span class="c1">n+k</span><span class="c2">)</span><span>)</span><span class="c2">Â </span><span>proceeds as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>First, the argument list </span><span class="c2">(a</span><span class="c1">1</span><span class="c2">, â¦, a</span><span class="c1">n</span><span class="c2">, x</span><span class="c1">n+1</span><span class="c2">: a</span><span class="c1">n+1</span><span class="c2">, â¦, x</span><span class="c1">n+k</span><span class="c2">: a</span><span class="c1">n+k</span><span class="c2">)</span><span>Â is evaluated.</span></p><p class="c13"><span>Let </span><span class="c2">C</span><span>Â be the class in which the superinitializer appears and let </span><span class="c2">S</span><span>Â be the superclass of </span><span class="c2">C. </span><span>Â If </span><span class="c2">S</span><span>Â is </span><span class="c7"><a class="c4" href="#id.64iudgj9wjj1">generic</a></span><span>, let </span><span class="c2">U</span><span class="c1">1</span><span class="c2">, ,.., U</span><span class="c1">m</span><span class="c2">Â </span><span>be the actual type arguments passed to </span><span class="c2">S</span><span>Â in the superclass clause of </span><span class="c2">C.</span></p><p class="c8"><span></span></p><p class="c13"><span>Then, the initializer list of the constructor </span><span class="c2">S</span><span>Â (respectively </span><span class="c2">S.id</span><span>) is </span><span>executed with respect</span><span>Â to the bindings that resulted from the evaluation of the argument list, Â with </span><span class="c0 c5">this</span><span>Â bound to the current binding of </span><span class="c0 c5">this,</span><span>Â and Â the type parameters (if any) of class </span><span class="c2">S</span><span>Â bound to the current binding of </span><span class="c2">U</span><span class="c1">1</span><span class="c2">, ,.., U</span><span class="c1">m</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time </span><span>error</span><span>Â if class </span><span class="c2">S</span><span>Â does not declare a generative constructor named </span><span class="c2">S</span><span>Â (respectively </span><span class="c2">S.id</span><span>)</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.ue4n89yodj3k"></a><h4 class="c13"><a name="h.1t7lgvdmbwt9"></a><span>Factories</span></h4><p class="c8"><span></span></p><p class="c13"><span>A </span><span class="c2">factory</span><span>Â is a constructor prefaced by the built-in identifier </span><span class="c0 c5">factory</span><span>. </span></p><p class="c8"><span class="c18"></span></p><a href="#" name="id.xcry94lhv85u"></a><p class="c13"><span class="c2 c5">factoryConstructorSignature:</span><span class="c2"><br> Â  Â </span><span class="c2">Â  </span><span class="c0 c5">factory</span><span class="c2">Â identifier (&#39;.&#39; </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2">)? </span><span class="c7 c2"><a class="c4" href="#id.6xer2paz3k7q">formalParameterList</a></span><span class="c2"><br> Â  Â ;</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span>The </span><span class="c2">return type</span><span>Â of a factory whose signature is of the form </span><span class="c0 c2 c5">factory</span><span class="c2">Â M </span><span>or the form </span><span class="c0 c2 c5">factory</span><span class="c2">Â M.id </span><span>is </span><span class="c2">M </span><span>if </span><span class="c2">M</span><span>Â is not a generic type; otherwise the return type is </span><span class="c2">M &lt;T</span><span class="c10 c2">1</span><span class="c2">, â¦, T</span><span class="c10 c2">n</span><span class="c2">&gt;, </span><span>where </span><span class="c2">T</span><span class="c10 c2">1</span><span class="c2">, â¦, T</span><span class="c10 c2">n </span><span>are the type parameters of the enclosing class.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>It is a static warning if </span><span class="c2">M.id</span><span>Â is not a constructor name.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>It is a compile-time error if </span><span class="c2">M </span><span>is not the Â </span><span>name</span><span>Â  of the immediately enclosing class. </span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>In checked mode, it is a </span><span>dynamic type error</span><span>Â if a factory returns an object whose type is not a subtype of its </span><span class="c7"><a class="c4" href="#id.93yudg3nk9o1">actual return type</a></span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">It seems useless to allow a factory to </span><span class="c12 c2">return null</span><span class="c12 c2">. But it is more uniform to allow it, as the rules currently do.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">Factories address classic weaknesses associated with constructors in other languages.</span></p><p class="c13"><span class="c12 c2">Factories can produce instances that are not freshly allocated: they can come from a cache. Likewise, factories can return instances of different classes. </span></p><p class="c8"><span class="c12 c2"></span></p><a href="#" name="id.l359w0dwudiw"></a><h5 class="c13"><a name="h.bt41dzw03qig"></a><span>Redirecting Factory Constructors</span></h5><p class="c8"><span></span></p><p class="c13"><span class="c2">Redirecting factory constructors are only partially implemented in M2.</span></p><p class="c8"><span class="c27 c5"></span></p><p class="c13"><span>A </span><span class="c2">redirecting factory constructor</span><span>Â specifies a call to a </span><span>constructor of another class</span><span>Â that is to be used whenever the redirecting constructor is called.</span></p><p class="c8"><span></span></p><a href="#" name="id.i9rp84d7qg8p"></a><p class="c13"><span class="c2 c5">redirectingFactoryConstructorSignature:<br></span><span class="c2">Â  Â  Â  </span><span class="c0 c5">const</span><span class="c2">? </span><span class="c0 c5">factory</span><span class="c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.te0njh1fhw7g">Â  </a></span><span class="c6 c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.te0njh1fhw7g">identifier</a></span><span class="c2">Â  (&#39;.&#39;</span><span class="c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.te0njh1fhw7g">Â </a></span><span class="c6 c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.te0njh1fhw7g">identifier</a></span><span class="c2">)?</span><span class="c2">Â  </span><span class="c7 c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.6xer2paz3k7q">formalParameterList</a></span><span class="c2">Â </span><span class="c2">`=â </span><span class="c6 c2"><a class="c4" href="#id.op3nw89imb4w">type</a></span><span class="c2">Â (&#39;.&#39;</span><span class="c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.te0njh1fhw7g">Â </a></span><span class="c6 c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.te0njh1fhw7g">identifier</a></span><span class="c2">)?<br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>Calling a redirecting factory constructor </span><span class="c2">k </span><span>causes the constructor </span><span class="c2">kâ</span><span>Â denoted by </span><span class="c2">type </span><span>(respectively, </span><span class="c2">type.identifier</span><span>) to be called with the actual arguments passed to </span><span class="c2">k,</span><span>Â and returns the result of </span><span class="c2">kâ </span><span>as the result of </span><span class="c2">k</span><span>. The resulting constructor call is governed by the same rules as an instance creation expression using </span><span class="c6 c0 c5"><a class="c4" href="#id.pp0ymlz8g03s">new</a></span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">It follows that if </span><span class="c3 c2">type</span><span class="c3">Â or </span><span class="c3 c2">type.id</span><span class="c3">Â are not defined, or do not refer to a class or constructor, a dynamic error occurs, as with any other undefined constructor call. The same holds if </span><span class="c3 c2">k</span><span class="c3">Â has more optional positional parameters than </span><span class="c3 c2">kâ</span><span class="c3">Â or if </span><span class="c3 c2">k </span><span class="c3">Â has a named parameter that is not declared by </span><span class="c3 c2">kâ</span><span class="c3">. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">This implies that the arguments to k are always legal arguments to </span><span class="c3 c2">kâ</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error if a redirecting factory constructor redirects to itself, either directly or indirectly via a sequence of redirections. </span></p><p class="c8 c44"><span></span></p><p class="c13"><span class="c12 c2">If a redirecting factory F</span><span class="c1 c12">1</span><span class="c12 c2">Â redirects to another redirecting factory F</span><span class="c1 c12">2</span><span class="c12 c2">Â and F</span><span class="c1 c12">2</span><span class="c12 c2">Â then redirects to F</span><span class="c1 c12">1</span><span class="c12 c2">, then both F</span><span class="c1 c12">1</span><span class="c12 c2">Â and F</span><span class="c1 c12">2</span><span class="c12 c2">Â are undefined. Such cycles are therefore illegal.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a </span><span>static warning</span><span>Â if </span><span class="c2">type</span><span>Â does not denote a class accessible in the current scope; if </span><span class="c2">type</span><span>Â does denote such a class </span><span class="c2">C</span><span>Â it is a static warning if the referenced constructor (be it </span><span class="c2">type</span><span>Â or </span><span class="c2">type.id</span><span>) is not a constructor of </span><span class="c2">C</span><span>.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">Note that it is not possible to modify the arguments being passed to Â kâ. This is a deliberate decision, so that kâ can easily determine what arguments were actually passed by the caller.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">At first glance, one might think that ordinary factory constructors could simply create instances of other classes and return them, and that redirecting factories are unnecessary. However, redirecting factories have several advantages:</span></p><ol class="c16" start="1"><li class="c9"><span class="c12 c2">An abstract class may provide a constant constructor that utilizes the constant constructor of another class.</span></li><li class="c9"><span class="c12 c2">A constructor to which calls are being redirected can determine whether any user arguments were explicitly passed.</span></li><li class="c9"><span class="c12 c2">A redirecting factory constructor avoids the need for forwarders to repeat the default values for formal parameters in their signatures.</span></li></ol><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error if </span><span class="c2">k</span><span>Â is prefixed with the </span><span class="c0 c5">const</span><span>Â modifier but </span><span class="c2">kâ</span><span>Â is not a </span><span class="c6"><a class="c4" href="#id.okcph2t66jnm">constant constructor</a></span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a </span><span>static warning </span><span>if the function type of </span><span class="c2">kâ</span><span>Â is not a </span><span>subtype</span><span>Â of the type of </span><span class="c2">k</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">This implies that the resulting object conforms to the interface of the immediately enclosing class of </span><span class="c3 c2">k</span><span class="c3">.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span>It is a </span><span>static type warning</span><span>Â if any of the type arguments to </span><span class="c2">kâ</span><span>Â are not subtypes of the bounds of the corresponding formal type parameters of </span><span class="c2">type</span><span class="c2">.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.okcph2t66jnm"></a><h4 class="c13"><a name="h.gk4elj1gohb4"></a><span>Constant Constructors</span></h4><p class="c8"><span></span></p><p class="c13"><span>A </span><span class="c2">constant constructor</span><span>Â may be used to create compile-time constant </span><span>objects.</span><span>Â A constant constructor is prefixed by the reserved word </span><span class="c0 c5">const.</span><span>Â </span></p><p class="c8"><span></span></p><a href="#" name="id.v89lf7v68kxd"></a><p class="c13"><span class="c2 c5">constantConstructorSignature:</span><span class="c2"><br> Â  Â  Â </span><span class="c0 c5">const</span><span class="c2">Â qualified </span><span class="c7 c2"><a class="c4" href="#id.6xer2paz3k7q">formalParameterList</a></span><span class="c2"><br> Â  Â ;</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">All the work of a constant constructor must be handled via its initializers.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span>It is a compile-time error if a constant constructor is declared by a class that has a non-final instance variable. </span></p><p class="c13"><span class="c3">The above refers to both locally declared and inherited instance variables.</span></p><p class="c13"><span>Any expression that appears within the initializer list of a constant constructor must be a potentially constant expression, or a compile-time error occurs.</span></p><p class="c8"><span></span></p><p class="c13"><span>A </span><span class="c2">potentially constant expression</span><span>Â is an expression </span><span class="c2">e</span><span>Â that would be a valid constant expression if all formal parameters of </span><span class="c2">e</span><span>âs immediately enclosing constant constructor were treated as compile-time constants </span><span>that were guaranteed to evaluate to an integer, boolean or string value </span><span>as required by their immediately enclosing superexpression.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">The difference between a potentially constant expression and a </span><span class="c7"><a class="c4" href="#id.hzs87hup8wb">compile-time constant</a></span><span class="c3">Â expression deserves some explanation. </span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">The key issue is whether one treats the formal parameters of a constructor as compile-time constants. </span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">If a constant constructor is invoked from a constant object expression, the actual arguments will be required to be compile-time constants. Therefore, if we were assured that constant constructors were always invoked from constant object expressions, we could assume that the formal parameters of a constructor were compile-time constants.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">However, constant constructors can also be invoked from </span><span class="c7"><a class="c4" href="#id.pp0ymlz8g03s">ordinary instance creation expressions</a></span><span class="c3">, and so the above assumption is not generally valid.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">Nevertheless, the use of the formal parameters of a constant constructor within the constructor is of considerable utility. The concept of potentially constant expressions is introduced to facilitate limited use of such formal parameters. Specifically, we allow the usage of the formal parameters of a constant constructor for expressions that involve built-in operators, but not for constant objects, lists and maps. This allows for constructors such as:</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c0 c3 c5">class</span><span class="c0 c3">Â C {</span></p><p class="c13"><span class="c0 c3">Â  </span><span class="c0 c3 c5">final</span><span class="c0 c3">Â x; </span><span class="c0 c3 c5">final</span><span class="c0 c3">Â y; </span><span class="c0 c3 c5">final</span><span class="c0 c3">Â z;</span></p><p class="c13"><span class="c0 c3">Â  </span><span class="c0 c3 c5">const</span><span class="c0 c3">Â C(p, q): x = q, y = p + 100, z = p + q;</span></p><p class="c13"><span class="c0 c3">}</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">The assignment to </span><span class="c0 c3">x</span><span class="c3">Â is allowed under the assumption that </span><span class="c0 c3">q</span><span class="c3">Â is a compile-time constant (even though </span><span class="c0 c3">q</span><span class="c3">Â is not, in general a compile-time constant). Â The assignment to </span><span class="c0 c3">y</span><span class="c3">Â is similar, but raises additional questions. In this case, the superexpression of </span><span class="c0 c3">p</span><span class="c3">Â is </span><span class="c0 c3">p + 100,</span><span class="c3">Â and it requires that </span><span class="c0 c3">p</span><span class="c3">Â be a numeric compile-time constant for the entire expression to be considered constant. Â The wording of the specification allows us to assume that </span><span class="c0 c3">p</span><span class="c3">Â evaluates to an integer. A similar argument holds for </span><span class="c0 c3">p</span><span class="c3">Â and </span><span class="c0 c3">q</span><span class="c3">Â in the assignment to </span><span class="c0 c3">z.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">However, the following constructors are disallowed:</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c0 c3 c5">class</span><span class="c0 c3">Â D {</span></p><p class="c13"><span class="c0 c3">Â  </span><span class="c0 c3 c5">final</span><span class="c0 c3">Â w;</span></p><p class="c13"><span class="c0 c3">Â  </span><span class="c0 c3 c5">const</span><span class="c0 c3">Â D.makeList(p): w = </span><span class="c0 c3 c5">const</span><span class="c0 c3">Â </span><span class="c0 c3">[p]; Â // compile-time error</span></p><p class="c13"><span class="c0 c3 c5">Â  const</span><span class="c0 c3">Â D.makeMap(p): w = </span><span class="c0 c3 c5">const</span><span class="c0 c3">Â {âhelpâ: p}; // compile-time error</span></p><p class="c13"><span class="c0 c3">Â  </span><span class="c0 c3 c5">const</span><span class="c0 c3">Â D.makeC(p): w = </span><span class="c0 c3 c5">const</span><span class="c0 c3">Â C(p, 12); // compile-time error</span></p><p class="c13"><span class="c0 c3">}</span></p><p class="c8"><span class="c0 c3"></span></p><p class="c13"><span class="c3">The problem is not that the assignments to </span><span class="c0 c3">w</span><span class="c3">Â are not potentially constant; they are. Â However, all these run afoul of the rules for constant lists, maps and objects, all of which independently require their subexpressions to be constant expressions.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c12 c2">All of the illegal constructors of D above could not be sensibly invoked via </span><span class="c12 c0 c2 c5">new</span><span class="c12 c2">,</span><span class="c12 c2">Â because an expression that must be constant cannot depend on a formal parameter, which may or may not be constant. In contrast, the legal examples make sense regardless of whether the constructor is invoked via </span><span class="c12 c0 c2 c5">const</span><span class="c12 c2">Â or via </span><span class="c12 c0 c2 c5">new</span><span class="c12 c2">. </span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">Careful readers will of course worry about cases where the actual arguments to </span><span class="c12 c0 c2">C()</span><span class="c12 c2">Â are constants, but are not of appropriate type. This is precluded by the following rule, combined with the </span><span class="c32 c12 c2"><a class="c4" href="#id.bfpdh2tlvt0v">rules for evaluating constant objects</a></span><span class="c12 c2">.</span></p><p class="c8"><span></span></p><p class="c13"><span>When invoked from a constant object expression, a constant constructor must throw an exception if any of its actual parameters</span><span>Â  </span><span>is a value that would prevent one of the potentially constant expressions within it to from being a valid compile-time constant.</span></p><p class="c8"><span></span></p><a href="#" name="id.y3ufp36d01bv"></a><h3 class="c13"><a name="h.i641x57pmqjt"></a><span>Static Methods</span></h3><p class="c8"><span></span></p><p class="c13"><span class="c2">Static methods</span><span>Â are </span><span class="c7"><a class="c4" href="#kix.v3h5pp33ioek">functions</a></span><span>Â whose declarations are immediately contained within a class declaration and that are declared </span><span class="c0 c5">static</span><span>. The static methods of a class </span><span class="c2">C</span><span>Â are those static methods declared by </span><span class="c2">C</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">Inheritance of static methods has little utility in Dart. Static methods cannot be overridden. Any required static function can be obtained from its declaring library, and there is no need to bring it into scope via inheritance. Experience shows that developers are confused by the idea of inherited methods that are not instance methods.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">Of course, the entire notion of static methods is debatable, but it is retained here because so many programmers are familiar with it. Dart static methods may be seen as functions of the enclosing library. </span></p><p class="c8"><span></span></p><p class="c8"><span class="c3"></span></p><p class="c8"><span></span></p><a href="#" name="id.4vjq3uijqjm"></a><h3 class="c13"><a name="h.1k2j0ywtrfjj"></a><span>Static Variables</span></h3><p class="c8"><span></span></p><p class="c13"><span class="c2">Static variables</span><span>Â are </span><span class="c7"><a class="c4" href="#kix.6b1cgvgf1cyq">variables</a></span><span>Â whose declarations are immediately contained within a class declaration and that are declared </span><span class="c0 c5">static.</span><span>Â The static variables of a class </span><span class="c2">C</span><span>Â are those static variables declared by </span><span class="c2">C</span><span>.</span></p><p class="c13"><span>Â </span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.7ugexyrtn1zr"></a><h3 class="c13"><a name="h.9no0amy1hz2x"></a><span>Superclasses</span></h3><p class="c8"><span></span></p><p class="c13"><span>The superclass of a class </span><span class="c2">C</span><span>Â that has a with clause </span><span class="c0 c5">with</span><span>Â </span><span class="c2">M</span><span class="c10 c2">1</span><span class="c2">, â¦, M</span><span class="c10 c2">k</span><span>Â and an extends clause </span><span class="c0 c5">extends</span><span>Â S is the application of the </span><span class="c6"><a class="c4" href="#id.hfiy4m46snbm">mixin</a></span><span>Â </span><span class="c2">M</span><span class="c10 c2">k</span><span class="c2">* .. * M</span><span class="c10 c2">1</span><span>Â  to </span><span class="c2">S</span><span>. Â If no </span><span class="c0 c5">with</span><span>Â clause is specified then t</span><span>he </span><span class="c0 c5">extends</span><span>Â clause of a class </span><span class="c2">C</span><span>Â specifies its superclass. If no </span><span class="c0 c5">extends</span><span>Â clause is specified, then either:</span></p><ol class="c16" start="1"><li class="c9"><span class="c2">C</span><span>Â is Object, which has no superclass. OR</span></li></ol><ol class="c16" start="1"><li class="c9"><span>Class </span><span class="c2">C</span><span>Â is deemed to have an </span><span class="c0 c5">extends</span><span>Â clause of the form </span><span class="c0 c5">extends </span><span>Object, and the rules above apply.</span></li></ol><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error to specify an </span><span class="c0 c5">extends</span><span>Â clause for class </span><span class="c0">Object</span><span>.</span></p><p class="c13"><span class="c2"><br></span><a href="#" name="id.frtqvspfkgww"></a><span class="c2 c5">superclass:</span><span class="c2"><br> Â  Â  Â </span><span class="c0 c5">extends</span><span class="c2">Â </span><span class="c7 c2"><a class="c4" href="#id.qv2a3rupuer9">type</a></span><span class="c2"><br> Â  Â ;</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error if</span><span>Â t</span><span>he </span><span class="c0 c5">extends</span><span>Â clause of a class </span><span class="c2">C</span><span>Â includes a type expression that does not denote a class available in the lexical scope of </span><span class="c2">C.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span class="c3">The type parameters of a generic class are available in the lexical scope of the superclass clause, potentially shadowing classes in the surrounding scope. The following code is therefore illegal and should cause a compile-time error:</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">class T{}</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">class G&lt;T&gt; extends T {} // Compilation error: Attempt to subclass a type parameter</span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span class="c2">A</span><span>Â class </span><span class="c2">S</span><span>Â is </span><span class="c2">a superclass of</span><span>Â a class </span><span class="c2">C</span><span>Â iff either:</span></p><ol class="c16" start="1"><li class="c9"><span>Â </span><span class="c2">S</span><span>Â is the superclass of </span><span class="c2">C,</span><span>Â or</span><span class="c2">Â </span></li><li class="c9"><span class="c2">S</span><span>Â is a superclass of a class </span><span class="c2">Sâ </span><span>and </span><span class="c2">Sâ</span><span>Â is a superclass of </span><span class="c2">C. </span></li></ol><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error if a class </span><span class="c2">C</span><span>Â is a superclass of itself.</span></p><p class="c8"><span></span></p><p class="c8"><span class="c3"></span></p><a href="#" name="id.lodslm1bek9u"></a><h4 class="c13"><a name="h.n9p3c8rq84d5"></a><span>Inheritance and Overriding</span></h4><p class="c8"><span></span></p><p class="c13"><span>A class </span><span class="c2">C</span><span>Â </span><span class="c2">inherits</span><span>Â any instance members of its superclass </span><span>that are not overridden by instance members declared in </span><span class="c2">C.</span><span>Â </span></p><p class="c8"><span></span></p><p class="c13"><span>A class may override instance members that would otherwise have been inherited from its superclass. </span></p><p class="c8"><span></span></p><p class="c13"><span>Let </span><span class="c2">C</span><span>Â be a class declared in library </span><span class="c2">L</span><span>Â with superclass </span><span class="c2">S</span><span>Â and let </span><span class="c2">C</span><span>Â declare an instance member </span><span class="c2">m</span><span class="c2">,</span><span>Â an</span><span>d a</span><span>ssume </span><span class="c2">S </span><span>declares an instance member </span><span class="c2">mâ </span><span>with the same name as</span><span class="c2">Â m. </span><span>Then </span><span class="c2">m overrides mâ </span><span>iff </span><span class="c2">mâ</span><span>Â is </span><span class="c7"><a class="c4" href="#id.zeletzevxf8t">accessible</a></span><span>Â to</span><span class="c2">Â L</span><span>, </span><span class="c2">m</span><span>Â has the same name as </span><span class="c2">mâ</span><span>Â and neither </span><span class="c2">m</span><span>Â nor </span><span class="c2">mâ</span><span>Â are fields.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">Fields never override each other. The getters and setters induced by fields do.</span></p><p class="c8"><span></span></p><p class="c13"><span>Whether an override is legal or not is described elsewhere in this specification (see </span><span class="c6"><a class="c4" href="#id.6kuu1330zv2p">instance methods</a></span><span>, </span><span class="c6"><a class="c4" href="#kix.wlocpej6rvqa">getters</a></span><span>Â and </span><span class="c6"><a class="c4" href="#kix.i4xvz9z9edz">setters</a></span><span>). </span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">For example</span><span class="c3">Â getters and setters may not legally override methods </span><span class="c3">and </span><span class="c3">vice versa</span><span class="c3">. Â  Setters and methods never override each other, because their names always differ.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">For convenience, here is a summary of the relevant rules. Remember that this is not normative. The controlling language is in the relevant sections of the specification.</span></p><p class="c8"><span class="c3"></span></p><ol class="c20" start="1"><li class="c9"><span class="c3">There is only one namespace for getters, setters, methods and constructors (3.1). A field </span><span class="c3 c2">f</span><span class="c3">Â introduces a getter </span><span class="c3 c2">f</span><span class="c3">, and if it is not const or final, a setter </span><span class="c3 c2">f=</span><span class="c3">Â (7.5, 7.8). When we speak of members here, we mean accessible fields, getters, setters and methods (7).</span></li><li class="c9"><span class="c3">You cannot have two members with the same name in the same class - be they declared or inherited (3.1, 7).</span></li><li class="c9"><span class="c3">Static members are never inherited.</span></li><li class="c9"><span class="c3">It is a warning if you have an static member named </span><span class="c3 c2">m</span><span class="c3">Â in your class or any superclass (even though it is not inherited) and an instance member of the same name (7.1, 7.2, 7.3).</span></li><li class="c9"><span class="c3">It is a warning if you have a static setter </span><span class="c3 c2">v=</span><span class="c3">, and an instance member </span><span class="c3 c2">v</span><span class="c3">Â (7.3).</span></li><li class="c9"><span class="c3">It is a warning if you have a</span><span class="c3">Â static getter </span><span class="c3 c2">v</span><span class="c3">Â and an instance setter </span><span class="c3 c2">v=</span><span class="c3">Â (7.2).</span></li><li class="c9"><span class="c3">If you define an instance member named </span><span class="c3 c2">m</span><span class="c3">, and your superclass has an instance member of the same name, they override each other. This may or may not be legal.</span></li><li class="c9"><span class="c3">If two members override each other, it is a static warning if their type signatures are not assignable to each other (7.1, 7.2, 7.3) (and since these are function types, this means the same as âsubtypes of each otherâ).</span></li><li class="c9"><span class="c3">If two members override each other, it is a compile time error if they have a different number of required parameters (7.1).</span></li><li class="c9"><span class="c3">If two members override each other, it is a compile time error if the overriding member has fewer optional positional parameters than the member being overridden (7.1).</span></li><li class="c9"><span class="c3">If two members override each other, it is a compile time error if the overriding member does not have all the named parameters that the member being overridden has (7.1).</span></li><li class="c9"><span class="c3">Setters, getters and operators never have optional parameters of any kind; itâs a compile-time error (7.1.1, 7.2, 7.3).</span></li><li class="c9"><span class="c3">It is a compile-time error if a member has the same name as its enclosing class (7).</span></li><li class="c9"><span class="c3">A class has an implicit interface (7).</span></li><li class="c9"><span class="c3">Interface members are not inherited by a class, but are inherited by its implicit interface. Interfaces have their own inheritance rules (8.1.1).</span></li><li class="c9"><span class="c3">A member is abstract if it has no body and is not labeled external (7.4, 6.4). </span></li><li class="c9"><span class="c3">A class is abstract iff it is explicitly labeled abstract.</span></li><li class="c9"><span class="c3">It is a static warning a concrete class has an abstract member (declare or inherited).</span></li><li class="c9"><span class="c3">It is a static warning and a dynamic error to call a non-factory constructor of an abstract class (11.10.1).</span></li><li class="c9"><span class="c3">If a class defines an instance member named m, and any of its superinterfaces have a member named m, the interface of the class overrides m.</span></li><li class="c9"><span class="c3">An interface inherits all members of its superinterfaces that are not overridden and not members of multiple superinterfaces.</span></li><li class="c9"><span class="c3">If multiple superinterfaces of an interface define a member with the same name m, then at most one member is inherited. That member (if it exists) is the one a type is a subtype of all the others. If there is no such member, then:</span></li></ol><ol class="c46" start="1"><li class="c11 c30"><span class="c3">A static warning is given.</span></li><li class="c11 c30"><span class="c3">If possible interface gets a member named m that has the same number of required parameters as all the members in the superinterfaces, the maximal number of optional positionals, and the superset of named parameters. The types of these are all </span><span class="c0 c3 c5">dynamic</span><span class="c3">. If this is impossible (because the superinterface members differ in their number of required parameters) then no member m appears in the interface.</span></li></ol><p class="c8 c23"><span class="c3"></span></p><ol class="c20" start="23"><li class="c9"><span class="c3">Rule 8 applies to interfaces as well as classes (8.1.1).</span></li><li class="c9"><span class="c3">It is a static warning if a concrete class does not have an implementation for a method in any of its superinterfaces (7.10).</span></li><li class="c9"><span class="c3">The identifier of a named constructor cannot be the same as the name of a member declared (as opposed to inherited) in the same class (7.6).</span></li></ol><p class="c8"><span class="c3"></span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c12 c2">It is nevertheless convenient to define the override relation between members in this way, so that we can concisely describe the illegal cases.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">Note that instance variables do not participate in the override relation, but the getters and setters they induce do. Also, getters donât override setters and vice versa. Â Finally, static members never override anything.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span>It is a static warning if a non-abstract class inherits an abstract method.</span></p><p class="c8"><span></span></p><a href="#" name="id.c8755sosjkuz"></a><h3 class="c13"><a name="h.pk4aq5ol5027"></a><span>Superinterfaces</span></h3><p class="c8"><span></span></p><p class="c13"><span>A class has a set of direct superinterfaces. This set includes the interface of its superclass and the interfaces specified in the the </span><span class="c0 c5">implements</span><span>Â clause of the class.</span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.5h6h28b15vp8"></a><p class="c13"><span class="c2 c5">interfaces:</span><span class="c2"><br> Â  Â  Â </span><span class="c0 c5">implements</span><span class="c2">Â </span><span class="c7 c2"><a class="c4" href="#id.adfwlw3tslsh">typeList</a></span><span class="c2"><br> Â  Â ;<br></span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error if</span><span>Â </span><span>the </span><span class="c0 c5">implements</span><span>Â clause of a class </span><span class="c2">C</span><span>Â includes a type expression that does not denote a </span><span>class </span><span>available in the lexical scope of </span><span class="c2">C. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">In particular, one cannot inherit from a type parameter. </span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error if the </span><span class="c0 c5">implements</span><span>Â clause of a class includes type </span><span class="c0 c5">dynamic</span><span>.</span></p><p class="c13"><span>It is a compile-time </span><span>error</span><span>Â if a </span><span>type </span><span class="c2">T</span><span class="c2">Â </span><span>appears more than once in the </span><span class="c0 c5">implements</span><span>Â clause of Â a class.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">One might argue that it is harmless to repeat a type in this way, so why make it an error? The issue is not so much that the situation described in program source is erroneous, but that it is pointless. As such, it is an indication that the programmer may very well have meant to say something else - and that is a mistake that should be called to her or his attention. Â Nevertheless, we could simply issue a warning; and perhaps we should and will. That said, problems like these are local and easily corrected on the spot, so we feel justified in taking a harder line. </span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error if the interface of a class </span><span class="c2">C</span><span>Â is a superinterface of itself.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a static warning if the implicit interface of a non-abstract class </span><span class="c2">C</span><span>Â includes an instance member </span><span class="c2">m</span><span>Â and </span><span class="c2">C </span><span>does not declare or inherit a corresponding instance member </span><span class="c2">m</span><span>. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">A class does not inherit members from its superinterfaces.</span><span>Â </span><span class="c3">However, its implicit interface does.</span></p><p class="c8"><span></span></p><a href="#" name="id.hfiy4m46snbm"></a><h2 class="c13"><span>Mixins</span></h2><p class="c8"><span class="c27 c5"></span></p><p class="c13"><span class="c12 c2">Caveat 1: Mixins are not implemented at this time.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">Caveat 2: This section of the spec is work in progress.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span>A mixin describes the difference between a class and its superclass. A mixin may be declared directly or derived from an existing class declaration.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error if a declared or derived mixin refers to </span><span class="c0 c5">super</span><span>. It is a compile-time error if a declared or derived mixin explicitly declares a constructor. It is a compile-time error if a mixin is derived from a class whose superclass is not </span><span class="c0">Object</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">These restrictions are temporary. Â We expect to remove them in later versions of Dart.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">The restriction on the use of </span><span class="c12 c0 c2 c5">super</span><span class="c12 c2">Â avoids the problem of rebinding </span><span class="c12 c0 c2 c5">super</span><span class="c12 c2">Â when the mixin is bound to difference superclasses.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">The restriction on constructors simplifies the construction of mixin applications because the process of creating instances is simpler.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">The restriction on the superclass means that the type of a class Â from which a mixing is derived is always implemented by any class that mixes it in. This allows us to defer the question of whether and how to express the type of the mixin independently of its superclass and super interface types.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">Reasonable answers exist for all these issues, but their implementation is non-trivial.</span></p><p class="c8"><span class="c12 c2"></span></p><a href="#" name="id.irdsyrsz71yz"></a><h3 class="c13"><a name="h.trk07h8vrppk"></a><span>Mixin Application</span></h3><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span>A mixin may be applied to a superclass, yielding a new class. Mixin application may occur Â when a mixin is mixed into a class declaration via its </span><span class="c6 c0 c5"><a class="c4" href="#id.g3i7hntbrzmw">with</a></span><span class="c6"><a class="c4" href="#id.g3i7hntbrzmw">Â clause</a></span><span>, or it may occur in the context of a </span><span class="c6"><a class="c4" href="#id.cogei5ciyfcy">type alias</a></span><span>.</span></p><p class="c8"><span></span></p><a href="#" name="id.kkw30c6ih30c"></a><p class="c13"><span class="c2 c5">mixinApplication:<br></span><span class="c2">Â  Â  Â  qualified</span><span class="c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.frtqvspfkgww">Â </a></span><span class="c6 c2"><a class="c4" href="#id.g3i7hntbrzmw">mixins</a></span><span class="c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.5h6h28b15vp8">Â </a></span><span class="c2 c29"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.5h6h28b15vp8">Â </a></span><span class="c6 c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.5h6h28b15vp8">interfaces</a></span><span class="c2">?â;â</span></p><p class="c13"><span class="c2">Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>A mixin application of the form </span><span class="c2">S </span><span class="c0 c2 c5">with</span><span class="c2">Â M </span><span class="c2">Â </span><span>defines a class </span><span class="c2">C</span><span>Â with superclass </span><span class="c2">S.</span><span>Â </span></p><p class="c8"><span></span></p><p class="c13"><span>A mixin application of the form </span><span class="c2">S </span><span class="c0 c2 c5">with</span><span class="c2">Â M</span><span class="c1">1</span><span class="c2">, â¦, M</span><span class="c1">k</span><span class="c2">Â  </span><span>defines a class </span><span class="c2">C</span><span>Â whose superclass is the application of the mixin composition </span><span class="c2">Â M</span><span class="c1">k</span><span class="c2">Â * â¦ * M</span><span class="c1">1</span><span>Â to </span><span class="c2">S.</span><span>Â </span></p><p class="c8"><span></span></p><p class="c13"><span>In both cases above, </span><span class="c2">C</span><span>Â declares the same instance members as </span><span class="c2">M</span><span>. If any of the instance fields of </span><span class="c2">M</span><span>Â have initializers, they are executed in the scope of </span><span class="c2">M</span><span>Â to initialize the corresponding fields of </span><span class="c2">C</span><span>. The class </span><span class="c2">C</span><span>Â has an implicitly declared nullary generative constructor with no initializer list and no body.</span></p><p class="c8"><span></span></p><p class="c13"><span>Let </span><span class="c2">K</span><span>Â be a class declaration Â with the same superclass and interfaces as </span><span class="c2">C</span><span>, Â and the instance members declared by </span><span class="c2">M</span><span>Â (respectively </span><span class="c2">M</span><span class="c10 c2">1</span><span class="c2">, ..., M</span><span class="c10 c2">k</span><span>). It is a static warning if the declaration of </span><span class="c2">K</span><span>Â would cause a static warning. Â It is a compile-time error if the declaration of </span><span class="c2">K</span><span>Â would cause a compile-time error.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">If, for example, </span><span class="c3 c2">M</span><span class="c3">Â declares an instance member </span><span class="c3 c2">im</span><span class="c3">Â whose type is at odds with the type of a member of the same name in </span><span class="c3 c2">S</span><span class="c3">, this will result in a static warning just as if we had defined </span><span class="c3 c2">K </span><span class="c3">by means of an ordinary class declaration extending </span><span class="c3 c2">S </span><span class="c3">with a body that included </span><span class="c3 c2">im</span><span class="c3">.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error if </span><span class="c2">S</span><span>Â does not denote a class available in the immediately enclosing scope. It is a compile-time error if </span><span class="c2">M</span><span>Â (respectively, any of </span><span class="c2">M</span><span class="c1">1</span><span class="c2">, ..., M</span><span class="c1">k</span><span>) does (respectively, do) not denote a class or mixin available in the immediately enclosing scope. It is a compile time error if a well formed mixin cannot be derived from </span><span class="c2">M</span><span>Â (respectively, from each of </span><span class="c2">M</span><span class="c1">1</span><span class="c2">, ..., M</span><span class="c1">k</span><span>).</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.11zuhsuql63s"></a><h3 class="c13"><a name="h.mhdp8ub62s7"></a><span>Mixin Composition</span></h3><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">Dart does not directly support mixin composition, but the concept is useful when defining how the superclass of a class with a mixin clause is created.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span>The</span><span>Â </span><span class="c2">composition of two mixins</span><span>, </span><span class="c2">M</span><span class="c10 c2">1</span><span class="c2">&lt;T</span><span class="c10 c2">1</span><span class="c2">Â â¦ T</span><span class="c10 c2">kM1</span><span class="c2">&gt;</span><span>Â and </span><span class="c2">M</span><span class="c10 c2">2</span><span class="c2">&lt;U</span><span class="c10 c2">1</span><span class="c2">Â â¦ U</span><span class="c10 c2">kM2</span><span class="c2">&gt;</span><span>, written </span><span class="c2">M</span><span class="c10 c2">1</span><span class="c2">&lt;T</span><span class="c10 c2">1</span><span class="c2">Â â¦ T</span><span class="c10 c2">kM1</span><span class="c2">&gt;</span><span>Â * </span><span class="c2">M</span><span class="c10 c2">2</span><span class="c2">&lt;U</span><span class="c10 c2">1</span><span class="c2">Â â¦ U</span><span class="c10 c2">kM2</span><span class="c2">&gt;</span><span class="c10 c2">Â </span><span>defines an anonymous mixin such that for any class </span><span class="c2">S&lt;V</span><span class="c10 c2">1</span><span class="c2">Â â¦ V</span><span class="c10 c2">kS</span><span class="c2">&gt;</span><span>, the application of </span><span class="c2">M</span><span class="c10 c2">1</span><span class="c2">&lt;T</span><span class="c10 c2">1</span><span class="c2">Â â¦ T</span><span class="c10 c2">kM1</span><span class="c2">&gt;</span><span>Â * </span><span class="c2">M</span><span class="c10 c2">2</span><span class="c2">&lt;U</span><span class="c10 c2">1</span><span class="c2">Â â¦ U</span><span class="c10 c2">kM2</span><span class="c2">&gt;</span><span class="c10 c2">Â </span><span>Â to </span><span class="c2">S&lt;V</span><span class="c10 c2">1</span><span class="c2">Â â¦ V</span><span class="c10 c2">kS</span><span class="c2">&gt;</span><span>Â is equivalent to</span></p><p class="c8"><span></span></p><p class="c13"><span class="c0 c2 c5">typedef</span><span class="c2">Â Id</span><span class="c10 c2">1</span><span class="c2">&lt;T</span><span class="c10 c2">1</span><span class="c2">Â â¦ T</span><span class="c10 c2">kM1</span><span class="c2">, U</span><span class="c10 c2">1</span><span class="c2">Â â¦ U</span><span class="c10 c2">kM2</span><span class="c2">, V</span><span class="c10 c2">1</span><span class="c2">Â â¦ V</span><span class="c10 c2">kS</span><span class="c2">&gt; = </span><span class="c0 c2 c5">abstract </span><span class="c2">Id</span><span class="c10 c2">2</span><span class="c2">&lt;U</span><span class="c10 c2">1</span><span class="c2">Â â¦ U</span><span class="c10 c2">kM2</span><span class="c2">, V</span><span class="c10 c2">1</span><span class="c2">Â â¦ V</span><span class="c10 c2">kS</span><span class="c2">&gt; </span><span class="c0 c2 c5">with </span><span class="c2">M</span><span class="c10 c2">1</span><span class="c2">Â &lt;T</span><span class="c10 c2">1</span><span class="c2">Â â¦ T</span><span class="c10 c2">kM1</span><span class="c2">&gt;</span><span class="c2">;</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>where </span><span class="c2">Id</span><span class="c10 c2">2</span><span class="c2">Â </span><span>denotes</span></p><p class="c8"><span></span></p><p class="c13"><span class="c0 c2 c5">typedef</span><span class="c2">Â Id</span><span class="c10 c2">2</span><span class="c2">&lt;U</span><span class="c10 c2">1</span><span class="c2">Â â¦ U</span><span class="c10 c2">kM2</span><span class="c2">, V</span><span class="c10 c2">1</span><span class="c2">Â â¦ V</span><span class="c10 c2">kS</span><span class="c2">&gt; = </span><span class="c0 c2 c5">abstract </span><span class="c2">S&lt;V</span><span class="c10 c2">1</span><span class="c2">Â â¦ V</span><span class="c10 c2">kS</span><span class="c2">&gt; </span><span class="c0 c2 c5">with</span><span class="c2">Â M</span><span class="c10 c2">2</span><span class="c2">&lt;U</span><span class="c10 c2">1</span><span class="c2">Â â¦ U</span><span class="c10 c2">kM2</span><span class="c2">&gt;;</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>and </span><span class="c2">Id</span><span class="c10 c2">1</span><span class="c2">Â </span><span>and</span><span class="c2">Â Id</span><span class="c10 c2">2</span><span class="c2">Â </span><span>are unique identifiers that do not exist anywhere in the program.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">The classes produced by mixin composition are regarded as abstract because they cannot be instantiated independently. They are only introduced as anonymous superclasses of ordinary class declarations and mixin applications. Consequently, no warning is given if a mixin composition includes abstract members, or incompletely implements an interface.</span></p><p class="c8"><span></span></p><p class="c13"><span>Mixin composition is associative.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">Note that any subset of </span><span class="c3 c2">M</span><span class="c10 c3 c2">1</span><span class="c3 c2">, M</span><span class="c10 c3 c2">2</span><span class="c3">Â and </span><span class="c3 c2">S</span><span class="c3">Â may or may not be generic. For any non-generic declaration, the corresponding type parameters may be elided, and if no type parameters remain in the derived declarations </span><span class="c3 c2">Id</span><span class="c10 c3 c2">1</span><span class="c3">Â and/or </span><span class="c3 c2">Id</span><span class="c10 c3 c2">2</span><span class="c3">Â then the those declarations need not be generic either.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.obndo59vaebw"></a><h2 class="c13"><a name="h.3g1mmsk0kbcr"></a><span>Interfaces</span></h2><p class="c8"><span></span></p><p class="c13"><span>An </span><span class="c2">interface</span><span>Â defines how one may interact with an object. An interface has methods, getters and setters and a set of superinterfaces.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error if an interface member </span><span class="c2">m</span><span class="c10 c2">1</span><span>Â overrides an interface member </span><span class="c2">m</span><span class="c10 c2">2</span><span>Â and Â </span><span class="c2">m</span><span class="c10 c2">1</span><span>Â has a different number of required parameters than </span><span class="c2">m</span><span class="c10 c2">2</span><span>. It is a compile-time error if an interface member </span><span class="c2">m</span><span class="c10 c2">1</span><span>Â overrides Â an interface member </span><span class="c2">m</span><span class="c10 c2">2</span><span>Â and Â </span><span class="c2">m</span><span class="c10 c2">1</span><span>Â does not declare all the named parameters declared by </span><span class="c2">m</span><span class="c10 c2">2</span><span>Â in the same order.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a static warning if an interface member</span><span class="c2">Â m</span><span class="c10 c2">1</span><span>Â overrides an interface member </span><span class="c2">m</span><span class="c10 c2">2</span><span>Â and the type of </span><span class="c2">m</span><span class="c10 c2">1</span><span>Â is not a subtype of the type of </span><span class="c2">m</span><span class="c10 c2">2</span><span>. Â It is a static warning if an interface method </span><span class="c2">m</span><span class="c10 c2">1</span><span>Â  overrides an interface method </span><span class="c2">m</span><span class="c10 c2">2</span><span>, Â the signature of </span><span class="c2">m</span><span class="c10 c2">2</span><span>Â explicitly specifies a default value for a formal parameter </span><span class="c2">p</span><span>Â and the signature of </span><span class="c2">m</span><span class="c10 c2">1</span><span>Â specifies a different default value for </span><span class="c2">p</span><span>.</span></p><h3 class="c13 c37"><a name="h.6rrdrau9dk6k"></a></h3><a href="#" name="id.1dtu82gkimcm"></a><h3 class="c13"><a name="h.6njjvzks70uf"></a><span>Superinterfaces</span></h3><p class="c8"><span></span></p><p class="c13"><span>An interface has a set of direct superinterfaces.</span></p><p class="c8"><span></span></p><p class="c13"><span>An interface </span><span class="c2">J</span><span>Â is a superinterface of an interface </span><span class="c2">I</span><span>Â iff either </span><span class="c2">J</span><span>Â is a direct superinterface of </span><span class="c2">I</span><span>Â or </span><span class="c2">J</span><span>Â is a superinterface of a direct superinterface of </span><span class="c2">I.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>It is a compile-time error if an interface is a superinterface of itself.</span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.dob88ttl6bd0"></a><h4 class="c13"><a name="h.n9p3c8rq84d5"></a><span>Inheritance and Overriding</span></h4><p class="c8"><span></span></p><p class="c13"><span>Let </span><span class="c2">I</span><span>Â be the implicit interface of a class </span><span class="c2">C</span><span>. Â </span><span class="c2">I</span><span>Â </span><span class="c2">inherits</span><span>Â any accessible instance members of its superinterfaces that are not overridden by members declared in </span><span class="c2">C.</span></p><p class="c8"><span></span></p><p class="c13"><span>However, if there </span><span>are multiple members </span><span class="c2">m</span><span class="c1">1</span><span class="c2">, â¦, Â m</span><span class="c1">k</span><span>Â with the same name </span><span class="c2">n</span><span>Â that would be inherited (because identically named members existed in several superinterfaces) then at most one member is inherited. If the static types </span><span class="c2">T</span><span class="c1">1</span><span class="c2">, â¦, Â T</span><span class="c1">k </span><span>of the members </span><span class="c2">m</span><span class="c1">1</span><span class="c2">, â¦, Â m</span><span class="c1">k </span><span>are not identical, then there must be a member </span><span class="c2">m</span><span class="c1">x</span><span>Â such that </span><span class="c2">T</span><span class="c1">x</span><span class="c2">Â &lt;: T</span><span class="c1">i</span><span class="c2">, 1 &lt;= x &lt;= k</span><span>Â for all Â </span><span class="c2">i, 1 &lt;= i &lt;= Â k, </span><span>or a static type warning occurs. The member that is inherited is </span><span class="c2">m</span><span class="c1">x</span><span class="c2">,</span><span>Â if it exists; otherwise:</span></p><ol class="c16" start="1"><li class="c9"><span>If all of </span><span class="c2">m</span><span class="c1">1</span><span class="c2">, â¦, Â m</span><span class="c1">k</span><span>Â have the same number </span><span class="c2">r</span><span>Â of required parameters and the same set of named parameters </span><span class="c2">s</span><span>, then let </span><span class="c2">h = max( numberOfOptionalPositionals( m</span><span class="c1">i </span><span class="c2">) ), 1 &lt;= i &lt;= k.</span><span>Â  </span><span class="c2">I </span><span>has a method named </span><span class="c2">n</span><span>, with </span><span class="c2">r</span><span>Â required parameters of type </span><span class="c0 c5">dynamic,</span><span>Â </span><span class="c2">h</span><span>Â optional positional parameters of type </span><span class="c0 c5">dynamic</span><span>, named parameters </span><span class="c2">s</span><span>Â of type </span><span class="c0 c5">dynamic</span><span>Â and Â return type </span><span class="c0 c5">dynamic.</span><span>Â  </span></li><li class="c9"><span>Otherwise none of the members Â </span><span class="c2">m</span><span class="c1">1</span><span class="c2">, â¦, Â m</span><span class="c1">k</span><span>Â is inherited</span><span class="c2">.</span></li></ol><p class="c8"><span class="c12 c2"></span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">The only situation where the runtime would be concerned with this would be during reflection if a mirror attempted to obtain the signature of an interface member. </span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c12 c2">The current solution is a tad complex, but is robust in the face of type annotation changes. Â Alternatives: (a) No member is inherited in case of conflict. (b) The first m is selected (based on order of superinterface list) (c) Inherited member chosen at random. Â </span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">(a) means that the presence of an inherited member of an interface varies depending on type signatures. Â (b) is sensitive to irrelevant details of the declaration and (c) is liable to give unpredictable results between implementations or even between different compilation sessions.</span></p><p class="c8"><span class="c3"></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.64iudgj9wjj1"></a><h2 class="c13"><a name="h.dkzw3xyky3rs"></a><span>Generics</span></h2><p class="c13"><span>A </span><span class="c7"><a class="c4" href="#id.o6h4ul6q3sru">class</a></span><span>Â declaration or type alias </span><span class="c2">G</span><span>Â may be </span><span class="c2">generic</span><span>, that is, </span><span class="c2">G </span><span>may have formal </span><span class="c2">type parameters</span><span>Â declared. A generic declaration induces a family of declarations, one for each set of actual type parameters provided in the program. </span></p><p class="c8"><span></span></p><a href="#" name="kix.bn2soknq8e18"></a><p class="c13"><span class="c2 c5">typeParameter</span><span class="c2 c5">:</span><span class="c2"><br> Â  metadata Â  </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2">Â (</span><span class="c0 c5">extends</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.qv2a3rupuer9">type</a></span><span class="c2">)?<br> Â  Â ;</span></p><p class="c8"><span></span></p><a href="#" name="id.p9q99pefxn6v"></a><p class="c13"><span class="c2 c5">typeParameters:</span><span class="c2"><br> Â  Â  &#39;&lt;&#39; </span><span class="c6 c2"><a class="c4" href="#kix.bn2soknq8e18">typeParameter</a></span><span class="c2">Â (&#39;,&#39; </span><span class="c6 c2"><a class="c4" href="#kix.bn2soknq8e18">typeParameter</a></span><span class="c2">)* &#39;&gt;&#39;<br> Â  Â ;<br></span></p><p class="c8"><span></span></p><p class="c13"><span>A type parameter </span><span class="c2">T</span><span>Â may be suffixed with an </span><span class="c0 c5">extends</span><span>Â clause that specifies the </span><span class="c2">upper bound</span><span>Â for </span><span class="c2">T.</span><span>Â If no extends clause is present, the upper bound is </span><span class="c0">Object</span><span class="c0">.</span><span>Â It is a static type warning if a type parameter is a supertype of its upper bound. The bounds of type variables are a form of type annotation and have no effect on execution in production mode.</span></p><p class="c8"><span class="c18"></span></p><p class="c13"><span>The type parameters of a generic declaration </span><span class="c2">G</span><span>Â are in </span><span>scope</span><span>Â in the bounds of all of the type parameters of </span><span class="c2">G. </span><span>The type parameters of a generic class declaration</span><span>Â </span><span class="c2">G</span><span>Â are also</span><span>Â </span><span>in scope in the </span><span class="c0 c5">extends</span><span>Â and </span><span class="c0 c5">implements</span><span>Â clauses of </span><span class="c2">G</span><span>Â (if these exist) and in the body of </span><span class="c2">G.</span><span>Â  However, a type parameter is considered to be a malformed type when referenced by a static member.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">The restriction is necessary since a type variable has no meaning in the context of a static member, because statics are shared among all instantiations of a generic. However, a type variable may be referenced from an instance initializer, even though </span><span class="c12 c0 c2 c5">this</span><span class="c12 c2">Â is not available.</span><span>Â </span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">Because type parameters are in scope in their bounds, we support F-bounded quantification (</span><span class="c3">if you don&#39;t know what that is, don&#39;t ask</span><span class="c3">). This enables typechecking code such as:</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c0 c3 c5">class</span><span class="c0 c3">Â Ordered&lt;T&gt; {</span></p><p class="c13"><span class="c0 c3">Â  </span><span class="c0 c3 c5">operator</span><span class="c0 c3">Â &gt; (T x);</span></p><p class="c13"><span class="c0 c3">}</span></p><p class="c8"><span class="c0 c3"></span></p><p class="c13"><span class="c0 c3 c5">class</span><span class="c0 c3">Â Sorter&lt;T </span><span class="c0 c3 c5">extends</span><span class="c0 c3">Â Ordered&lt;T&gt;&gt; {</span></p><p class="c13"><span class="c0 c3">Â  Â sort(List&lt;T&gt; l) { â¦ l[n] &lt; l[n+1] â¦}</span></p><p class="c13"><span class="c0 c3">}</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">Even where type parameters are in scope there are </span><span class="c3">numerous restrictions</span><span class="c3">Â at this time:</span></p><ol class="c16" start="1"><li class="c9"><span class="c3">A type parameter cannot be used to name a constructor in an </span><span class="c7"><a class="c4" href="#id.hvkbnlui8uvu">instance creation expression</a></span><span class="c3">.</span></li><li class="c9"><span class="c3">A type parameter cannot be used as a superclass or superinterface.</span></li></ol><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">The normative versions of these are given in the appropriate sections of this specification. Some of these restrictions may be lifted in the future.</span></p><p class="c8"><span class="c3"></span></p><p class="c8"><span></span></p><a href="#" name="id.iwjln3dq9jqj"></a><h2 class="c13"><a name="h.d0rowtffuudf"></a><span>Metadata</span></h2><p class="c8"><span class="c5 c36"></span></p><p class="c13"><span>Dart supports </span><span class="c2">metadata </span><span>which is used to attach user defined annotations to program structures. Â </span></p><p class="c8"><span></span></p><a href="#" name="id.gtr1evk47jqd"></a><p class="c13"><span class="c2 c5">metadata:<br></span><span class="c2">Â  Â  Â  (&#39;@&#39; qualified (â.â identifier)? (arguments)?)*<br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>Metadata consists of a series of annotations, each of which begin with the character </span><span class="c0">@</span><span>, followed by either a reference to a compile-time constant variable, or a call to a constant constructor.</span></p><p class="c8"><span></span></p><p class="c13"><span>Metadata is associated with the abstract syntax tree of the program construct </span><span class="c2">p</span><span>Â that immediately follows the metadata, assuming </span><span class="c2">p</span><span>Â is not itself metadata or a comment . Metadata can be retrieved at runtime via a reflective call, provided the annotated program construct </span><span class="c2">p</span><span>Â is accessible via reflection.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">Reflective access to metadata is not yet implemented as of the M2 release.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">Obviously, metadata can also be retrieved statically by parsing the program and evaluating the constants via a suitable interpreter. In fact many if not most uses of metadata are entirely static.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c12 c2">It is important that no runtime overhead be incurred by the introduction of metadata that is not actually used. Because metadata only involves constants, the time at which it is computed is irrelevant so that implementations may skip the metadata during ordinary parsing and execution and evaluate it lazily.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c3">It is possible to associate metadata with constructs that may not be accessible via reflection, such as local variables (though it is conceivable that in the future, richer reflective libraries might provide access to these as well).</span><span class="c12 c2">Â </span><span class="c3">Â This is not as useless as it might seem. As noted above, the data can be retrieved statically if source code is available.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span>Metadata can </span><span>appear before </span><span>a library, class, typedef, type parameter, constructor, factory, function, field, parameter, or variable declaration and before an import or export directive.</span></p><p class="c8"><span></span></p><a href="#" name="id.5cg9qz6trgbb"></a><h2 class="c13"><a name="h.dz8ekoegseec"></a><span>Expressions</span></h2><p class="c13"><span>An </span><span class="c2">expression</span><span>Â is a fragment of Dart code that can be evaluated at run time to yield a </span><span class="c2">value</span><span>,</span><span>Â which is always an object. Every expression has an associated </span><span class="c7"><a class="c4" href="#id.hiljskbmppmb">static type</a></span><span>. Every value has an associated </span><span class="c7"><a class="c4" href="#id.xmnezjjgjrld">dynamic type</a></span><span>.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.1u3vxuwrz6py"></a><p class="c13"><span class="c2 c5">expression</span><span class="c2 c5">:<br></span><span class="c2">Â  Â  Â  </span><span class="c6 c2"><a class="c4" href="#kix.3nqu822r00nf">assignableExpression</a></span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.gs625gfxuh9m">assignmentOperator</a></span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.1u3vxuwrz6py">expression</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.u42blbh7fdm7">conditionalExpression</a></span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.6dmpu4rs8im6">cascadeSection</a></span><span class="c2">*</span></p><p class="c13"><span class="c2">Â  Â  | </span><span class="c6 c2"><a class="c4" href="#kix.8xgyk1afd3ei">throwExpression</a></span><span class="c2"><br> Â  Â ;<br></span></p><p class="c13"><span class="c2"><br><br></span><a href="#" name="id.k68gukuq6cj9"></a><span class="c2 c5">expressionWithoutCascade:</span><span class="c2"><br> Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#kix.3nqu822r00nf">assignableExpression</a></span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.gs625gfxuh9m">assignmentOperator</a></span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.k68gukuq6cj9">expressionWithoutCascade</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.u42blbh7fdm7">conditionalExpression</a></span></p><p class="c13"><span class="c2">Â  Â  | </span><span class="c6 c2"><a class="c4" href="#id.ndl7z65wpgd0">throwExpressionWithoutCascade</a></span><span class="c2"><br> Â  Â ;<br></span></p><a href="#" name="id.8a2tqk43n0f2"></a><p class="c13"><span class="c2 c5">expressionList:</span><span class="c2"><br> Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#id.1u3vxuwrz6py">expression</a></span><span class="c2">Â (&#39;,&#39; </span><span class="c6 c2"><a class="c4" href="#id.1u3vxuwrz6py">expression</a></span><span class="c2">)*<br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span class="c2"><br></span><a href="#" name="kix.37v9da65ia6t"></a><span class="c2 c5">primary:</span><span class="c2"><br> Â  Â  Â </span><span class="c6"><a class="c4" href="#id.wwq4i2tyv7sn">thisExpression</a></span><span class="c2"><br> Â  Â | </span><span class="c0 c5">super</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#kix.sozsnkf6qfzk">assignableSelector</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.p3fm2ke402rw">functionExpression</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.88dsnjlmlm9c">literal</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.a0815nq10roy">newExpression</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.py555jou6no8">constObjectExpression</a></span><span class="c2"><br> Â  Â | &#39;(&#39; </span><span class="c6 c2"><a class="c4" href="#id.1u3vxuwrz6py">expression</a></span><span class="c2">Â &#39;)&#39;</span></p><p class="c13"><span class="c2">Â  Â  | </span><span class="c6 c2"><a class="c4" href="#id.e295wdblj6pq">argumentDefinitionTest</a></span><span class="c2"><br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>An expression </span><span class="c2">e </span><span>may always be enclosed in parentheses, but this never has any semantic effect on </span><span class="c2">e.</span></p><p class="c8"><span class="c2"><br></span></p><a href="#" name="id.hzs87hup8wb"></a><h3 class="c13"><a name="h.9asvt38phduq"></a><span>Constants</span></h3><p class="c13"><span>A constant expression is an expression whose value can never change, and that can be evaluated entirely at compile time. </span></p><p class="c8"><span></span></p><p class="c13"><span>A constant expression is one of the following:</span></p><ol class="c16" start="1"><li class="c9"><span>A literal </span><span class="c7"><a class="c4" href="#id.qjvme5fkz60x">number</a></span><span>.</span></li><li class="c9"><span>A literal </span><span class="c7"><a class="c4" href="#id.qyrl5513vmyg">boolean</a></span><span>.</span></li><li class="c9"><span>A literal </span><span class="c7"><a class="c4" href="#id.6fv1qfiad49o">string</a></span><span>Â  where any </span><span class="c6"><a class="c4" href="#id.4kp5eixbuz9v">interpolated expression</a></span><span>Â is a compile-time constant that evaluates to a </span><span>numeric, string or boolean</span><span>Â value or to </span><span class="c0 c5">null</span><span>. </span><span class="c12 c2">It would be tempting to allow string interpolation where the interpolated value is any compile-time constant. Â However, this would require running the </span><span class="c12 c0 c2">toString()</span><span class="c12 c2">Â method for constant objects, which could contain arbitrary code.</span></li><li class="c9"><span class="c7 c0"><a class="c4" href="#id.y33m1d6n2h6f">null</a></span><span class="c0">.</span></li><li class="c9"><span>A reference to a static </span><span class="c6"><a class="c4" href="#kix.6b1cgvgf1cyq">constant variable</a></span><span>.</span></li><li class="c9"><span>An identifier expression that denote</span><span>s a Â </span><span class="c6"><a class="c4" href="#kix.6b1cgvgf1cyq">constant variable</a></span><span>Â or </span><span>a class</span><span>.</span></li><li class="c9"><span>A </span><span class="c7"><a class="c4" href="#id.okcph2t66jnm">constant constructor</a></span><span>Â </span><span class="c7"><a class="c4" href="#id.bfpdh2tlvt0v">invocation</a></span><span>.</span></li><li class="c9"><span>A constant </span><span class="c7"><a class="c4" href="#id.tlcxi4pl8sj4">list literal</a></span><span>.</span></li><li class="c9"><span>A constant </span><span class="c7"><a class="c4" href="#id.riie55qjrb82">map literal</a></span><span>.</span></li><li class="c9"><span>A s</span><span>imple or </span><span>qualified</span><span>Â </span><span>identifier denoting a top-level </span><span class="c6"><a class="c4" href="#kix.v3h5pp33ioek">function</a></span><span>Â or a </span><span class="c6"><a class="c4" href="#id.y3ufp36d01bv">static method</a></span><span>. </span></li><li class="c9"><span>A parenthesized expression </span><span class="c2">(e)</span><span>Â where </span><span class="c2">e</span><span class="c2">Â </span><span>is a constant expression.</span></li><li class="c9"><span>An expression of the form </span><span class="c0">identical(</span><span class="c2">e</span><span class="c1">1</span><span class="c0">, </span><span class="c2">e</span><span class="c1">2</span><span class="c0">) </span><span>where </span><span class="c2">e</span><span class="c1">1</span><span>Â and </span><span class="c2">e</span><span class="c1">2</span><span>Â are constant expressions and </span><span class="c0">identical</span><span class="c0">()</span><span>Â is statically bound to</span><span>Â the predefined dart function</span><span>Â </span><span class="c0">identical</span><span class="c0">() </span><span>discussed below.</span></li><li class="c9"><span>An expression of one of the forms</span><span class="c0">Â </span><span class="c2">e</span><span class="c10 c2">1</span><span>Â == </span><span class="c2">e</span><span class="c1">2</span><span>Â or </span><span class="c2">e</span><span class="c10 c2">1</span><span>Â != </span><span class="c2">e</span><span class="c1">2</span><span class="c2">Â </span><span>where </span><span class="c2">e</span><span class="c1">1</span><span>Â and </span><span class="c2">e</span><span class="c1">2</span><span>Â are constant expressions that evaluate to a </span><span>numeric, string or boolean value</span><span>Â or to </span><span class="c0 c5">null</span><span>.</span></li><li class="c9"><span>An expression of one of the forms </span><span class="c2">!e</span><span class="c2">,</span><span>Â </span><span class="c1">Â </span><span class="c2">e</span><span class="c10 c2">1</span><span>Â &amp;&amp; </span><span class="c2">e</span><span class="c1">2</span><span class="c10 c2">Â </span><span>or</span><span class="c10">Â </span><span class="c2">e</span><span class="c10 c2">1</span><span>Â || </span><span class="c2">e</span><span class="c1">2</span><span class="c2">, </span><span>where </span><span class="c2">e, e</span><span class="c1">1</span><span>Â and </span><span class="c2">e</span><span class="c1">2</span><span>Â are constant expressions that evaluate to a boolean value or to </span><span class="c0 c5">null</span><span>.</span></li><li class="c9"><span>An expression of one of the forms</span><span class="c1">Â </span><span class="c2">~</span><span>Â </span><span class="c2">e</span><span>,</span><span class="c10">Â </span><span class="c2">e</span><span class="c10 c2">1</span><span>Â ^ </span><span class="c2">e</span><span class="c1">2</span><span>,</span><span class="c10">Â </span><span class="c2">e</span><span class="c10 c2">1</span><span>Â &amp; </span><span class="c2">e</span><span class="c1">2</span><span class="c2">, e</span><span class="c10 c2">1</span><span>Â | </span><span class="c2">e</span><span class="c1">2</span><span>, </span><span class="c2">e</span><span class="c10 c2">1</span><span>Â &gt;&gt; </span><span class="c2">e</span><span class="c1">2</span><span class="c10 c2">Â </span><span>or</span><span class="c10">Â </span><span class="c2">e</span><span class="c10 c2">1</span><span>Â &lt;&lt; </span><span class="c2">e</span><span class="c1">2</span><span class="c2">, </span><span>where </span><span class="c2">e, e</span><span class="c1">1</span><span>Â and </span><span class="c2">e</span><span class="c1">2</span><span>Â are constant expressions that evaluate to an integer value </span><span>or to </span><span class="c0 c5">null</span><span>.</span></li><li class="c9"><span>An expression of one of the forms</span><span class="c1">Â </span><span class="c2">-e</span><span>, </span><span class="c2">e</span><span class="c10 c2">1</span><span>Â + </span><span class="c2">e</span><span class="c1">2</span><span class="c2">, e</span><span class="c10 c2">1</span><span>Â - </span><span class="c2">e</span><span class="c1">2</span><span class="c2">, e</span><span class="c10 c2">1</span><span>Â * </span><span class="c2">e</span><span class="c1">2</span><span>,</span><span class="c10">Â </span><span class="c2">e</span><span class="c10 c2">1</span><span>Â / </span><span class="c2">e</span><span class="c1">2</span><span class="c2">, e</span><span class="c10 c2">1</span><span>Â ~/ </span><span class="c2">e</span><span class="c1">2</span><span class="c2">, </span><span class="c2">e</span><span class="c10 c2">1</span><span>Â &gt;</span><span class="c2">e</span><span class="c1">2</span><span>,</span><span class="c10">Â </span><span class="c2">e</span><span class="c10 c2">1</span><span>Â &lt; </span><span class="c2">e</span><span class="c1">2</span><span class="c2">, e</span><span class="c10 c2">1</span><span>Â &gt;= </span><span class="c2">e</span><span class="c1">2</span><span>,</span><span class="c10">Â </span><span class="c2">e</span><span class="c10 c2">1</span><span>Â &lt;= </span><span class="c2">e</span><span class="c1">2</span><span class="c2">Â </span><span>or </span><span class="c2">e</span><span class="c10 c2">1</span><span>Â % </span><span class="c2">e</span><span class="c1">2</span><span>,</span><span class="c10">Â </span><span class="c2">Â </span><span>where </span><span class="c2">e</span><span>, </span><span class="c2">e</span><span class="c1">1</span><span>Â and </span><span class="c2">e</span><span class="c1">2</span><span>Â are constant expressions that evaluate to a numeric value or to </span><span class="c0 c5">null</span><span>.</span></li></ol><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error if evaluation of a compile-time constant would raise an exception.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">The above is not dependent on program control-flow. The mere presence of a compile time constant whose evaluation would fail within a program is an error. Â This also holds recursively: since compound constants are composed out of constants, if any subpart of a constant is would raise an exception when evaluated, that is an error.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">On the other hand, since implementations are free to compile code late, some compile-time errors may manifest quite late.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c0 c3 c5">const</span><span class="c0 c3">Â x = 1/0;</span></p><p class="c13"><span class="c0 c3 c5">final</span><span class="c0 c3">Â y = 1/0;</span></p><p class="c8"><span class="c0 c3"></span></p><p class="c13"><span class="c0 c3 c5">class</span><span class="c0 c3">Â K {</span></p><p class="c13"><span class="c0 c3">Â  m1(){</span></p><p class="c13"><span class="c0 c3">Â  Â  </span><span class="c0 c3 c5">var</span><span class="c0 c3">Â z = </span><span class="c0 c3 c5">false</span><span class="c0 c3">;</span></p><p class="c13"><span class="c0 c3">Â  Â  </span><span class="c0 c3 c5">if</span><span class="c0 c3">Â (z) {</span><span class="c0 c3 c5">return</span><span class="c0 c3">Â x;}</span></p><p class="c13"><span class="c0 c3">Â  Â  </span><span class="c0 c3 c5">else</span><span class="c0 c3">Â {</span><span class="c0 c3 c5">return</span><span class="c0 c3">Â 2;}</span></p><p class="c13"><span class="c0 c3">Â  }</span></p><p class="c8"><span class="c0 c3"></span></p><p class="c13"><span class="c0 c3">Â m2() {</span></p><p class="c13"><span class="c0 c3">Â  Â </span><span class="c0 c3 c5">if</span><span class="c0 c3">Â (</span><span class="c0 c3 c5">true</span><span class="c0 c3">) {</span><span class="c0 c3 c5">return</span><span class="c0 c3">Â y;}</span></p><p class="c13"><span class="c0 c3">Â  Â </span><span class="c0 c3 c5">else</span><span class="c0 c3">Â {</span><span class="c0 c3 c5">return</span><span class="c0 c3">Â 3;}</span></p><p class="c13"><span class="c0 c3">Â }</span></p><p class="c13"><span class="c0 c3">}</span></p><p class="c8"><span class="c0 c3"></span></p><p class="c13"><span class="c3">An implementation is free to immediately issue a compilation error for </span><span class="c0 c3">x</span><span class="c3">Â but it is not required to do so. Â It could defer errors if it does not immediately compile the declarations that reference </span><span class="c0 c3">x</span><span class="c3">. For example, it could delay giving the compilation error for </span><span class="c0 c3">x</span><span class="c3">Â until the first invocation of </span><span class="c0 c3">m1.</span><span class="c3">Â However, it could not choose to execute </span><span class="c0 c3">m1</span><span class="c3">, Â see that the branch that refers to </span><span class="c0 c3">x</span><span class="c3">Â is not taken and return 2 successfully. </span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">The situation with respect to an invocation </span><span class="c0 c3">m2</span><span class="c3">Â is different. Because </span><span class="c0 c3">y</span><span class="c3">Â is not a compile-time constant (even though its value is), one need not give a compile-time error upon compiling </span><span class="c0 c3">m2</span><span class="c3">. An implementation may run the code, which will cause Â the getter for </span><span class="c0 c3">y</span><span class="c3">Â to be invoked. At that point, the initialization of </span><span class="c0 c3">y</span><span class="c3">Â must take place, which requires the initializer to be compiled, which will cause a compilation error.</span></p><p class="c8"><span class="c3"></span></p><p class="c8"><span class="c0 c3"></span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c12 c2">The treatment of </span><span class="c12 c0 c2 c5">null</span><span class="c12 c2">Â merits some discussion. Consider </span><span class="c12 c0 c2 c5">null</span><span class="c12 c0 c2">Â + 2</span><span class="c12 c2">. Â This expression always causes an error. We could have chosen not to treat it as a constant expression (and in general, not to allow </span><span class="c12 c0 c2 c5">null</span><span class="c12 c2">Â as a subexpression of numeric or boolean constant expressions). Â There are two arguments for including it:</span></p><ol class="c20" start="1"><li class="c9"><span class="c12 c2">It is constant. We can evaluate it at compile-time. </span></li><li class="c9"><span class="c12 c2">It seems more useful to give the error stemming from the evaluation explicitly.</span></li></ol><p class="c8"><span class="c3"></span></p><p class="c13"><span>It is a compile-time error if the value of a compile-time constant expression depends on itself.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">As an example, consider:</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c0 c3 c5">class</span><span class="c0 c3">Â CircularConsts{ // Illegal program - mutually recursive compile-time constants</span></p><p class="c13"><span class="c0 c3">Â  </span><span class="c0 c3 c5">static</span><span class="c0 c3">Â </span><span class="c0 c3 c5">const</span><span class="c0 c3">Â i = j; // a compile-time constant</span></p><p class="c13"><span class="c0 c3">Â  </span><span class="c0 c3 c5">static</span><span class="c0 c3">Â </span><span class="c0 c3 c5">const</span><span class="c0 c3">Â j = i; // a compile-time constant</span></p><p class="c13"><span class="c0 c3">}</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c8"><span class="c12 c2"></span></p><a href="#" name="id.88dsnjlmlm9c"></a><p class="c13"><span class="c2 c5">literal:</span><span class="c2"><br> Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#id.kerf68lc6rxd">nullLiteral</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.bhttjpn562o">booleanLiteral</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.57n5jyggoz16">numericLiteral</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.evk894mdov9u">stringLiteral</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.yqueh2ebzths">mapLiteral</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.8u5sm21y6987">listLiteral</a></span><span class="c2"><br> Â  Â ;<br></span></p><p class="c13"><span class="c2">Â </span><span>Let </span><span class="c2">c</span><span class="c1">1</span><span>Â and </span><span class="c2">c</span><span class="c1">2</span><span>Â be a pair of constants. Then </span><span class="c0">identical(</span><span class="c2">c</span><span class="c1">1</span><span class="c0">, </span><span class="c2">c</span><span class="c1">2</span><span class="c0">)</span><span>Â iff:</span></p><ol class="c16" start="1"><li class="c9"><span class="c2">c</span><span class="c1">1</span><span>Â evaluates to either </span><span class="c0 c5">null</span><span>, a constant map, a constant list, an instance of </span><span class="c0">bool</span><span>, </span><span class="c0">num</span><span>, </span><span class="c0">String</span><span>Â or </span><span class="c0">Type</span><span>Â and </span><span class="c2">c</span><span class="c1">1</span><span class="c0">Â == </span><span class="c2">c</span><span class="c1">2</span><span>, OR</span></li><li class="c9"><span class="c2">c</span><span class="c1">1</span><span>Â and </span><span class="c2">c</span><span class="c1">2</span><span>Â are constant objects of the same class C and for each member field of </span><span class="c2">c</span><span class="c1">1</span><span>Â is identical to the corresponding field of </span><span class="c2">c</span><span class="c1">2</span><span>.</span></li></ol><p class="c13"><span>where </span><span class="c0">identical</span><span class="c0">()</span><span>Â is the predefined dart function that returns true iff its two arguments are either:</span></p><ol class="c16" start="1"><li class="c9"><span>The same object. </span></li><li class="c9"><span>Of type </span><span class="c0">int</span><span>Â and have the same numeric value.</span></li><li class="c9"><span>Of type </span><span class="c0">double</span><span>, are not </span><span class="c0">NaN</span><span>s, and have the same numeric value.</span></li></ol><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.y33m1d6n2h6f"></a><h3 class="c13"><a name="h.gianetx6ltsy"></a><span>Null</span></h3><p class="c13"><span>The reserved word </span><span class="c0 c5">null</span><span>Â denotes the null object.</span></p><p class="c13"><span><br></span><a href="#" name="id.kerf68lc6rxd"></a><span class="c2">nullLiteral:</span><span class="c2"><br> Â  Â  Â </span><span class="c0 c5">null</span></p><p class="c13"><span>;</span></p><p class="c13"><span>The null object is the sole instance of the built-in class </span><span class="c0">Null. </span><span>Attempting to instantiate Null causes a runtime error. It is a compile-time error for a class to attempt to extend or implement </span><span class="c0">Null.</span><span>Â Invoking a method on </span><span class="c0 c5">null</span><span>Â yields a </span><span class="c0">NoSuchMethodError</span><span>Â </span><span>unless the method is explicitly implemented by class </span><span class="c0">Null</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>The static type of </span><span class="c0 c5">null</span><span>Â is bottom.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">The decision to use bottom instead of </span><span class="c12 c0 c2">Null</span><span class="c12 c2">Â allows </span><span class="c12 c0 c2 c5">null</span><span class="c12 c2">Â to be be assigned everywhere without complaint by the static checker. </span></p><p class="c8"><span></span></p><p class="c8"><span class="c3 c38"></span></p><p class="c8"><span></span></p><a href="#" name="id.qjvme5fkz60x"></a><h3 class="c13"><a name="h.ofa8cxlvo8lw"></a><span>Numbers</span></h3><p class="c8"><span></span></p><p class="c13"><span>A numeric literal is either a decimal or hexadecimal integer of arbitrary size, or a decimal double.</span></p><p class="c8"><span></span></p><a href="#" name="id.57n5jyggoz16"></a><p class="c13"><span class="c2 c5">numericLiteral:</span><span class="c2"><br> Â  Â  Â  NUMBER<br> Â  Â | HEX_NUMBER<br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.5qntm4tmtyju"></a><p class="c13"><span class="c2 c5">NUMBER:</span><span class="c2"><br> Â  Â  Â DIGIT+ (&#39;.&#39; DIGIT+)? EXPONENT?<br> Â  Â | Â &#39;.&#39; DIGIT+ EXPONENT?<br> Â  Â ;<br></span></p><a href="#" name="id.4mskjmm2cajg"></a><p class="c13"><span class="c2 c5">EXPONENT:</span><span class="c2"><br> Â  Â  Â (&#39;e&#39; | &#39;E&#39;) (&#39;+&#39; | &#39;-&#39;)? DIGIT+<br> Â  Â ;<br></span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.1fvefff2yfdv"></a><p class="c13"><span class="c2 c5">HEX_NUMBER:</span><span class="c2"><br> Â  Â  Â &#39;0x&#39; HEX_DIGIT+<br> Â  Â | &#39;0X&#39; HEX_DIGIT+<br> Â  Â ;<br><br> </span><a href="#" name="id.p2n864q7q3ax"></a><span class="c2 c5">HEX_DIGIT:</span><span class="c2"><br> Â  Â  Â &#39;a&#39;..&#39;f&#39;<br> Â  Â | &#39;A&#39;..&#39;F&#39;<br> Â  Â | DIGIT<br> Â  Â ;<br></span></p><p class="c13"><span>If a numeric literal begins with the prefix â0xâ, it is a</span><span class="c2">Â hexadecimal integer literal,</span><span>Â which denotes the hexadecimal integer represented by the part of the literal following â0xâ. </span><span>Otherwise, if the numeric literal does not include a decimal point </span><span>denotes an it is a </span><span class="c2">decimal integer literal,</span><span>Â which denotes a decimal integer. Â Otherwise, the numeric literal is a </span><span class="c2">literal double</span><span>Â which denotes a 64 bit double precision floating point number as specified by the IEEE 754 standard. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">Integers are not restricted to a fixed range. Dart integers are true integers, not 32 bit or 64 bit or any other fixed range representation. Their size is limited only by the memory available to the implementation.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span>It is a compile-time error for a class to attempt to extend or implement </span><span class="c0">int. </span><span>It is a compile-time error for a class to attempt to extend or implement </span><span class="c0">double.</span><span>Â It is a compile-time error for any type other than the types </span><span class="c0">int</span><span>Â and </span><span class="c0">double</span><span>Â to attempt to extend or implement </span><span class="c0">num.</span><span class="c2"><br> </span></p><p class="c13"><span>An </span><span class="c2">integer literal</span><span>Â is either a hexadecimal integer literal or a Â decimal integer literal.</span></p><p class="c13"><span>The static type of an integer literal is </span><span class="c0">int.</span><span>Â A </span><span class="c2">literal double</span><span>Â is a numeric literal that is not an integer literal. The static type of a literal double is </span><span class="c0">double.</span><span><br></span></p><a href="#" name="id.qyrl5513vmyg"></a><h3 class="c13"><a name="h.jitw991wrmh5"></a><span>Booleans</span></h3><p class="c13"><span>The reserved words </span><span class="c0 c5">true</span><span>Â and </span><span class="c0 c5">false</span><span>Â denote objects that represent the boolean values true and false respectively. They are the </span><span class="c2">boolean literals.</span></p><p class="c8"><span></span></p><a href="#" name="id.bhttjpn562o"></a><p class="c13"><span class="c2 c5">booleanLiteral:</span><span class="c2"><br> Â  Â  Â </span><span class="c0 c5">true</span><span class="c2"><br> Â  Â | </span><span class="c0 c5">false</span></p><p class="c13"><span class="c2">Â  Â  ;</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>Both Â </span><span class="c0 c5">true</span><span>Â and </span><span class="c0 c5">false</span><span>Â are implement the built-in class </span><span class="c0">bool.</span><span>Â They are the only two instances of </span><span class="c0">bool.</span><span>Â It is a compile-time error for a class to attempt to extend or implement </span><span class="c0">bool.</span><span>Â </span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">It follows that the two boolean literals are the only two instances of </span><span class="c0 c3">bool.</span><span>Â </span></p><p class="c8"><span></span></p><p class="c13"><span>The static type of a boolean literal is </span><span class="c0">bool.</span></p><p class="c8"><span class="c18"></span></p><a href="#" name="id.luoug0f1vx2f"></a><h4 class="c13"><a name="h.qoglfpvek4rj"></a><span>Boolean Conversion</span></h4><p class="c8"><span></span></p><p class="c13"><span class="c2">Boolean conversion</span><span>Â maps any object </span><span class="c2">o</span><span>Â into a boolean. Boolean conversion is defined Â by the function</span></p><p class="c8"><span></span></p><p class="c13"><span class="c0">(bool v){</span></p><p class="c13"><span class="c0">Â  Â  Â  Â  Â  </span><span class="c0 c5">assert</span><span class="c0">(v != </span><span class="c0 c5">null</span><span class="c0">);</span></p><p class="c13"><span class="c0">Â Â Â Â Â Â Â Â </span><span class="c0 c5">return</span><span class="c0">Â identical(</span><span>v</span><span class="c0 c5">,</span><span class="c0">Â </span><span class="c0 c5">true)</span><span class="c0">;</span></p><p class="c13"><span class="c0">}(o)</span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">Boolean conversion is used as part of control-flow constructs and boolean expressions. Â Ideally, one would simply insist that control-flow decisions be based exclusively on booleans. Â This is straightforward in a statically typed setting. In a dynamically typed language, it requires a dynamic check. Sophisticated virtual machines can minimize the penalty involved. </span><span class="c12 c2">Alas</span><span class="c12 c2">, Dart must be compiled into Javascript. Boolean conversion allows this to be done efficiently. </span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">At the same time, this formulation differs radically from Javascript, where most numbers and objects are interpreted as </span><span class="c12 c0 c2 c5">true.</span><span class="c12 c2">Â  Dartâs approach prevents usages such Â </span><span class="c12 c0 c2 c5">if</span><span class="c12 c0 c2">Â (a-b) â¦ ;</span><span class="c12 c2">Â because it does not agree with the low level conventions whereby non-null objects or non-zero numbers are treated as </span><span class="c12 c0 c2 c5">true.</span><span class="c12 c2">Â Indeed, there is no way to derive </span><span class="c12 c0 c2 c5">true</span><span class="c12 c2">Â from a non-boolean object via boolean conversion, so this kind of low level hackery is nipped in the bud.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">Dart also avoids the strange behaviors that can arise due to the interaction of boolean conversion with autoboxing in Javascript. A notorious example is the situation where </span><span class="c12 c0 c2 c5">false</span><span class="c12 c2">Â can be interpreted as </span><span class="c12 c0 c2 c5">true.</span><span class="c12 c2">Â In Javascript, booleans are not objects, and instead are autoboxed into objects where âneededâ. Â If </span><span class="c12 c0 c2 c5">false</span><span class="c12 c2">Â gets autoboxed into an object, that object can be coerced into </span><span class="c12 c0 c2 c5">true</span><span class="c12 c2">Â (as it is a non-null object). </span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.6fv1qfiad49o"></a><h3 class="c13"><a name="h.fp52o176rzde"></a><span>Strings</span></h3><p class="c8"><span></span></p><p class="c13"><span>A </span><span class="c2">string</span><span>Â is a sequence of valid UTF-16 code units. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">This decision was made for compatibility with web browsers and Javascript. Earlier versions of the specification required a string to be a sequence of valid Unicode code points. Â Programmers should not depend on this distinction.</span></p><p class="c8"><span></span></p><a href="#" name="id.evk894mdov9u"></a><p class="c13"><span class="c2 c5">stringLiteral:</span><span class="c2"><br> Â  Â  Â multilineString+<br> Â  Â | singleLineString</span><span class="c2">+</span><span class="c2"><br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>A string can be either a single line string or a multiline string. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c2 c5">singleLineString:</span><span class="c2"><br> Â  Â  Â &#39; Â &#39;&#39; &#39; stringContentDQ* &#39; &quot; &#39;<br> Â  Â | &#39; </span><span class="c2">&#39; &#39; </span><span class="c2">StringContentSQ* &#39; &#39; &#39;<br> Â  Â | &#39;r&#39; &#39;</span><span class="c2">Â &#39;</span><span class="c2">Â &#39; (~( &#39; &#39; &#39; | NEWLINE ))* &#39; &#39; &#39;<br> Â  Â | &#39;r&#39; &#39; &quot; &#39; (~( &#39; &quot; &#39; | NEWLINE ))* &#39; &quot; &#39;<br> Â  Â ;<br></span></p><p class="c13"><span>A single line string is delimited by either matching single quotes or matching double quotes. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">Hence, âabcâ and âabcâ are both legal strings, as are âHe said âTo be or not to beâ did he not?â Â and âHe said âTo be or not to beâ didnât he?â. However âThis â is not a valid string, nor is âthisâ.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">The grammar ensures that a single line string cannot span more than one line of source code, unless it includes an interpolated expression that spans multiple lines.</span><span>Â </span></p><p class="c8"><span></span></p><p class="c13"><span>Adjacent single line strings are implicitly concatenated to form a single string literal, and so are adjacent multiline strings, but the two forms may not be mixed.</span></p><p class="c13"><span class="c3">Here is an example</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">print(&quot;A string&quot; &quot;and then another&quot;); // prints: A stringand then another</span></p><p class="c8"><span class="c3"></span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">Early versions of Dart used the operator + for string concatenation. However, this was Â dropped, as it leads to puzzlers such as</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c0 c2">print(&quot;A simple sum: 2 + 2 = &quot; +</span></p><p class="c13"><span class="c12 c0 c2">Â  Â  Â  Â  Â  Â  2 + 2);</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">which this prints Â &#39;A simple sum: 2 + 2 = 22&#39; rather than &#39;A simple sum: 2 + 2 = 4&#39;.</span></p><p class="c13"><span class="c12 c2">Instead, the recommended Dart idiom is to use string interpolation.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c0 c2">print(&quot;A simple sum: 2 + 2 = Â ${2+2}&quot;);</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">String interpolation work well for most cases. The main situation where it is not fully satisfactory is for string literals that are too large to fit on a line. Multiline strings can be useful, but in some cases, we want to visually align the code. This can be expressed by writing smaller strings separated by whitespace, as shown here:</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">&#39;</span><span class="c12 c0 c2">Imagine this is a very long string that does not fit on a line. What shall we do? &#39;</span></p><p class="c13"><span class="c12 c0 c2">&#39;Oh what shall we do? &#39;</span></p><p class="c13"><span class="c12 c0 c2">&#39;We shall split it into pieces &#39;</span></p><p class="c13"><span class="c12 c0 c2">&#39;like so&#39;</span></p><p class="c8"><span class="c3"></span></p><p class="c8"><span></span></p><p class="c13"><span class="c2 c5">multilineString</span><span class="c2 c5">:</span><span class="c2"><br> Â  Â  &#39;</span><span class="c2 c5">&quot;&quot;&quot;</span><span class="c2">&#39; Â s</span><span class="c2">tringContent</span><span class="c2">TDQ* &#39;</span><span class="c2 c5">&quot;&quot;&quot;</span><span class="c2">&#39;<br> Â  Â | &#39;</span><span class="c2 c5">&#39;&#39;&#39;</span><span class="c2">&#39; stringContentTSQ* &#39;</span><span class="c2 c5">&#39;&#39;&#39;</span><span class="c2">&#39;</span></p><p class="c13"><span class="c2">Â  Â  | ârâ &#39;</span><span class="c2 c5">&quot;&quot;&quot;</span><span class="c2">&#39; Â (~(</span><span class="c2 c5">&quot;&quot;&quot;</span><span class="c2">))* &#39;</span><span class="c2 c5">&quot;&quot;&quot;</span><span class="c2">&#39;</span></p><p class="c13"><span class="c2">Â  Â  | ârâ &#39;</span><span class="c2 c5">&#39;&#39;&#39;</span><span class="c2">&#39; (~(</span><span class="c2 c5">&#39;&#39;&#39;</span><span class="c2">))* &#39;</span><span class="c2 c5">&#39;&#39;&#39;</span><span class="c2">&#39;<br> Â  Â ;<br></span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.3nq8vkqtjqvz"></a><p class="c13"><span class="c2 c5">ESCAPE_SEQUENCE:</span></p><p class="c13"><span class="c2">Â  Â  Â â\nâ</span></p><p class="c13"><span class="c2">Â  Â | â\râ</span></p><p class="c13"><span class="c2">Â  Â | â\fâ</span></p><p class="c13"><span class="c2">Â  Â | â\bâ</span></p><p class="c13"><span class="c2">Â  | â\tâ</span></p><p class="c13"><span class="c2">Â  | â\vâ</span></p><p class="c13"><span class="c2">Â  | â\xâ HEX_DIGIT HEX_DIGIT</span></p><p class="c13"><span class="c2">Â  | â\uâ HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT</span></p><p class="c13"><span class="c2">Â  | â\u{â </span><span class="c2">HEX_DIGIT_SEQUENCE</span><span class="c2">Â â}â</span></p><p class="c13"><span class="c2">Â  :</span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.5gaf5oqxyhna"></a><p class="c13"><span class="c2 c5">HEX_DIGIT_SEQUENCE:</span></p><p class="c13"><span class="c2">Â  Â  Â HEX_DIGIT HEX_DIGIT? HEX_DIGIT? HEX_DIGIT? HEX_DIGIT? HEX_DIGIT? </span></p><p class="c13"><span class="c2">Â  Â  ;</span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span></span></p><p class="c13"><span>Multiline strings are delimited by either matching triples of single quotes or matching triples of double quotes. If the first line of a multiline string consists solely of whitespace characters then that line is ignored, including the new line at its end.</span></p><p class="c8"><span></span></p><p class="c13"><span>Strings support escape sequences for special characters. The escapes are:</span></p><ol class="c16" start="1"><li class="c9"><span>Â \n for newline, equivalent to \x0A.</span></li><li class="c9"><span>\r for carriage return, equivalent to \x0D.</span></li><li class="c9"><span>\f for form feed, equivalent to \x0C.</span></li><li class="c9"><span>\b for backspace, equivalent to \x08.</span></li><li class="c9"><span>\t for tab, equivalent to \x09.</span></li><li class="c9"><span>\v for vertical tab, equivalent to \x0B.</span></li><li class="c9"><span>\x</span><span class="c24 c2">HEX_DIGIT</span><span class="c1 c24">1</span><span class="c24">Â </span><span class="c24 c2">HEX_DIGIT</span><span class="c1 c24">2</span><span>, equivalent to </span><span class="c24">\u{</span><span class="c24">Â </span><span class="c24 c2">HEX_DIGIT</span><span class="c1 c24">1</span><span class="c24">Â </span><span class="c24 c2">HEX_DIGIT</span><span class="c1 c24">2</span><span class="c24">}.</span></li><li class="c9"><span>\u</span><span class="c24 c2">HEX_DIGIT</span><span class="c1 c24">1</span><span class="c24">Â </span><span class="c24 c2">HEX_DIGIT</span><span class="c1 c24">2</span><span class="c24 c2">Â HEX_DIGIT</span><span class="c1 c24">3</span><span class="c24 c2">Â HEX_DIGIT</span><span class="c1 c24">4</span><span>, equivalent to </span><span class="c24">\u{ </span><span class="c24 c2">HEX_DIGIT</span><span class="c1 c24">1</span><span class="c24">Â </span><span class="c24 c2">HEX_DIGIT</span><span class="c1 c24">2</span><span class="c24 c2">Â HEX_DIGIT</span><span class="c1 c24">3</span><span class="c24 c2">Â HEX_DIGIT</span><span class="c1 c24">4</span><span class="c24">}.</span></li><li class="c9"><span>\u{</span><span class="c2">HEX_DIGIT_SEQUENCE</span><span>} </span><span class="c24">is the unicode scalar value represented by the </span><span class="c2">HEX_DIGIT_SEQUENCE</span><span class="c24">. It is a compile-time error if the value of the </span><span class="c2">HEX_DIGIT_SEQUENCE</span><span class="c24">Â is not a valid unicode scalar value.</span></li><li class="c9"><span>$ indicating the beginning of an interpolated expression.</span></li><li class="c9"><span>Otherwise, \</span><span class="c2">k</span><span>Â indicates the character </span><span class="c2">k</span><span>Â for any </span><span class="c2">k</span><span>Â not in </span><span class="c2">{n, r, f, b, t, v, x, u}</span><span>.</span></li></ol><p class="c13"><span>It is a compile-time error if a non-raw string literal contains a character sequence of the form</span><span>Â \x </span><span>that is not followed by a sequence of two hexadecimal digits. It is a compile-time error if a non-raw string literal Â contains a character sequence of the form \u that is not followed by either a sequence of four hexadecimal digits, or by curly brace delimited sequence of hexadecimal digits.</span></p><p class="c8"><span></span></p><p class="c13"><span>Any string may be prefixed with the character ârâ, indicating that it is a </span><span class="c2">raw string,</span><span>Â in which case </span><span>no escapes</span><span>Â or interpolations are recognized.</span><span class="c2"><br><br><br> </span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span class="c2 c5">stringContentDQ:</span><span class="c2"><br> Â  Â  Â ~( &#39;</span><span class="c2 c5">\</span><span class="c2">&#39; | &#39; Â </span><span class="c2 c5">&quot; </span><span class="c2">Â &#39; | &#39;</span><span class="c2 c5">$</span><span class="c2">&#39; | NEWLINE )<br> Â </span><span class="c2">Â  | &#39;</span><span class="c2 c5">\</span><span class="c2">&#39; ~( NEWLINE )<br></span><a href="#" name="id.kq4y2jlvvfaa"></a><span class="c2">Â  Â  | stringInterpolation<br> Â  Â ;<br><br> </span><span class="c2 c5">stringContentSQ:</span><a href="#" name="kix.uc5qdyxt69ds"></a><span class="c2"><br> Â  Â  Â ~( &#39;\&#39; | &#39;\&#39;&#39; | &#39;$&#39; | NEWLINE )<br> Â  Â | &#39;\&#39; ~( NEWLINE )<br> Â  Â | stringInterpolation<br> Â  Â ;<br></span></p><p class="c13"><span class="c2 c5">stringContentTDQ:</span><span class="c2"><br> Â  Â  Â ~( &#39;</span><span class="c2 c5">\</span><span class="c2">&#39; | &#39; Â </span><span class="c2 c5">&quot; </span><span class="c2">Â &#39; | &#39;</span><span class="c2 c5">$</span><span class="c2">&#39; )<br> Â  Â | </span><span class="c2">&#39;</span><span class="c2 c5">\</span><span class="c2">&#39; ~( NEWLINE )<br></span><a href="#" name="kix.iyhioapxm8q2"></a><span class="c2">Â  Â  | stringInterpolation<br> Â  Â ;<br><br> </span><span class="c2 c5">stringContentTSQ:</span><span class="c2"><br> Â  Â  Â ~( &#39;\&#39; | &#39;\&#39;&#39; | &#39;$&#39; )<br> Â  Â | &#39;\&#39; ~( NEWLINE )<br> Â  Â | </span><span class="c2">stringInterpolation</span><span class="c2"><br> Â  Â ;<br><br></span><a href="#" name="id.au65szsm2thq"></a><span class="c2 c5">NEWLINE:</span><span class="c2"><br> Â  Â  Â \n<br> Â  Â | \r<br> Â  Â ;<br><br></span></p><p class="c13"><span>All string literals implement the built-in class </span><span class="c0">String.</span><span>Â It is a compile-time error for a class to attempt to extend or implement </span><span class="c0">String.</span><span>Â The static type of a string literal is </span><span class="c0">String.</span></p><p class="c13"><span class="c2"><br> Â  Â </span></p><a href="#" name="id.4kp5eixbuz9v"></a><h4 class="c13"><a name="h.us5hu2wpthk4"></a><span>String Interpolation</span></h4><p class="c8"><span></span></p><p class="c13"><span>It is possible to embed expressions within non-raw string literals, such that the these expressions are evaluated, and the resulting values are converted into strings and concatenated with the enclosing string. This process is known as </span><span class="c2">string interpolation.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span class="c2 c5">stringInterpolation:</span><span class="c2"><br> Â  Â  Â &#39;$&#39; IDENTIFIER_NO_DOLLAR<br> Â  Â | &#39;$&#39; &#39;{&#39;</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.k68gukuq6cj9">expression </a></span><span class="c2">&#39;}&#39;<br> Â  Â ;<br></span></p><p class="c13"><span class="c3">The reader will note that the expression inside the interpolation could itself include strings, which could again be interpolated recursively. </span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span></span></p><p class="c13"><span>An unescaped $ character in a string signifies the beginning of an interpolated expression. Â The $ sign may be followed by either:</span></p><ol class="c16" start="1"><li class="c9"><span>A </span><span>single identifier </span><span class="c2">id</span><span>Â that must not contain the $ character. </span></li><li class="c9"><span>An expression </span><span class="c2">e</span><span>Â delimited by curly braces.</span></li></ol><p class="c8"><span></span></p><p class="c13"><span>The form </span><span class="c0">$id</span><span>Â is equivalent to the form </span><span class="c0">${id}</span><span>. Â An interpolated string </span><span class="c0 c2">âs</span><span class="c1 c0">1</span><span class="c0">${</span><span class="c0 c2">e</span><span class="c0">}</span><span class="c0 c2">s</span><span class="c1 c0">2</span><span class="c0 c2">â</span><span>Â  is equivalent to the concatenation of the strings </span><span>â</span><span class="c0 c2">s</span><span class="c1 c0">1</span><span class="c0">â</span><span>,</span><span class="c0">Â </span><span class="c0 c2">e</span><span class="c0">.</span><span class="c0">toString</span><span class="c0">()</span><span>Â and </span><span class="c0">â</span><span class="c0 c2">s</span><span class="c1 c0">2</span><span class="c0">â.</span><span>Â </span><span>Likewise</span><span>Â an interpolated string </span><span class="c0 c2">âs</span><span class="c1 c0">1</span><span class="c0">${</span><span class="c0 c2">e</span><span class="c0">}</span><span class="c0 c2">s</span><span class="c1 c0">2</span><span class="c0 c2">â</span><span>â </span><span>is equivalent to the concatenation of Â the strings â</span><span class="c0 c2">s</span><span class="c1 c0">1</span><span class="c0">â</span><span>,</span><span class="c0">Â </span><span class="c0 c2">e</span><span class="c0">.toString</span><span class="c0">()</span><span class="c0">Â </span><span>and</span><span class="c0">Â â</span><span class="c0 c2">s</span><span class="c1 c0">2</span><span class="c0">â</span><span>. In both cases, it is a runtime error if </span><span class="c0 c2">e</span><span class="c0">.toString</span><span class="c0">()</span><span class="c0">Â </span><span>does not return an object of type </span><span class="c0">String</span><span>.</span></p><p class="c8"><span class="c0"></span></p><p class="c8"><span class="c12 c2"></span></p><p class="c8"><span></span></p><h3 class="c13"><a name="h.aj7d3xqsd3m5"></a><span>Lists</span></h3><p class="c8"><span></span></p><p class="c13"><span>A</span><span class="c2">Â list literal </span><span>denotes a list, which is an integer indexed collection of objects. </span></p><p class="c8"><span></span></p><a href="#" name="id.8u5sm21y6987"></a><p class="c13"><span class="c2 c5">listLiteral:</span><span class="c2"><br> Â  Â  Â </span><span class="c0 c5">const</span><span class="c0">?</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.okv2bn8j19mq">typeArguments</a></span><span class="c2">? &#39;[&#39; (</span><span class="c6 c2"><a class="c4" href="#id.8a2tqk43n0f2">expressionList</a></span><span class="c2">Â &#39;,&#39;?)? &#39;]&#39;<br> Â  Â ;<br></span></p><p class="c13"><span>A list may contain zero or more objects. The number of elements in a list is its </span><span class="c2">size.</span><span>Â A list has an associated set of indices. Â An empty list has an empty set of indices. A non-empty list has the index set </span><span class="c2">{0 â¦ n -1}</span><span>Â where </span><span class="c2">n</span><span>Â is the size of the list</span><span class="c2">.</span><span>Â It is a runtime error to attempt to access a list using an index that is not a member of its set of indices.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>If a list literal begins with the reserved word </span><span class="c0 c5">const</span><span>, it is a </span><span class="c2">constant list literal</span><span>Â which is a </span><span class="c6"><a class="c4" href="#id.hzs87hup8wb">compile-time constant</a></span><span>Â and therefore evaluated at compile-time. Otherwise, it is a </span><span class="c2">runtime list literal</span><span>Â and it is evaluated at runtime.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile time error if an element of a constant list literal is not a compile-time constant. It is a compile time error if the type argument of a constant list literal </span><span>includes a type parameter.</span></p><p class="c13"><span class="c12 c2">The binding of a type parameter is not known at compile-time, so we cannot use type parameters inside compile-time constants.</span></p><p class="c8"><span></span></p><p class="c13"><span>The value of a constant list literal Â </span><span class="c0 c5">const</span><span class="c2">Â &lt;E&gt;[e</span><span class="c1">1</span><span class="c2">... e</span><span class="c1">n</span><span class="c2">]</span><span>Â is an object </span><span class="c2">a</span><span>Â that implements the built-in class </span><span class="c2">List&lt;E&gt;</span><span class="c2">. </span><span>The </span><span class="c2">i</span><span>th element of </span><span class="c2">a</span><span>Â is </span><span class="c2">v</span><span class="c1">i+1</span><span>, where </span><span class="c2">v</span><span class="c1">i</span><span>Â is the value of the compile time expression </span><span class="c2">e</span><span class="c1">i</span><span class="c2">. Â </span><span>The value of a constant list literal Â </span><span class="c0 c5">const</span><span class="c2">Â [e</span><span class="c1">1</span><span class="c2">... e</span><span class="c1">n</span><span class="c2">]</span><span>Â is defined as the value of a constant list literal </span><span class="c0 c5">const</span><span class="c2">Â &lt;</span><span class="c0 c2 c5">dynamic</span><span class="c2">&gt;[e</span><span class="c1">1</span><span class="c2">... e</span><span class="c1">n</span><span class="c2">]</span><span>. It is a run-time error to attempt to modify a constant list literal.</span><span class="c3">Â </span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span>Let </span><span class="c2">list</span><span class="c1">1</span><span>Â = </span><span class="c0 c5">const</span><span class="c2">Â &lt;V&gt;[e</span><span class="c1">11</span><span class="c2">... e</span><span class="c1">1n</span><span class="c2">] </span><span>and </span><span class="c2">list</span><span class="c1">2</span><span>Â = </span><span class="c0 c5">const</span><span class="c2">Â &lt;U&gt;[e</span><span class="c1">21</span><span class="c2">... e</span><span class="c1">2n</span><span class="c2">] </span><span>be two constant list literals and let the Â elements of </span><span class="c2">list</span><span class="c1">1</span><span>Â and </span><span class="c2">list</span><span class="c1">2</span><span>Â  evaluate to Â </span><span class="c2">o</span><span class="c1">11</span><span class="c2">... o</span><span class="c1">1n</span><span>Â and </span><span class="c2">o</span><span class="c1">21</span><span class="c2">... o</span><span class="c1">2n</span><span>Â respectively. Iff </span><span class="c0">identical(</span><span class="c2">o</span><span class="c1">1i</span><span class="c0">, </span><span class="c2">o</span><span class="c1">2i</span><span class="c0">)</span><span>Â for </span><span class="c2">1 &lt;= i &lt;= n</span><span>Â and </span><span class="c2">V = U</span><span>Â then </span><span class="c0">identical(</span><span class="c2">list</span><span class="c1">1</span><span class="c0">,</span><span>Â </span><span class="c2">list</span><span class="c1">2</span><span class="c0">)</span><span>. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">In other words, constant list literals are canonicalized.</span></p><p class="c8"><span></span></p><p class="c13"><span>A runtime list literal </span><span class="c2">&lt;E&gt;[e</span><span class="c1">1</span><span class="c2">... e</span><span class="c1">n</span><span class="c2">]</span><span>Â  is evaluated as follows:</span></p><ol class="c16" start="1"><li class="c9"><span>First, the expressions </span><span class="c2">e</span><span class="c1">1</span><span class="c2">... e</span><span class="c1">n</span><span>Â are evaluated in left to right order, yielding objects </span><span class="c2">o</span><span class="c1">1</span><span class="c2">... o</span><span class="c1">n</span><span>.</span></li><li class="c9"><span>A fresh instance </span><span class="c2">a,</span><span>Â of size </span><span class="c2">n</span><span>, </span><span>that implements the built-in interface </span><span class="c2">List</span><span class="c0 c2">&lt;E&gt;</span><span class="c2">Â </span><span>is allocated. </span></li><li class="c9"><span>The operator </span><span class="c0">[]=</span><span>Â is invoked on </span><span class="c2">a</span><span>Â with Â first Â argument </span><span class="c2">i</span><span>Â and second argument </span><span class="c0 c2">o</span><span class="c1 c0">i+1</span><span>, </span><span class="c2">0 &lt;= i &lt;= n.</span></li><li class="c9"><span>The result of the evaluation is </span><span class="c2">a.</span></li></ol><p class="c8"><span></span></p><p class="c13"><span class="c3">Note that this specification does not specify an order in which the elements are set</span><span class="c3 c2">.</span><span class="c3">Â This allows for parallel assignments into the list if an implementation so desires. Â The order can only be observed in checked mode: if element </span><span class="c3 c2">i</span><span class="c3">Â is not a subtype of the element type of the list, a dynamic type error will occur when </span><span class="c3 c2">a[i]</span><span class="c3">Â is assigned </span><span class="c3 c2">o</span><span class="c1 c3">i-1</span><span class="c3">. </span></p><p class="c8"><span></span></p><p class="c13"><span>A runtime list literal Â </span><span class="c2">[e</span><span class="c1">1</span><span class="c2">... e</span><span class="c1">n</span><span class="c2">]</span><span>Â is evaluated as Â </span><span class="c2">&lt;dynamic&gt;[e</span><span class="c1">1</span><span class="c2">... e</span><span class="c1">n</span><span class="c2">]</span><span>.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">There is no restriction precluding nesting of list literals. It follows from the rules above that</span></p><p class="c13"><span class="c0 c3">&lt;List&lt;int&gt;&gt;[[1, 2, 3</span><span class="c0 c3">], [</span><span class="c0 c3">4, 5, 6]] </span><span class="c3">is a list with type parameter </span><span class="c0 c3">List&lt;int&gt;</span><span class="c3">, containing two lists with type parameter </span><span class="c0 c3 c5">dynamic</span><span class="c3">. </span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span>The static type of a list literal of the form Â </span><span class="c0 c5">const</span><span class="c2">Â &lt;E&gt;[e</span><span class="c1">1</span><span class="c2">... e</span><span class="c1">n</span><span class="c2">]</span><span>Â  or the form </span><span class="c2">&lt;E&gt;[e</span><span class="c1">1</span><span class="c2">... e</span><span class="c1">n</span><span class="c2">]</span><span>Â is List</span><span class="c0">&lt;</span><span class="c0 c2">E</span><span class="c0">&gt;.</span><span>Â The static type a list literal of the form Â </span><span class="c0 c5">const</span><span class="c2">Â [e</span><span class="c1">1</span><span class="c2">... e</span><span class="c1">n</span><span class="c2">]</span><span>Â  or the form </span><span class="c2">[e</span><span class="c1">1</span><span class="c2">... e</span><span class="c1">n</span><span class="c2">]</span><span>Â is List</span><span class="c0">&lt;dynamic&gt;.</span></p><p class="c8"><span class="c0"></span></p><p class="c13"><span class="c12 c2">It is tempting to assume that the type of the list literal would be computed based on the types of its elements. However, for mutable lists this may be unwarranted. Even for constant lists, we found this behavior to be problematic. Since compile-time is often actually runtime, the runtime system must be able to perform a complex least upper bound computation to determine a reasonably precise type. It is better to leave this task to a tool in the IDE. It is also much more uniform (and therefore predictable and understandable) to insist that whenever types are unspecified they are assumed to be the unknown type </span><span class="c12 c0 c2 c5">dynamic</span><span class="c12 c2">.</span></p><p class="c8"><span></span></p><a href="#" name="id.riie55qjrb82"></a><h3 class="c13"><a name="h.1f7gnk1hnxaz"></a><span>Maps</span></h3><p class="c8"><span></span></p><p class="c13"><span>A </span><span class="c2">map literal</span><span>Â denotes a </span><span class="c2">map</span><span>Â from strings to objects. </span></p><p class="c8"><span></span></p><a href="#" name="id.yqueh2ebzths"></a><p class="c13"><span class="c2 c5">mapLiteral:</span><span class="c2"><br> Â  Â  </span><span class="c0 c5">const</span><span class="c0">?</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.okv2bn8j19mq">typeArguments</a></span><span class="c2">? &#39;{&#39; (</span><span class="c6 c2"><a class="c4" href="#id.pz53j3hd7ayc">mapLiteralEntry</a></span><span class="c2">Â (&#39;,&#39; </span><span class="c6 c2"><a class="c4" href="#id.pz53j3hd7ayc">mapLiteralEntry</a></span><span class="c2">)* &#39;,&#39;?)? &#39;}&#39;<br> Â  Â ;<br><br></span><a href="#" name="id.pz53j3hd7ayc"></a><span class="c2 c5">mapLiteralEntry:</span></p><p class="c13"><span class="c2">Â  Â  </span><span class="c6 c2"><a class="c4" href="#id.evk894mdov9u">stringLiteral</a></span><span class="c2">Â &#39;:&#39; </span><span class="c6 c2"><a class="c4" href="#id.k68gukuq6cj9">expression</a></span><span class="c2"><br> Â  Â ;<br></span></p><p class="c13"><span>A map literal consists of zero or more </span><span class="c2">entries</span><span>. Each entry has a </span><span class="c2">key,</span><span>Â which is a string literal, and a </span><span class="c2">value,</span><span>Â which is an object. </span></p><p class="c13"><span>Â </span></p><p class="c13"><span>If a map literal begins with the reserved word </span><span class="c0 c5">const</span><span>, it is a </span><span class="c2">constant map literal</span><span>Â which is a </span><span class="c6"><a class="c4" href="#id.hzs87hup8wb">compile-time constant</a></span><span>Â and therefore evaluated at compile-time. Otherwise, it is a run-time map literal and it is evaluated at run-time.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile time error if either a key or a value of an entry in a constant map literal is not a compile-time constant. It is a compile time error if the type arguments of a constant map literal include a type parameter. </span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span>The value of a constant map literal Â </span><span class="c0 c5">const</span><span class="c2">Â &lt;String, V&gt;{k</span><span class="c1">1</span><span class="c2">:e</span><span class="c1">1</span><span class="c2">... k</span><span class="c1">n</span><span class="c2">Â :e</span><span class="c1">n</span><span class="c2">}</span><span>Â is an object </span><span class="c2">m</span><span>Â that implements the built-in class </span><span class="c2">Map&lt;String, V&gt;. </span><span>The entries of </span><span class="c2">m</span><span>Â are </span><span class="c2">u</span><span class="c1">i</span><span class="c2">:v</span><span class="c1">i</span><span>, 1 &lt;= </span><span class="c2">i</span><span>Â &lt;= </span><span class="c2">n</span><span>, where </span><span class="c2">u</span><span class="c1">i</span><span>Â is the value of the compile time expression </span><span class="c2">k</span><span class="c1">i</span><span class="c2">Â and</span><span class="c1">Â </span><span class="c2">v</span><span class="c1">i</span><span>Â is the value of the compile time expression </span><span class="c2">e</span><span class="c1">i</span><span class="c2">. Â </span><span>The value of a constant map literal Â </span><span class="c0 c5">const</span><span class="c2">Â {k</span><span class="c1">1</span><span class="c2">:e</span><span class="c1">1</span><span class="c2">... k</span><span class="c1">n</span><span class="c2">Â :e</span><span class="c1">n</span><span class="c2">} </span><span>is defined as the value of a constant map literal </span><span class="c0 c5">const</span><span class="c2">Â &lt;String, dynamic&gt;{k</span><span class="c1">1</span><span class="c2">:e</span><span class="c1">1</span><span class="c2">... k</span><span class="c1">n</span><span class="c2">Â :e</span><span class="c1">n</span><span class="c2">}</span><span>. Â It is a run-time error to attempt to modify a constant map literal.</span><span class="c3">Â </span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span>Let </span><span class="c2">map</span><span class="c1">1</span><span>Â = </span><span class="c0 c5">const</span><span class="c2">Â &lt;String, V&gt;{k</span><span class="c1">11</span><span class="c2">:e</span><span class="c1">11</span><span class="c2">... k</span><span class="c1">1n</span><span class="c2">Â :e</span><span class="c1">1n</span><span class="c2">} </span><span>and </span><span class="c2">map</span><span class="c1">2</span><span>Â </span><span>=</span><span>Â </span><span class="c0 c5">const</span><span class="c2">Â &lt;String, U&gt;{k</span><span class="c1">21</span><span class="c2">:e</span><span class="c1">21</span><span class="c2">... k</span><span class="c1">2n</span><span class="c2">Â :e</span><span class="c1">2n</span><span class="c2">} </span><span>be two constant map literals. Let the keys of </span><span class="c2">map</span><span class="c1">1</span><span>Â and </span><span class="c2">map</span><span class="c1">2 </span><span>evaluate to Â </span><span class="c2">s</span><span class="c1">11</span><span class="c2">... s</span><span class="c1">1n</span><span class="c2">Â  and Â s</span><span class="c1">21</span><span class="c2">... s</span><span class="c1">2n</span><span class="c2">Â </span><span>respectively,</span><span class="c1">Â </span><span>and let the elements of </span><span class="c2">map</span><span class="c1">1</span><span>Â and </span><span class="c2">map</span><span class="c1">2 </span><span>evaluate to</span><span>Â </span><span class="c2">o</span><span class="c1">11</span><span class="c2">... o</span><span class="c1">1n</span><span>Â and </span><span class="c2">o</span><span class="c1">21</span><span class="c2">... o</span><span class="c1">2n</span><span class="c2">Â </span><span>respectively. Iff </span><span class="c0">identical(</span><span class="c2">o</span><span class="c1">1i</span><span class="c0">, </span><span class="c2">o</span><span class="c1">2i</span><span class="c0">)</span><span>Â  and </span><span class="c0">identical(</span><span class="c2">s</span><span class="c1">1i</span><span class="c0">, </span><span class="c2">s</span><span class="c1">2i</span><span class="c0">) </span><span>for </span><span class="c2">1 &lt;= i &lt;= n, and V = U</span><span>Â then </span><span class="c0">identical(</span><span class="c2">map</span><span class="c1">1</span><span class="c0">,</span><span>Â </span><span class="c2">map</span><span class="c1">2</span><span class="c0">)</span><span>. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">In other words, constant map literals are canonicalized.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span>A runtime map literal </span><span class="c2">&lt;String, V&gt;{k</span><span class="c1">1</span><span class="c2">:e</span><span class="c1">1</span><span class="c2">... k</span><span class="c1">n</span><span class="c2">Â :e</span><span class="c1">n</span><span class="c2">}</span><span>Â  is evaluated as follows:</span></p><ol class="c16" start="5"><li class="c9"><span>First, the expressions </span><span class="c2">e</span><span class="c1">1</span><span class="c2">...e</span><span class="c1">n</span><span>Â are evaluated in left to right order, yielding objects </span><span class="c2">o</span><span class="c1">1</span><span class="c2">... o</span><span class="c1">n</span><span>. </span></li><li class="c9"><span>A fresh instance </span><span class="c2">m</span><span>Â that implements the interface of the built-in class </span><span class="c0 c2">Map&lt;String, V&gt;</span><span class="c2">Â </span><span>is allocated. </span></li><li class="c9"><span>Let </span><span class="c2">u</span><span class="c1">i</span><span>Â be the value of the compile-time constant string specified by </span><span class="c2">k</span><span class="c1">i</span><span class="c2">.</span><span>Â The operator </span><span class="c0">[]=</span><span>Â is invoked on </span><span class="c2">a</span><span>Â with Â first Â argument </span><span class="c2">u</span><span class="c1">i</span><span>Â and second argument </span><span class="c2">o</span><span class="c1">i</span><span class="c2">,</span><span>Â </span><span class="c2">0 &lt;= i &lt;= n</span><span>.</span></li><li class="c9"><span>The result of the evaluation is </span><span class="c2">m.</span></li></ol><p class="c8"><span></span></p><p class="c13"><span>A runtime map literal Â </span><span class="c2">{k</span><span class="c1">1</span><span class="c2">:e</span><span class="c1">1</span><span class="c2">... k</span><span class="c1">n</span><span class="c2">Â :e</span><span class="c1">n</span><span class="c2">}</span><span>Â is evaluated as Â </span><span class="c2">&lt;String, dynamic&gt;{k</span><span class="c1">1</span><span class="c2">:e</span><span class="c1">1</span><span class="c2">... k</span><span class="c1">n</span><span class="c2">Â :e</span><span class="c1">n</span><span class="c2">}</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a static warning if the values of any two keys in a map literal are equal.</span></p><p class="c8"><span></span></p><p class="c13"><span>A map literal is </span><span class="c2">ordered:</span><span>Â iterating over the keys and/or values of the maps always happens in the order the keys appeared in the source code.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span class="c3">Of course,</span><span class="c3">Â if a key repeats, the order is defined by first occurrence, but the value is defined by the last. </span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span>The static type of a map literal of the form Â </span><span class="c0 c5">const</span><span class="c2">Â &lt;String, V&gt;{k</span><span class="c1">1</span><span class="c2">:e</span><span class="c1">1</span><span class="c2">... k</span><span class="c1">n</span><span class="c2">Â :e</span><span class="c1">n</span><span class="c2">}</span><span>Â or the form </span><span class="c2">&lt;String, V&gt;{k</span><span class="c1">1</span><span class="c2">:e</span><span class="c1">1</span><span class="c2">... k</span><span class="c1">n</span><span class="c2">Â :e</span><span class="c1">n</span><span class="c2">} </span><span>is </span><span class="c0">Map&lt;String, </span><span class="c0 c2">V</span><span class="c0">&gt;.</span><span>Â The static type a map literal of the form Â </span><span class="c0 c5">const</span><span class="c2">Â {k</span><span class="c1">1</span><span class="c2">:e</span><span class="c1">1</span><span class="c2">... k</span><span class="c1">n</span><span class="c2">Â :e</span><span class="c1">n</span><span class="c2">}</span><span>Â or the form </span><span class="c2">{k</span><span class="c1">1</span><span class="c2">:e</span><span class="c1">1</span><span class="c2">... k</span><span class="c1">n</span><span class="c2">Â :e</span><span class="c1">n</span><span class="c2">} </span><span>is </span><span class="c0">Map&lt;String, dynamic&gt;. </span><span>It is a compile-time error if the first type argument to a map literal is not </span><span class="c0">String</span><span>.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="kix.s2h8t3rjj21s"></a><h3 class="c13"><a name="h.lo4c3zw824l"></a><span>Throw</span></h3><p class="c8"><span></span></p><p class="c13"><span class="c2">In the M2 release, Â </span><span class="c0 c2 c5">throw</span><span class="c2">Â is not treated as an expression by all implementations. It is safe to use </span><span class="c0 c2 c5">throw</span><span class="c2">Â as a statement. The rules for </span><span class="c0 c2 c5">throw</span><span class="c2">Â remain subject to change. </span></p><p class="c8"><span></span></p><p class="c13"><span>The </span><span class="c2">throw expression</span><span>Â is used to raise or re-raise an exception.</span></p><p class="c8"><span></span></p><a href="#" name="kix.8xgyk1afd3ei"></a><p class="c13"><span class="c2 c5">throwExpression</span><span class="c2 c5">:</span><span class="c2"><br> Â  Â  </span><span class="c0 c5">throw</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.1u3vxuwrz6py">expression</a></span><span class="c2">? <br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.ndl7z65wpgd0"></a><p class="c13"><span class="c2 c5">throwExpressionWithoutCascade:</span><span class="c2"><br> Â  Â  </span><span class="c0 c5">throw</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.k68gukuq6cj9">expressionWithoutCascade</a></span><span class="c2">? <br> Â  Â ;<br><br></span></p><p class="c13"><span>The </span><span class="c2">current exception</span><span>Â is the last unhandled exception thrown. </span></p><p class="c8"><span class="c3 c2"></span></p><p class="c13"><span>Evaluation of a throw statement of the form </span><span class="c0 c5">throw</span><span>Â </span><span class="c0 c2">e </span><span class="c0">;</span><span>Â proceeds as follows:</span></p><p class="c13"><span>The expression </span><span class="c2">e</span><span>Â is </span><span>evaluated</span><span>Â </span><span>yielding a value </span><span class="c2">v</span><span class="c2">. </span><span>If </span><span class="c2">v </span><span>evaluates to </span><span class="c0 c5">null</span><span>, then a </span><span class="c0">NullThrownError</span><span>Â </span><span>is thrown. Otherwise, control is transferred to the nearest dynamically enclosing </span><span class="c7"><a class="c4" href="#id.vlflmf5cnfa1">exception handler</a></span><span>, with the current exception set to </span><span class="c2">v</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">There is no requirement that the expression </span><span class="c3 c2">e</span><span class="c3">Â evaluate to a special kind of exception or error object.</span></p><p class="c8"><span></span></p><p class="c13"><span>Evaluation of a statement of the form </span><span class="c0 c5">throw</span><span class="c0">;</span><span>Â proceeds as follows:</span></p><p class="c13"><span>Control is transferred to the nearest dynamically enclosing </span><span class="c7"><a class="c4" href="#id.vlflmf5cnfa1">exception handler</a></span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">No change is made to the current exception.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error if an expression of the form </span><span class="c0 c5">throw</span><span class="c0">; </span><span>is not enclosed within a on-</span><span>catch</span><span>Â clause.</span></p><p class="c8"><span class="c0"></span></p><p class="c13"><span>The static type of a throw expression is bottom.</span></p><p class="c8"><span class="c0"></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.kmutx51qdso8"></a><h3 class="c13"><a name="h.w0k5ugtz3rpv"></a><span>Function Expressions</span></h3><p class="c8"><span></span></p><p class="c13"><span>A </span><span class="c2">function literal</span><span>Â is an object that encapsulates an executable unit of code. </span></p><p class="c8"><span></span></p><a href="#" name="id.p3fm2ke402rw"></a><p class="c13"><span class="c2 c5">functionExpression:</span><span class="c2"><br> Â  Â </span><span class="c6 c2"><a class="c4" href="#id.6xer2paz3k7q">formalParameterList</a></span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.airwihpzw070">functionExpressionBody</a></span><span class="c2"><br> Â  Â ;<br><br><br></span><a href="#" name="id.airwihpzw070"></a><span class="c2 c5">functionExpressionBody:</span><span class="c2"><br> Â  Â  Â &#39;=&gt;&#39; </span><span class="c6 c2"><a class="c4" href="#id.1u3vxuwrz6py">expression</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#kix.kx7urn183i41">block</a></span><span class="c2"><br> Â  Â ;</span></p><p class="c13"><span class="c2"><br></span><span>Â </span><span>A function literal implements the built-in class </span><span class="c0">Function.</span></p><p class="c8"><span></span></p><p class="c13"><span>The static type of a function literal of the form </span><span class="c2">(T</span><span class="c10 c2">1 </span><span class="c2">a</span><span class="c10 c2">1</span><span class="c2">, â¦, T</span><span class="c10 c2">n </span><span class="c2">a</span><span class="c10 c2">n</span><span class="c2">, [T</span><span class="c10 c2">n+1 Â </span><span class="c2">x</span><span class="c10 c2">n+1</span><span class="c2">Â = d</span><span class="c10 c2">1</span><span class="c2">, â¦ ,T</span><span class="c10 c2">n+k</span><span class="c2">Â x</span><span class="c10 c2">n+k</span><span class="c2">Â = d</span><span class="c10 c2">k</span><span class="c2">]) =&gt; e</span><span>Â is </span><span class="c2">(T</span><span class="c10 c2">1</span><span class="c2">, â¦, T</span><span class="c10 c2">n</span><span class="c2">, [T</span><span class="c10 c2">n+1</span><span class="c2">Â x</span><span class="c10 c2">n+1</span><span class="c2">, .., T</span><span class="c10 c2">n+k</span><span class="c2">Â x</span><span class="c10 c2">n+k</span><span class="c2">]) âT</span><span class="c10 c2">0</span><span>, where </span><span class="c2">T</span><span class="c10 c2">0</span><span>Â is the static type of </span><span class="c2">e.</span><span>Â In any case where </span><span class="c2">T</span><span class="c10 c2">i</span><span class="c2">Â ,1 &lt;= i &lt;= </span><span class="c2">n</span><span class="c2">, Â </span><span>is not specified, it is considered to have been specified as </span><span class="c0 c5">dynamic</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>The static type of a function literal of the form </span><span class="c2">(T</span><span class="c10 c2">1 </span><span class="c2">a</span><span class="c10 c2">1</span><span class="c2">, â¦, T</span><span class="c10 c2">n </span><span class="c2">a</span><span class="c10 c2">n</span><span class="c2">, {T</span><span class="c10 c2">n+1 Â </span><span class="c2">x</span><span class="c10 c2">n+1</span><span class="c2">Â : d</span><span class="c10 c2">1</span><span class="c2">, â¦ ,T</span><span class="c10 c2">n+k</span><span class="c2">Â x</span><span class="c10 c2">n+k</span><span class="c2">Â : d</span><span class="c10 c2">k</span><span class="c2">}) =&gt; e</span><span>Â is </span><span class="c2">(T</span><span class="c10 c2">1</span><span class="c2">, â¦, T</span><span class="c10 c2">n</span><span class="c2">, {T</span><span class="c10 c2">n+1</span><span class="c2">Â x</span><span class="c10 c2">n+1</span><span class="c2">, .., T</span><span class="c10 c2">n+k</span><span class="c2">Â x</span><span class="c10 c2">n+k</span><span class="c2">}) âT</span><span class="c10 c2">0</span><span>, where </span><span class="c2">T</span><span class="c10 c2">0</span><span>Â is the static type of </span><span class="c2">e.</span><span>Â In any case where </span><span class="c2">T</span><span class="c10 c2">i</span><span class="c2">Â ,1 &lt;= i &lt;= n, Â </span><span>is not specified, it is considered to have been specified as </span><span class="c0 c5">dynamic</span><span>.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span>The static type of a function literal of the form </span><span class="c2">(T</span><span class="c10 c2">1 </span><span class="c2">a</span><span class="c10 c2">1</span><span class="c2">, â¦, T</span><span class="c10 c2">n </span><span class="c2">a</span><span class="c10 c2">n</span><span class="c2">, [T</span><span class="c10 c2">n+1 Â </span><span class="c2">x</span><span class="c10 c2">n+1</span><span class="c2">Â = d</span><span class="c10 c2">1</span><span class="c2">, â¦, T</span><span class="c10 c2">n+k</span><span class="c2">Â x</span><span class="c10 c2">n+k</span><span class="c2">Â = d</span><span class="c10 c2">k</span><span class="c2">]) {s} </span><span>is </span><span class="c2">(T</span><span class="c10 c2">1</span><span class="c2">, â¦, T</span><span class="c10 c2">n</span><span class="c2">, [T</span><span class="c10 c2">n+1</span><span class="c2">Â x</span><span class="c10 c2">n+1</span><span class="c2">, .., T</span><span class="c10 c2">n+k</span><span class="c2">Â x</span><span class="c10 c2">n+k</span><span class="c2">]) â </span><span class="c0 c5">dynamic</span><span class="c2">.</span><span>Â In any case where </span><span class="c2">T</span><span class="c10 c2">i</span><span class="c2">Â ,1 &lt;= i &lt;= n, </span><span>is not specified, it is considered to have been specified as </span><span class="c0 c5">dynamic</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>The static type of a function literal of the form </span><span class="c2">(T</span><span class="c10 c2">1 </span><span class="c2">a</span><span class="c10 c2">1</span><span class="c2">, â¦, T</span><span class="c10 c2">n </span><span class="c2">a</span><span class="c10 c2">n</span><span class="c2">, {T</span><span class="c10 c2">n+1 Â </span><span class="c2">x</span><span class="c10 c2">n+1</span><span class="c2">Â : d</span><span class="c10 c2">1</span><span class="c2">, â¦, T</span><span class="c10 c2">n+k</span><span class="c2">Â x</span><span class="c10 c2">n+k</span><span class="c2">Â : d</span><span class="c10 c2">k</span><span class="c2">}) {s} </span><span>is </span><span class="c2">(T</span><span class="c10 c2">1</span><span class="c2">, â¦, T</span><span class="c10 c2">n</span><span class="c2">, {T</span><span class="c10 c2">n+1</span><span class="c2">Â x</span><span class="c10 c2">n+1</span><span class="c2">, .., T</span><span class="c10 c2">n+k</span><span class="c2">Â x</span><span class="c10 c2">n+k</span><span class="c2">}) â </span><span class="c0 c5">dynamic</span><span class="c2">.</span><span>Â In any case where </span><span class="c2">T</span><span class="c10 c2">i</span><span class="c2">Â ,1 &lt;= i &lt;= n, </span><span>is not specified, it is considered to have been specified as </span><span class="c0 c5">dynamic</span><span>.</span><span class="c2"><br></span></p><a href="#" name="id.v2khzso6nh04"></a><h3 class="c13"><a name="h.a02n00oljphq"></a><span>This</span></h3><p class="c13"><span>The reserved word </span><span class="c0 c5">this</span><span>Â denotes the target of the current instance member invocation.</span></p><p class="c8"><span></span></p><a href="#" name="id.wwq4i2tyv7sn"></a><p class="c13"><span class="c2 c5">thisExpression:</span><span class="c2"><br> Â  Â  Â </span><span class="c0 c5">this</span></p><p class="c13"><span class="c0">Â  Â  Â ;</span></p><p class="c8"><span class="c0"></span></p><p class="c13"><span>The static type of </span><span class="c0 c5">this</span><span>Â is the</span><span>Â interface of the immediately enclosing class.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">We do not support self-types at this point. </span></p><p class="c8"><span class="c0"></span></p><p class="c13"><span>It is a compile-time erro</span><span>r </span><span class="c0">if </span><span class="c0 c5">this</span><span>Â appears</span><span>Â in a top-level function or variable initializer, Â in a factory constructor, or in a static method or variable initializer, or in the initializer of an instance variable.</span><span class="c0">Â </span></p><p class="c8"><span></span></p><a href="#" name="id.hvkbnlui8uvu"></a><h3 class="c13"><a name="h.seezxc7foicl"></a><span>Instance Creation</span></h3><p class="c8"><span></span></p><p class="c13"><span>Instance creation expressions invoke constructors to produce instances. </span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error if a constructor of a non-generic type invoked by a new expression or a constant object expression is passed any type arguments. It is a compile-time error if a constructor of a generic type with </span><span class="c2">n</span><span>Â type parameters invoked by a new expression or a constant object expression is passed </span><span class="c2">m</span><span>Â type arguments where </span><span class="c2">m != n</span><span>. </span></p><p class="c8"><span></span></p><p class="c13"><span>It is a static type warning if any of the type arguments to a constructor of a generic type </span><span class="c2">G</span><span>Â invoked by a new expression or a constant object expression are not </span><span>subtypes of the bounds</span><span>Â of the corresponding formal type parameters of </span><span class="c2">G.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.pp0ymlz8g03s"></a><h4 class="c13"><a name="h.twiod7rqtbah"></a><span>New</span></h4><p class="c13"><span>The </span><span class="c2">new expression</span><span>Â invokes a </span><span class="c7"><a class="c4" href="#id.yh8ud94ky84">constructor</a></span><span>.</span></p><p class="c8"><span></span></p><a href="#" name="id.a0815nq10roy"></a><p class="c13"><span class="c2 c5">newExpression:</span></p><p class="c13 c48"><span class="c0 c5">new</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.qv2a3rupuer9">type</a></span><span class="c2">Â (&#39;.&#39; </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2">)? </span><span class="c7 c2"><a class="c4" href="#kix.xl2ewwstkqba">arguments</a></span></p><p class="c13 c48"><span>;</span></p><p class="c8"><span></span></p><p class="c13"><span>Let </span><span class="c2">e</span><span>Â be a new expression of the form </span><span class="c0 c5">new</span><span class="c2">Â T.id(a</span><span class="c10 c2">1</span><span class="c2">, .., a</span><span class="c10 c2">n</span><span class="c2">,</span><span class="c10 c2">Â </span><span class="c2">x</span><span class="c10 c2">n+1</span><span class="c2">: a</span><span class="c10 c2">n+1</span><span class="c2">, â¦, x</span><span class="c10 c2">n+k</span><span class="c2">: a</span><span class="c10 c2">n+k</span><span class="c2">) </span><span>or the form </span><span class="c0 c5">new</span><span class="c2">Â T(a</span><span class="c10 c2">1</span><span class="c2">, .., a</span><span class="c10 c2">n</span><span class="c2">,</span><span class="c10 c2">Â </span><span class="c2">x</span><span class="c10 c2">n+1</span><span class="c2">: a</span><span class="c10 c2">n+1</span><span class="c2">, â¦, x</span><span class="c10 c2">n+k</span><span class="c2">: a</span><span class="c10 c2">n+k</span><span class="c2">)</span><span>.</span><span class="c2">Â </span><span>It is a </span><span>static warning</span><span>Â if </span><span class="c2">T</span><span>Â is not a class accessible in the current scope, optionally followed by type arguments.</span></p><p class="c8"><span></span></p><p class="c13"><span>If </span><span class="c2">T</span><span>Â is a class or parameterized type accessible in the current scope then: </span></p><p class="c8"><span></span></p><ol class="c16" start="1"><li class="c9"><span>If </span><span class="c2">e</span><span>Â is of the form </span><span class="c0 c5">new</span><span class="c2">Â T.id(a</span><span class="c10 c2">1</span><span class="c2">, .., a</span><span class="c10 c2">n</span><span class="c2">,</span><span class="c10 c2">Â </span><span class="c2">x</span><span class="c10 c2">n+1</span><span class="c2">: a</span><span class="c10 c2">n+1</span><span class="c2">, â¦, x</span><span class="c10 c2">n+k</span><span class="c2">: a</span><span class="c10 c2">n+k</span><span class="c2">) </span><span>it is a static warning if </span><span class="c2">T.id</span><span>Â is not the name of a constructor declared by the type </span><span class="c2">T.</span><span>Â If </span><span class="c2">e</span><span>Â of the form </span><span class="c0 c5">new</span><span class="c2">Â T(a</span><span class="c10 c2">1</span><span class="c2">, .., a</span><span class="c10 c2">n</span><span class="c2">,</span><span class="c10 c2">Â </span><span class="c2">x</span><span class="c10 c2">n+1</span><span class="c2">: a</span><span class="c10 c2">n+1</span><span class="c2">, â¦, x</span><span class="c10 c2">n+k</span><span class="c2">: a</span><span class="c10 c2">n+k</span><span class="c2">) </span><span>it is a static warning if the type </span><span class="c2">T </span><span>does not declare a constructor with the same name as the declaration of </span><span class="c2">T.</span></li></ol><p class="c8"><span class="c2"></span></p><p class="c13"><span>If </span><span class="c2">T</span><span>Â is a parameterized type </span><span class="c2">S&lt;U</span><span class="c10 c2">1</span><span class="c2">, ,.., U</span><span class="c10 c2">m</span><span class="c2">&gt;,</span><span>Â let </span><span class="c2">R = S.</span><span>Â </span><span class="c2">Â </span><span>It is a compile time error if </span><span class="c2">S</span><span>Â is not a generic type with </span><span class="c2">m</span><span>Â type parameters. If </span><span class="c2">T</span><span>Â is not a parameterized type, let </span><span class="c2">R = T.</span></p><p class="c13"><span>Furthermore, if </span><span class="c2">e</span><span>Â is of the form </span><span class="c0 c5">new</span><span class="c2">Â T.id(a</span><span class="c10 c2">1</span><span class="c2">, .., a</span><span class="c10 c2">n</span><span class="c2">,</span><span class="c10 c2">Â </span><span class="c2">x</span><span class="c10 c2">n+1</span><span class="c2">: a</span><span class="c10 c2">n+1</span><span class="c2">, â¦, x</span><span class="c10 c2">n+k</span><span class="c2">: a</span><span class="c10 c2">n+k</span><span class="c2">)</span><span>Â then let Â </span><span class="c2">q </span><span>be the constructor </span><span class="c2">T.id, </span><span>otherwise let </span><span class="c2">q</span><span>Â be the constructor </span><span class="c2">T</span><span>. Finally, if </span><span class="c2">R</span><span>Â is generic but </span><span class="c2">T</span><span>Â is not a parameterized type, then for </span><span class="c2">1 &lt;= i &lt;= m, let V</span><span class="c10 c2">i</span><span class="c2">Â = </span><span class="c0 c5">dynamic</span><span>, otherwise let </span><span class="c2">V</span><span class="c10 c2">i</span><span class="c2">Â = U</span><span class="c10 c2">i</span><span class="c2">. </span><span>Â </span></p><p class="c8"><span></span></p><p class="c13"><span>Evaluation of </span><span class="c2">e</span><span>Â proceeds as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>If </span><span class="c2">T</span><span>Â is not a class accessible in the current scope, a dynamic error occurs. Otherwise, if </span><span class="c2">q</span><span>Â is not defined or not accessible, a </span><span class="c0">NoSuchMethodError</span><span>Â is thrown. Â  If </span><span class="c2">q</span><span>Â has Â less than </span><span class="c2">n</span><span>Â positional parameters or more than </span><span class="c2">n</span><span>Â required parameters, or if </span><span class="c2">q</span><span>Â lacks any of the keyword parameters {x</span><span class="c1">n+1</span><span>, ..., x</span><span class="c22">n+k</span><span>} a </span><span class="c0">NoSuchMethodError</span><span>Â is thrown. Otherwise, if </span><span class="c2">q</span><span>Â is a generative constructor (regardless of whether </span><span class="c2">q</span><span>Â is redirecting or not), then:</span></p><p class="c8"><span></span></p><p class="c13"><span>Â  Â  Â  Â  Â  Â If </span><span class="c2">q</span><span>Â is a non-factory constructor of an abstract class then an Â </span><span class="c0">AbstractClassInstantiationError</span><span>Â is thrown.</span></p><p class="c8"><span></span></p><p class="c13 c23"><span>Otherwise, let </span><span class="c2">T</span><span class="c10 c2">i</span><span>Â be the type parameters of </span><span class="c2">R</span><span>Â (if any) and let </span><span class="c2">B</span><span class="c10 c2">i</span><span>Â be the bounds of </span><span class="c2">T</span><span class="c10 c2">i</span><span class="c2">, 1 &lt;= i &lt;= m.</span><span>Â It is a dynamic type error if, in checked mode, </span><span class="c2">V</span><span class="c10 c2">i</span><span class="c10">Â </span><span>is not a subtype of Â </span><span class="c2">[V</span><span class="c10 c2">1</span><span class="c2">, Â ..., V</span><span class="c10 c2">m</span><span class="c2">/T</span><span class="c10 c2">1</span><span class="c2">, Â ..., T</span><span class="c10 c2">m</span><span class="c2">]B</span><span class="c10 c2">i</span><span class="c2">, 1 &lt;= i &lt;= m.</span></p><p class="c8"><span class="c2"></span></p><p class="c13 c23"><span>A fresh instance,</span><span class="c2">Â i,</span><span>Â  of class </span><span class="c2">R</span><span>Â is allocated. For each instance variable </span><span class="c2">f</span><span>Â of </span><span class="c2">i, </span><span>Â if the variable declaration of </span><span class="c2">f</span><span>Â has an initializer expression </span><span class="c2">e</span><span class="c10 c2">f</span><span>, then </span><span class="c2">e</span><span class="c10 c2">f </span><span>is evaluated to an object </span><span class="c2">o</span><span class="c10 c2">f </span><span>and </span><span class="c2">f</span><span>Â is bound to </span><span class="c2">o</span><span class="c10 c2">f</span><span>. Otherwise </span><span class="c2">f</span><span>Â is bound to </span><span class="c0 c5">null.</span><span>Â  </span></p><p class="c8"><span></span></p><p class="c13 c23"><span class="c3">Observe that </span><span class="c0 c3 c5">this</span><span class="c3">Â is not in scope in </span><span class="c3 c2">e</span><span class="c10 c3 c2">f</span><span class="c3">. Hence, the initialization cannot depend on other properties of the object being instantiated. </span><span class="c18">Do we want to say that </span><span class="c0 c5 c18">this</span><span class="c18">Â is not in scope, or that using </span><span class="c0 c18 c5">this</span><span class="c18">Â is illegal?</span></p><p class="c8"><span class="c18"></span></p><p class="c13 c23"><span>Next, the argument list </span><span class="c2">(a</span><span class="c10 c2">1</span><span class="c2">, â¦, a</span><span class="c10 c2">n</span><span class="c2">, x</span><span class="c10 c2">n+1</span><span class="c2">: a</span><span class="c10 c2">n+1</span><span class="c2">, â¦, x</span><span class="c2 c10">n+k</span><span class="c2">: a</span><span class="c10 c2">n+k</span><span class="c2">)</span><span>Â is evaluated. Then, </span><span class="c2">q</span><span>Â is executed with </span><span class="c0 c5">this</span><span>Â bound to </span><span class="c2">i</span><span>, the type parameters (if any) of </span><span class="c2">R</span><span>Â bound to the actual type arguments </span><span class="c2">V</span><span class="c10 c2">1</span><span class="c2">, ..., V</span><span class="c10 c2">m</span><span>Â and the formal parameters of </span><span class="c2">q</span><span>Â bound to the corresponding actual arguments. The result of the evaluation of </span><span class="c2">e</span><span>Â is </span><span class="c2">i.</span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>Otherwise, </span><span class="c2">q</span><span>Â is a factory constructor. Then:</span></p><p class="c8"><span></span></p><p class="c13 c23"><span>L</span><span>et </span><span class="c2">T</span><span class="c10 c2">i</span><span>Â be the type parameters of </span><span class="c2">R</span><span>Â (if any) and let </span><span class="c2">B</span><span class="c10 c2">i</span><span>Â be the bounds of </span><span class="c2">T</span><span class="c10 c2">i</span><span class="c2">, 1 &lt;= i &lt;= m.</span><span>Â In checked mode, it is a dynamic type error if </span><span class="c2">V</span><span class="c10 c2">i</span><span class="c10">Â </span><span>is not a subtype of Â </span><span class="c2">[V</span><span class="c10 c2">1</span><span class="c2">, Â ..., V</span><span class="c10 c2">m</span><span class="c2">/T</span><span class="c10 c2">1</span><span class="c2">, Â ..., T</span><span class="c10 c2">m</span><span class="c2">]B</span><span class="c10 c2">i</span><span class="c2">, 1 &lt;= i &lt;= m.</span></p><p class="c13 c23"><span>If </span><span class="c2">q </span><span>is a redirecting factory constructor of the form </span><span class="c2">T(p</span><span class="c10 c2">1</span><span class="c2">, â¦, p</span><span class="c10 c2">n+k</span><span class="c2">) = c; </span><span>or of the form Â </span><span class="c2">T.id(p</span><span class="c10 c2">1</span><span class="c2">, â¦, p</span><span class="c10 c2">n+k</span><span class="c2">) = c; </span><span>then the result of the evaluation of </span><span class="c2">e</span><span>Â is equivalent to evaluating the expression </span><span class="c2">[V</span><span class="c10 c2">1</span><span class="c2">, Â ..., V</span><span class="c10 c2">m</span><span class="c2">/T</span><span class="c10 c2">1</span><span class="c2">, Â ..., T</span><span class="c10 c2">m</span><span class="c2">](</span><span class="c5">new</span><span>Â c</span><span class="c2">(a</span><span class="c10 c2">1</span><span class="c2">, â¦, a</span><span class="c10 c2">n</span><span class="c2">, x</span><span class="c10 c2">n+1</span><span class="c2">: a</span><span class="c10 c2">n+1</span><span class="c2">, â¦, x</span><span class="c10 c2">n+k</span><span class="c2">: a</span><span class="c10 c2">n+k</span><span class="c2">)).</span></p><p class="c8"><span class="c2"></span></p><p class="c13 c23"><span>Otherwise, t</span><span>he argument list </span><span class="c2">(a</span><span class="c10 c2">1</span><span class="c2">, â¦, a</span><span class="c10 c2">n</span><span class="c2">, x</span><span class="c10 c2">n+1</span><span class="c2">: a</span><span class="c10 c2">n+1</span><span class="c2">, â¦, x</span><span class="c10 c2">n+k</span><span class="c2">: a</span><span class="c10 c2">n+k</span><span class="c2">)</span><span>Â is evaluated. Then, the body of </span><span class="c2">q</span><span>Â is executed Â with respect to the bindings that resulted from the evaluation of the argument list and the type parameters (if any) of </span><span class="c2">q</span><span>Â bound to the actual type arguments </span><span class="c2">V</span><span class="c10 c2">1</span><span class="c2">, ,.., V</span><span class="c10 c2">m</span><span>Â resulting in an object </span><span class="c2">i.</span><span>Â The result of the evaluation of </span><span class="c2">e</span><span>Â is </span><span class="c2">i.</span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>It is a static warning if </span><span class="c2">q</span><span>Â is a constructor of an abstract class and </span><span class="c2">q</span><span>Â is not a factory constructor.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c25">The above gives precise meaning to the idea that instantiating an abstract class leads to a warning at compile time. Â A similar clause applies to constant object creation in the next section.</span></p><p class="c8"><span class="c25"></span></p><p class="c13"><span class="c2 c12">In particular, a factory constructor can be declared in an abstract class and used safely, as it will either produce a valid instance or lead to a warning inside its own declaration.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span>The static type of a new expression of either the form </span><span class="c0 c5">new</span><span class="c2">Â T.id(a</span><span class="c10 c2">1</span><span class="c2">, .., a</span><span class="c10 c2">n</span><span class="c2">)</span><span>Â or the form </span><span class="c0 c5">new</span><span class="c2">Â T(a</span><span class="c10 c2">1</span><span class="c2">, .., a</span><span class="c10 c2">n</span><span class="c2">)</span><span>Â is</span><span class="c2">Â T.</span><span>Â It is a static warning if the static type of </span><span class="c2">a</span><span class="c10 c2">i</span><span class="c2">, 1 &lt;= i &lt;= n+ k </span><span>may not be assigned to the type of the corresponding formal parameter of the constructor </span><span class="c2">T.id</span><span>Â (respectively </span><span class="c2">T</span><span>).</span></p><p class="c8"><span class="c25"></span></p><p class="c8"><span></span></p><a href="#" name="id.bfpdh2tlvt0v"></a><h4 class="c13"><a name="h.kk36x2av9f7f"></a><span>Const</span></h4><p class="c13"><span>A </span><span class="c2">constant object expression</span><span>Â invokes a </span><span class="c7"><a class="c4" href="#id.okcph2t66jnm">constant constructor</a></span><span>. </span></p><p class="c8"><span></span></p><a href="#" name="id.py555jou6no8"></a><p class="c13"><span class="c2 c5">constObjectExpression:</span></p><p class="c13 c48"><span class="c0 c5">const</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.qv2a3rupuer9">type</a></span><span class="c2">Â (&#39;.&#39; </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2">)? </span><span class="c6 c2"><a class="c4" href="#kix.xl2ewwstkqba">arguments</a></span></p><p class="c13 c48"><span>;</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span>Let </span><span class="c2">e</span><span>Â be a constant object expression of the form </span><span class="c0 c5">const</span><span class="c2">Â T.id(a</span><span class="c10 c2">1</span><span class="c2">, .., a</span><span class="c10 c2">n</span><span class="c2">,</span><span class="c10 c2">Â </span><span class="c2">x</span><span class="c10 c2">n+1</span><span class="c2">: a</span><span class="c10 c2">n+1</span><span class="c2">, â¦, x</span><span class="c10 c2">n+k</span><span class="c2">: a</span><span class="c10 c2">n+k</span><span class="c2">) </span><span>or the form </span><span class="c0 c5">const</span><span class="c2">Â T(a</span><span class="c10 c2">1</span><span class="c2">, .., a</span><span class="c10 c2">n</span><span class="c2">,</span><span class="c10 c2">Â </span><span class="c2">x</span><span class="c10 c2">n+1</span><span class="c2">: a</span><span class="c10 c2">n+1</span><span class="c2">, â¦, x</span><span class="c10 c2">n+k</span><span class="c2">: a</span><span class="c10 c2">n+k</span><span class="c2">)</span><span>.</span><span class="c2">Â </span><span>It is a compile-time error if </span><span class="c2">T</span><span>Â is not a class accessible in the current scope, optionally followed by type arguments. Â It is a compile-time error if </span><span class="c2">T</span><span>Â includes any type parameters.</span></p><p class="c8"><span></span></p><p class="c13"><span>If </span><span class="c2">e</span><span>Â is of the form </span><span class="c0 c5">const</span><span class="c2">Â T.id(a</span><span class="c10 c2">1</span><span class="c2">, .., a</span><span class="c10 c2">n</span><span class="c2">,</span><span class="c10 c2">Â </span><span class="c2">x</span><span class="c10 c2">n+1</span><span class="c2">: a</span><span class="c10 c2">n+1</span><span class="c2">, â¦, x</span><span class="c10 c2">n+k</span><span class="c2">: a</span><span class="c10 c2">n+k</span><span class="c2">)</span><span>Â it is a compile-time error if </span><span class="c2">T</span><span>Â is not a class accessible in the current scope, optionally followed by type arguments. </span><span class="c2">Â </span><span>It is a compile-time error if </span><span class="c2">T.id</span><span>Â is not the name of a constant constructor declared by the type </span><span class="c2">T.</span><span>Â If </span><span class="c2">e</span><span>Â is of the form </span><span class="c0 c5">const</span><span class="c2">Â T(a</span><span class="c10 c2">1</span><span class="c2">, .., a</span><span class="c10 c2">n</span><span class="c2">,</span><span class="c10 c2">Â </span><span class="c2">x</span><span class="c10 c2">n+1</span><span class="c2">: a</span><span class="c10 c2">n+1</span><span class="c2">, â¦, x</span><span class="c10 c2">n+k</span><span class="c2">: a</span><span class="c10 c2">n+k</span><span class="c2">) </span><span>it is a compile-time error if the type </span><span class="c2">T </span><span>does not declare a</span><span><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.okcph2t66jnm">Â </a></span><span class="c7"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.okcph2t66jnm">constant constructor</a></span><span>Â with the same name as the declaration of </span><span class="c2">T.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>In all of the above cases, it is a compile-time error if </span><span class="c2">a</span><span class="c10 c2">i</span><span class="c2">, 1 &lt; = i &lt;= n + k,</span><span>Â is not a compile-time constant expression.</span></p><p class="c8"><span></span></p><p class="c13"><span>If </span><span class="c2">T</span><span>Â is a parameterized type </span><span class="c2">S&lt;U</span><span class="c10 c2">1</span><span class="c2">, ,.., U</span><span class="c10 c2">m</span><span class="c2">&gt;,</span><span>Â let </span><span class="c2">R = S; </span><span>It is a compile time error if </span><span class="c2">S</span><span>Â is not a generic type with </span><span class="c2">m</span><span>Â type parameters. If </span><span class="c2">T</span><span>Â is not a parameterized type, let </span><span class="c2">R = T.</span></p><p class="c13"><span>Finally, if </span><span class="c2">R</span><span>Â is generic but </span><span class="c2">T</span><span>Â is not a parameterized type, then for </span><span class="c2">1 &lt;= i &lt;= m, let V</span><span class="c10 c2">i</span><span class="c2">Â = </span><span class="c0 c5">dynamic</span><span>, otherwise let </span><span class="c2">V</span><span class="c10 c2">i</span><span class="c2">Â = U</span><span class="c10 c2">i</span><span class="c2">. </span><span>Â </span></p><p class="c8"><span></span></p><p class="c13"><span>Evaluation of </span><span class="c2">e</span><span>Â proceeds as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>First, if </span><span class="c2">e</span><span>Â is of the form </span><span class="c0 c5">const</span><span class="c2">Â T.id(a</span><span class="c10 c2">1</span><span class="c2">, .., a</span><span class="c10 c2">n</span><span class="c2">,</span><span class="c10 c2">Â </span><span class="c2">x</span><span class="c10 c2">n+1</span><span class="c2">: a</span><span class="c10 c2">n+1</span><span class="c2">, â¦, x</span><span class="c10 c2">n+k</span><span class="c2">: a</span><span class="c10 c2">n+k</span><span class="c2">)</span><span>Â then let </span><span class="c2">i</span><span>Â be the value of the expression </span><span class="c0 c5">new</span><span class="c2">Â T.id(a</span><span class="c10 c2">1</span><span class="c2">, .., a</span><span class="c10 c2">n</span><span class="c2">,</span><span class="c10 c2">Â </span><span class="c2">x</span><span class="c10 c2">n+1</span><span class="c2">: a</span><span class="c10 c2">n+1</span><span class="c2">, â¦, x</span><span class="c10 c2">n+k</span><span class="c2">: a</span><span class="c10 c2">n+k</span><span class="c2">)</span><span>. Otherwise, </span><span class="c2">e</span><span>Â must be of the form Â </span><span class="c0 c5">const</span><span class="c2">Â T(a</span><span class="c10 c2">1</span><span class="c2">, .., a</span><span class="c10 c2">n</span><span class="c2">,</span><span class="c10 c2">Â </span><span class="c2">x</span><span class="c10 c2">n+1</span><span class="c2">: a</span><span class="c10 c2">n+1</span><span class="c2">, â¦, x</span><span class="c10 c2">n+k</span><span class="c2">: a</span><span class="c10 c2">n+k</span><span class="c2">),</span><span>Â in which case let </span><span class="c2">i </span><span>be the result of evaluating</span><span class="c2">Â </span><span class="c0 c5">new</span><span class="c2">Â T(a</span><span class="c10 c2">1</span><span class="c2">, .., a</span><span class="c10 c2">n</span><span class="c2">,</span><span class="c10 c2">Â </span><span class="c2">x</span><span class="c10 c2">n+1</span><span class="c2">: a</span><span class="c10 c2">n+1</span><span class="c2">, â¦, x</span><span class="c10 c2">n+k</span><span class="c2">: a</span><span class="c10 c2">n+k</span><span class="c2">) </span><span class="c5">. </span><span>Then:</span></p><ol class="c16" start="1"><li class="c9"><span>If during execution of the program, a constant object expression has already evaluated to an instance </span><span class="c2">j</span><span>Â of class </span><span class="c2">R</span><span>Â with type arguments </span><span class="c2">V</span><span class="c10 c2">i</span><span class="c2">Â 1 &lt;= i &lt;= m,</span><span>Â then:</span></li></ol><ol class="c39" start="1"><li class="c11 c30"><span>For each instance variable </span><span class="c2">f</span><span>Â of </span><span class="c2">i,</span><span>Â let </span><span class="c2">v</span><span class="c10 c2">if</span><span>Â be the value of the field </span><span class="c2">f</span><span>Â in </span><span class="c2">i,</span><span>Â and let </span><span class="c2">v</span><span class="c10 c2">jf</span><span>Â be the value of the field </span><span class="c2">f</span><span>Â in </span><span class="c2">j.</span><span>Â If Â </span><span class="c0">identical(</span><span class="c2">v</span><span class="c10 c2">if</span><span class="c0">Â , </span><span class="c2">v</span><span class="c10 c2">jf</span><span class="c0">)</span><span class="c2">Â </span><span>for all fields </span><span class="c2">f</span><span>Â in </span><span class="c2">i, </span><span>then the value of </span><span class="c2">e </span><span>is </span><span class="c2">j, </span><span>otherwise the value of </span><span class="c2">e</span><span>Â is </span><span class="c2">i.</span></li></ol><ol class="c16" start="2"><li class="c9"><span>Otherwise the value of </span><span class="c2">e</span><span>Â is </span><span class="c2">i.</span></li></ol><p class="c8"><span class="c2"></span></p><p class="c13"><span class="c3">In other words, constant objects are canonicalized. Â In order to determine if an object is actually new, one has to compute it; then it can be compared to any cached instances. If an equivalent object exists in the cache, we throw away the newly created object and use the cached one. Objects are equivalent if they have identical fields and identical type arguments. Since the constructor cannot induce any side effects, the execution of the constructor is unobservable. Â The constructor need only be executed once per call site, at compile-time.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span>The static type of a constant object expression of either the form </span><span class="c0 c5">const</span><span class="c2">Â T.id(a</span><span class="c10 c2">1</span><span class="c2">, .., a</span><span class="c10 c2">n</span><span class="c2">)</span><span>Â or the form </span><span class="c0 c5">const</span><span class="c2">Â T(a</span><span class="c10 c2">1</span><span class="c2">, .., a</span><span class="c10 c2">n</span><span class="c2">)</span><span>Â is</span><span class="c2">Â T.</span><span>Â It is a static warning if the static type of </span><span class="c2">a</span><span class="c10 c2">i</span><span class="c2">, 1 &lt;= i &lt;= n+ k </span><span>may not be assigned to the type of the corresponding formal parameter of the constructor </span><span class="c2">T.id</span><span>Â (respectively </span><span class="c2">T</span><span>).</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error if evaluation of a constant object results in an uncaught exception being thrown.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">To see how such situations might arise, consider the following examples:</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c0 c3 c5">class</span><span class="c0 c3">Â A {</span></p><p class="c13"><span class="c0 c3">Â </span><span class="c0 c3 c5">static final</span><span class="c0 c3">Â x;</span></p><p class="c13"><span class="c0 c3">Â </span><span class="c0 c3 c5">const</span><span class="c0 c3">Â A(</span><span class="c0 c3 c5">var</span><span class="c0 c3">Â p): p = x * 10;</span></p><p class="c13"><span class="c0 c3">}</span></p><p class="c8"><span class="c0 c3"></span></p><p class="c13"><span class="c0 c3 c5">const</span><span class="c0 c3">Â A(âxâ); //compile-time error</span></p><p class="c13"><span class="c0 c3 c5">const</span><span class="c0 c3">Â A(5); // legal</span></p><p class="c8"><span class="c0 c3"></span></p><p class="c13"><span class="c0 c3 c5">class</span><span class="c0 c3">Â IntPair {</span></p><p class="c13"><span class="c0 c3">Â </span><span class="c0 c3 c5">const</span><span class="c0 c3">Â IntPair(this.x, this.y);</span></p><p class="c13"><span class="c0 c3">Â </span><span class="c0 c3 c5">final</span><span class="c0 c3">Â int x;</span></p><p class="c13"><span class="c0 c3">Â </span><span class="c0 c3 c5">final</span><span class="c0 c3">Â int y;</span></p><p class="c13"><span class="c0 c3">Â </span><span class="c0 c3 c5">operator</span><span class="c0 c3">Â *(v) =&gt; new IntPair(x*v, y*v);</span></p><p class="c13"><span class="c0 c3">}</span></p><p class="c8"><span class="c0 c3"></span></p><p class="c13"><span class="c0 c3 c5">const</span><span class="c0 c3">Â A(</span><span class="c0 c3 c5">const</span><span class="c0 c3">Â IntPair(1, 2)); // compile-time error: illegal in a subtler way</span></p><p class="c8"><span class="c0 c3"></span></p><p class="c13"><span class="c3">Due to the rules governing constant constructors, evaluating the constructor A() with the argument </span><span class="c0 c3">âxâ</span><span class="c3">Â or the argument </span><span class="c0 c3 c5">const</span><span class="c0 c3">Â IntPair(1, 2) </span><span class="c3">would cause it to throw an exception, resulting in a compile-time error.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span>Given an instance creation expression of the form </span><span class="c0 c5">const</span><span class="c2">Â </span><span class="c2">q</span><span class="c2">(a</span><span class="c10 c2">1</span><span class="c2">, .., a</span><span class="c10 c2">n</span><span class="c2">)</span><span>Â it is a static warning if </span><span class="c2">q</span><span>Â is the constructor of an Â </span><span class="c7"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.t8nep39l3cq0">abstract class</a></span><span>Â but</span><span>Â </span><span class="c2">q</span><span>Â is not a factory constructor.</span><span>Â  </span></p><p class="c8"><span class="c12 c2"></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.x6lx0jb4kti5"></a><h3 class="c13"><a name="h.w9xbbkh4rog6"></a><span>Spawning an Isolate</span></h3><p class="c8"><span></span></p><p class="c13"><span>Spawning an isolate is accomplished via what is syntactically an ordinary library call, invoking one of the functions </span><span class="c0">spawnUri()</span><span>Â or </span><span class="c0">spawnFunction()</span><span>Â defined in the </span><span class="c0">dart:isolate</span><span>Â library</span><span class="c0">.</span><span>Â However, such calls Â have the Â semantic effect of creating a new isolate with its own memory and thread of control.</span></p><p class="c8"><span></span></p><p class="c13"><span>An isolate&#39;s memory is finite, as is the space available to its thread&#39;s call stack. It is possible for a running isolate to exhaust its memory or stack, resulting in a run-time error that cannot be effectively caught, which will force the isolate to be suspended.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">As discussed </span><span class="c32 c3"><a class="c4" href="#id.l4twf9coi3a3">above</a></span><span class="c3">, the handling of a suspended isolate is the responsibility of the embedder.</span></p><p class="c8"><span></span></p><a href="#" name="id.hu9dfddw6bhy"></a><h3 class="c13"><a name="h.8rkt9qgxx3m"></a><span>Property Extraction</span></h3><p class="c8"><span></span></p><p class="c13"><span>Property extraction allows for a member of an object to be concisely extracted from the object. </span><span>If </span><span class="c2">o</span><span>Â is an object, and if </span><span class="c2">m</span><span>Â is the name of a method member of </span><span class="c2">o</span><span>, then </span><span class="c2">o.m</span><span>Â is defined to be equivalent to:</span></p><ol class="c16" start="1"><li class="c9"><span class="c2">(r</span><span class="c10 c2">1</span><span class="c2">, .., r</span><span class="c10 c2">n</span><span class="c2">, {p</span><span class="c10 c2">1</span><span class="c2">Â : d</span><span class="c10 c2">1</span><span class="c2">, â¦, p</span><span class="c10 c2">k</span><span class="c2">Â : d</span><span class="c10 c2">k</span><span class="c2">}){</span><span class="c0 c2">return</span><span class="c2">Â o.m(r</span><span class="c10 c2">1</span><span class="c2">, .., r</span><span class="c10 c2">n</span><span class="c2">, p</span><span class="c10 c2">1</span><span class="c2">: </span><span class="c2">p</span><span class="c10 c2">1</span><span class="c2">, Â .., p</span><span class="c10 c2">k</span><span class="c2">: </span><span class="c2">p</span><span class="c10 c2">k</span><span class="c2">);}</span><span>Â if </span><span class="c2">m</span><span>Â has required parameters </span><span class="c2">r</span><span class="c10 c2">1</span><span class="c2">, â¦, r</span><span class="c10 c2">n</span><span class="c2">,</span><span>Â and named parameters </span><span class="c2">p</span><span class="c10 c2">1</span><span class="c2">Â .. p</span><span class="c10 c2">k</span><span class="c2">Â </span><span>with defaults</span><span class="c2">Â d</span><span class="c10 c2">1</span><span class="c2">, â¦, d</span><span class="c10 c2">k</span><span class="c2">.</span></li><li class="c9"><span class="c2">(r</span><span class="c10 c2">1</span><span class="c2">, .., r</span><span class="c10 c2">n</span><span class="c2">, [p</span><span class="c10 c2">1</span><span class="c2">Â = d</span><span class="c10 c2">1</span><span class="c2">, â¦, p</span><span class="c10 c2">k</span><span class="c2">Â = d</span><span class="c10 c2">k</span><span class="c2">]){</span><span class="c0 c2 c5">return</span><span class="c2">Â o.m(r</span><span class="c10 c2">1</span><span class="c2">, .., r</span><span class="c10 c2">n</span><span class="c2">, p</span><span class="c10 c2">1</span><span class="c2">, .., p</span><span class="c10 c2">k</span><span class="c2">);}</span><span>Â if </span><span class="c2">m</span><span>Â has required parameters </span><span class="c2">r</span><span class="c10 c2">1</span><span class="c2">, â¦, r</span><span class="c10 c2">n</span><span class="c2">,</span><span>Â and </span><span>optional positional parameters</span><span>Â </span><span class="c2">p</span><span class="c10 c2">1</span><span class="c2">Â .. p</span><span class="c10 c2">k</span><span class="c2">Â </span><span>with defaults</span><span class="c2">Â d</span><span class="c10 c2">1</span><span class="c2">, â¦, d</span><span class="c10 c2">k</span><span class="c2">.</span></li></ol><p class="c8"><span></span></p><p class="c13"><span>Otherwise, if </span><span class="c2">m </span><span>is the name of a getter member of </span><span class="c2">o </span><span>(declared implicitly or explicitly) then </span><span class="c2">o.m</span><span>Â evaluates to the result of invoking the getter.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">Observations:</span></p><ol class="c20" start="1"><li class="c9"><span class="c3">One cannot extract a getter or a setter.</span></li><li class="c9"><span class="c3">One can tell whether one implemented a property via a method or via field/getter, which means that one has to plan ahead as to what construct to use, and that choice is reflected in the interface of the class. </span><span class="c18">Â </span></li></ol><p class="c8"><span></span></p><a href="#" name="id.o7xycf4osas8"></a><h3 class="c13"><a name="h.y92yhnm0wxy7"></a><span>Function Invocation</span></h3><p class="c13"><span>Function invocation occurs in the following cases: when a </span><span class="c7"><a class="c4" href="#kix.5k4ge149hokr">function expression is invoked,</a></span><span>Â when a </span><span class="c7"><a class="c4" href="#kix.uf8pv9cr3nu2">method</a></span><span>, </span><span class="c6"><a class="c4" href="#id.lharm2td3qkb">getter</a></span><span>Â or </span><span class="c6"><a class="c4" href="#id.lc2fh7iv9xwt">setter</a></span><span>Â is invoked or when a constructor is invoked (either via </span><span class="c7"><a class="c4" href="#id.hvkbnlui8uvu">instance creation</a></span><span>Â , </span><span class="c7"><a class="c4" href="#id.joo06zfmou7z">constructor redirection</a></span><span>Â or super initialization). The various kinds of function invocation differ as to how the function to be invoked, </span><span class="c2">f,</span><span>Â  is determined as well as whether </span><span class="c0 c5">this</span><span>Â is bound. Once </span><span class="c2">f</span><span>Â has been determined, the formal parameters of </span><span class="c2">f </span><span>are bound to the corresponding actual arguments. The body of </span><span class="c2">f</span><span>Â is then executed with the aforementioned bindings. Execution of the body terminates when the first of the following occurs;</span></p><ol class="c16" start="1"><li class="c9"><span>An uncaught exception is thrown </span></li><li class="c9"><span>A return statement immediately nested in the body of </span><span class="c2">f </span><span>is executed.</span></li><li class="c9"><span>The last statement of the body completes execution. </span></li></ol><p class="c8"><span class="c2"><br></span></p><a href="#" name="id.ildrdt8gs2av"></a><h4 class="c13"><a name="h.3tizygdkqnej"></a><span>Actual Argument List Evaluation</span></h4><p class="c13"><span>Function invocation involve evaluation of the list of actual arguments to the function and binding of the results to the functionâs formal parameters.</span></p><p class="c8"><span></span></p><a href="#" name="kix.xl2ewwstkqba"></a><p class="c13"><span class="c2 c5">arguments:</span><span class="c2"><br> Â  Â  Â &#39;(&#39; </span><span class="c7 c2"><a class="c4" href="#id.yhq3xin4zid1">argumentList</a></span><span class="c2">? &#39;)&#39;<br> Â  Â ;<br><br></span><a href="#" name="kix.ych6gak590r1"></a><span class="c2 c5">argumentList:</span><span class="c2"><br> Â  Â  Â </span><span class="c7 c2"><a class="c4" href="#id.7mx0z515yx51">namedArgument</a></span><span class="c2">Â (&#39;,&#39; </span><span class="c7 c2"><a class="c4" href="#id.7mx0z515yx51">namedArgument</a></span><span class="c2">)*<br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.8a2tqk43n0f2">expressionList</a></span><span class="c2">Â (&#39;,&#39; </span><span class="c7 c2"><a class="c4" href="#id.7mx0z515yx51">namedArgument</a></span><span class="c2">)*<br> Â  Â ;<br><br></span><a href="#" name="kix.7a3j6nl17wrf"></a><span class="c2 c5">namedArgument:</span><span class="c2"><br> Â  Â  Â label </span><span class="c6 c2"><a class="c4" href="#id.1u3vxuwrz6py">expression</a></span><span class="c2"><br> Â  Â ;<br></span></p><p class="c8"><span></span></p><p class="c13"><span>Evaluation of an actual argument list of the form (</span><span class="c2">a</span><span class="c1">1</span><span class="c2">Â .. a</span><span class="c1">m</span><span class="c2">, q</span><span class="c1">1</span><span class="c2">: a</span><span class="c1">m+1</span><span class="c2">, â¦, q</span><span class="c1">l</span><span class="c2">: a</span><span class="c1">m+l</span><span>) proceeds as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>The arguments </span><span class="c2">a</span><span class="c1">1</span><span class="c2">, â¦, a</span><span class="c1">m+l</span><span class="c2">Â </span><span>are evaluated in the order they appear in the program, yielding objects </span><span class="c2">o</span><span class="c1">1</span><span class="c2">Â .. o</span><span class="c1">m+l</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">Simply stated, an argument list consisting of </span><span class="c3 c2">m</span><span class="c3">Â positional arguments and </span><span class="c3 c2">l</span><span class="c3">Â named arguments is evaluated from left to right. </span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.p7pe6x2fs02j"></a><h4 class="c13"><a name="h.edxvczd1cw0f"></a><span>Binding Actuals to Formals</span></h4><p class="c8"><span></span></p><p class="c13"><span>Let </span><span class="c2">f</span><span>Â be the function, let </span><span class="c2">p</span><span class="c1">1</span><span class="c2">, â¦, p</span><span class="c1">n</span><span>Â be the positional parameters of </span><span class="c2">f</span><span>Â and let </span><span class="c2">p</span><span class="c1">n+1</span><span class="c2">, â¦, p</span><span class="c1">n+k</span><span>Â be the optional parameters declared by </span><span class="c2">f.</span></p><p class="c8"><span></span></p><p class="c13"><span>An evaluated actual argument list </span><span class="c2">(o</span><span class="c1">1</span><span class="c2">, â¦, o</span><span class="c1">m+l</span><span class="c2">)</span><span>Â derived from an actual argument list of the form (</span><span class="c2">a</span><span class="c1">1</span><span class="c2">Â .. a</span><span class="c1">m</span><span class="c2">, q</span><span class="c1">1</span><span class="c2">: a</span><span class="c1">m+1</span><span class="c2">, â¦, q</span><span class="c1">l</span><span class="c2">: a</span><span class="c1">m+l</span><span>) is bound to the formal parameters of </span><span class="c2">f</span><span>Â as follows:</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span class="c3">Again, we have an argument list consisting of </span><span class="c3 c2">m</span><span class="c3">Â positional arguments and </span><span class="c3 c2">l </span><span class="c3">named arguments. We have a function with </span><span class="c3 c2">h</span><span class="c3">Â required parameters and </span><span class="c3 c2">k</span><span class="c3">Â optional parameters. The number of positional arguments must be at least as large as the number of required parameters</span><span class="c3">, and no larger than the number of positional parameters</span><span class="c3">. All named arguments must have a corresponding named parameter. </span><span class="c3">You may not provide a given named argument more than once.</span><span class="c3">Â If an optional parameter has no corresponding argument, it gets its default value. In checked mode, all arguments must belong to subtypes of the type of their corresponding formal.</span></p><p class="c8"><span></span></p><p class="c13"><span>If Â </span><span class="c2">m &lt; </span><span class="c2">h</span><span class="c2">Â </span><span class="c2">or Â m &gt; n</span><span class="c2">, </span><span>a run-time error occurs. Furthermore, each </span><span class="c2">q</span><span class="c1">i</span><span class="c2">, 1 &lt;= i &lt;= l,</span><span>Â  must </span><span>have a corresponding named parameter in</span><span>Â the set {</span><span class="c2">p</span><span class="c1">n+1</span><span class="c2">, â¦, p</span><span class="c1">n+k</span><span>}</span><span>Â or a </span><span>run time error</span><span>Â occurs. Then </span><span class="c2">p</span><span class="c1">i</span><span>Â is bound to the value of </span><span class="c2">o</span><span class="c1">i</span><span>, </span><span class="c2">1 &lt;= i &lt;= m,</span><span>Â and</span><span class="c2">Â q</span><span class="c1">j</span><span>Â is bound to the value of </span><span class="c2">o</span><span class="c1">m+j</span><span>, </span><span class="c2">1 &lt;= j &lt;= l</span><span>. All remaining formal parameters of </span><span class="c2">f</span><span>Â are bound to their default values. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">All of these remaining parameters are necessarily optional and thus have default values.</span></p><p class="c13"><span>If </span><span class="c2">l &gt; 0</span><span>, then it is necessarily the case that </span><span class="c2">n = h</span><span>, because a method cannot have both optional positional parameters and named parameters.</span></p><p class="c8"><span></span></p><p class="c13"><span>In checked mode, it is a dynamic type error if </span><span class="c2">o</span><span class="c1">i</span><span>Â </span><span>is not </span><span class="c0 c5">null</span><span>Â and the </span><span class="c7"><a class="c4" href="#id.93yudg3nk9o1">actual type</a></span><span>Â of </span><span class="c2">p</span><span class="c1">i</span><span>Â is not a supertype of the type of </span><span class="c2">o</span><span class="c1">i</span><span class="c2">, 1 &lt;= i &lt;= m</span><span>. It is a dynamic type error if, in checked mode, </span><span class="c2">o</span><span class="c1">m+j</span><span>Â </span><span>is not </span><span class="c0 c5">null</span><span>Â and the </span><span class="c7"><a class="c4" href="#id.93yudg3nk9o1">actual type</a></span><span>Â of </span><span class="c2">q</span><span class="c1">j</span><span>Â is not a supertype of the type of </span><span class="c2">o</span><span class="c1">m+j</span><span>, </span><span class="c2">1 &lt;= j &lt;= l</span><span>. </span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error if </span><span class="c2">q</span><span class="c1">i</span><span class="c2">Â = q</span><span class="c1">j</span><span class="c2">Â </span><span>for any </span><span class="c2">i != j.</span></p><p class="c8"><span></span></p><p class="c13"><span>Let </span><span class="c2">T</span><span class="c1">i</span><span>Â be the static type of </span><span class="c2">a</span><span class="c1">i</span><span>, let </span><span class="c2">S</span><span class="c1">i</span><span>Â be the type of </span><span class="c2">p</span><span class="c1">i</span><span>, </span><span class="c2">1 &lt;= i &lt;= n+k</span><span>Â and let </span><span class="c2">S</span><span class="c1">q</span><span>Â be the type of the named parameter </span><span class="c2">q</span><span>Â of </span><span class="c2">f</span><span>. Â It is a static warning if </span><span class="c2">T</span><span class="c1">j</span><span>Â may not be assigned to </span><span class="c2">S</span><span class="c1">j</span><span>, </span><span class="c2">1 &lt;= j &lt;= m</span><span>. Â It is a static warning if </span><span class="c2">m &lt; h</span><span>Â or if </span><span class="c2">m &gt; n</span><span>. Furthermore, each </span><span class="c2">q</span><span class="c1">i</span><span class="c2">, 1 &lt;= i &lt;= l,</span><span>Â  must </span><span>have a corresponding named parameter in</span><span>Â the set {</span><span class="c2">p</span><span class="c1">n+1</span><span class="c2">, â¦, p</span><span class="c1">n+k</span><span>}</span><span>Â  or a static warning occurs. Â It is a static warning if </span><span class="c2">T</span><span class="c1">m+j</span><span>Â  may not be assigned to </span><span class="c2">S</span><span class="c1">r</span><span class="c2">,</span><span>Â where </span><span class="c2">r = q</span><span class="c1">j</span><span class="c2">, 1 &lt;= j &lt;= l.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.umipgzep5jdf"></a><h4 class="c13"><a name="h.o9n2pv4hceh1"></a><span>Unqualified Invocation</span></h4><p class="c8"><span></span></p><p class="c13"><span>An unqualified function invocation </span><span class="c2">i</span><span>Â has the form </span><span class="c2">id(a</span><span class="c1">1</span><span class="c2">, â¦, a</span><span class="c1">n</span><span class="c2">, </span><span class="c2">x</span><span class="c1">n+1</span><span class="c2">: a</span><span class="c1">n+1</span><span class="c2">, â¦, x</span><span class="c1">n+k</span><span class="c2">: a</span><span class="c1">n+k</span><span class="c2">),</span><span>Â where </span><span class="c2">id </span><span>is an identifier.</span><span class="c2">Â </span><span>Â </span></p><p class="c8"><span></span></p><p class="c13"><span class="c18">What about library prefixes?</span></p><p class="c8"><span class="c18"></span></p><p class="c13"><span>If there exists a lexically visible declaration named </span><span class="c2">id,</span><span>Â let </span><span class="c2">f</span><span class="c1">id</span><span>Â be the innermost such declaration. Then:</span></p><ol class="c16" start="1"><li class="c9"><span>Â If </span><span class="c2">f</span><span class="c1">id</span><span>Â is a local function, a library function, a library or static getter or a variable then </span><span class="c2">i</span><span>Â is interpreted as a </span><span class="c7"><a class="c4" href="#kix.5k4ge149hokr">function expression invocation</a></span><span class="c2">.</span></li><li class="c9"><span>Otherwise, If </span><span class="c2">f</span><span class="c1">id</span><span>Â is a static method of the enclosing class </span><span class="c2">C, i </span><span>is equivalent to the static method invocation </span><span class="c2">C.id(a</span><span class="c1">1</span><span class="c2">, â¦, a</span><span class="c1">n</span><span class="c2">, x</span><span class="c1">n+1</span><span class="c2">: a</span><span class="c1">n+1</span><span class="c2">, â¦, x</span><span class="c1">n+k</span><span class="c2">: a</span><span class="c1">n+k</span><span class="c2">).</span></li></ol><p class="c8"><span></span></p><p class="c13"><span>Otherwise, </span><span class="c2">i </span><span>is equivalent to the ordinary method invocation </span><span class="c2">this.id(a</span><span class="c1">1</span><span class="c2">, â¦, a</span><span class="c1">n</span><span class="c2">, x</span><span class="c1">n+1</span><span class="c2">: </span><span class="c2">a</span><span class="c1">n+1</span><span class="c2">, â¦, x</span><span class="c1">n+k</span><span class="c2">: a</span><span class="c1">n+k</span><span class="c2">). </span></p><p class="c8"><span class="c2"></span></p><a href="#" name="kix.5k4ge149hokr"></a><h4 class="c13"><a name="h.5l8tud6ne77w"></a><span>Function Expression Invocation</span></h4><p class="c8"><span></span></p><p class="c13"><span>A function expression invocation </span><span class="c2">i</span><span>Â has the form </span><span class="c2">e</span><span class="c1">f</span><span class="c2">(a</span><span class="c1">1</span><span class="c2">, â¦, a</span><span class="c1">n</span><span class="c2">, x</span><span class="c1">n+1</span><span class="c2">: a</span><span class="c1">n+1</span><span class="c2">, â¦, x</span><span class="c1">n+k</span><span class="c2">: a</span><span class="c1">n+k</span><span class="c2">),</span><span>Â where </span><span class="c2">e</span><span class="c1">f</span><span class="c2">Â </span><span>is an expression. If </span><span class="c2">e</span><span class="c1">f </span><span>is an identifier </span><span class="c2">id,</span><span>Â then </span><span class="c2">id</span><span>Â must necessarily denote a local function, a library function, a library or static getter or a variable as described </span><span class="c7"><a class="c4" href="#id.umipgzep5jdf">above</a></span><span>, or </span><span class="c2">i</span><span>Â is not considered a function expression invocation. If </span><span class="c2">e</span><span class="c1">f </span><span>is a </span><span class="c6"><a class="c4" href="#id.hu9dfddw6bhy">property extraction</a></span><span>Â expression, then </span><span class="c2">i</span><span>Â is not a function expression invocation and is instead recognized as an </span><span class="c7"><a class="c4" href="#kix.dveayw720vs7">ordinary method invocation</a></span><span>. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c0 c3">a.b(x)</span><span class="c3">Â is parsed as a method invocation of method m() on object </span><span class="c0 c3">a</span><span class="c3">, not as an invocation of getter </span><span class="c0 c3">b</span><span class="c3">Â on a followed by a function call </span><span class="c0 c3">(a.b)(x)</span><span class="c3">. Â If a method or getter </span><span class="c0 c3">b</span><span class="c3">Â exists, the two will be equivalent. However, if </span><span class="c0 c3">b</span><span class="c3">Â is not defined on </span><span class="c0 c3">a</span><span class="c3">, the resulting invocation of </span><span class="c0 c3">noSuchMethod()</span><span class="c3">Â would differ. Â The </span><span class="c0 c3">InvocationMirror</span><span class="c3">Â passed to </span><span class="c0 c3">noSuchMethod()</span><span class="c3">Â would describe a call to a method </span><span class="c0 c3">b</span><span class="c3">Â with argument </span><span class="c0 c3">x</span><span class="c3">Â in the former case, and a call to a getter </span><span class="c0 c3">b</span><span class="c3">Â (with no arguments) in the latter.</span></p><p class="c8"><span></span></p><p class="c13"><span>Otherwise:</span></p><p class="c8"><span></span></p><p class="c13"><span>A function expression invocation </span><span class="c2">i</span><span>Â of the form Â </span><span class="c2">e</span><span class="c10 c2">f</span><span class="c2">(a</span><span class="c10 c2">1</span><span class="c2">, â¦, a</span><span class="c10 c2">n</span><span class="c2">, x</span><span class="c10 c2">n+1</span><span class="c2">: a</span><span class="c10 c2">n+1</span><span class="c2">, â¦, x</span><span class="c10 c2">n+k</span><span class="c2">: a</span><span class="c10 c2">n+k</span><span class="c2">)</span><span>Â is equivalent to the ordinary method invocation </span><span class="c2">e</span><span class="c10 c2">f</span><span class="c2">.call(a</span><span class="c10 c2">1</span><span class="c2">, â¦, a</span><span class="c10 c2">n</span><span class="c2">, x</span><span class="c10 c2">n+1</span><span class="c2">: a</span><span class="c10 c2">n+1</span><span class="c2">, â¦, x</span><span class="c10 c2">n+k</span><span class="c2">: a</span><span class="c10 c2">n+k</span><span class="c2">)</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">The implication of this definition, and the other definitions involving the method </span><span class="c0 c3">call()</span><span class="c3">, is that user defined types can be used as function values provided iff they define a </span><span class="c0 c3">call()</span><span class="c3">Â method. The method </span><span class="c0 c3">call()</span><span class="c3">Â is special in this regard. The signature of the </span><span class="c0 c3">call()</span><span class="c3">Â method determines the appropriate signature used when using the object via the built-in invocation syntax.</span></p><p class="c8"><span class="c3"></span></p><p class="c8"><span></span></p><p class="c13"><span>It is a static type warning if the static type </span><span class="c2">F</span><span>Â of </span><span class="c2">e</span><span class="c1">f</span><span>Â may not be assigned to a function type. Â If </span><span class="c2">F</span><span>Â is not a function type, the static type of </span><span class="c2">i</span><span>Â is </span><span class="c0 c5">dynamic</span><span>. Otherwise the static type of </span><span class="c2">i</span><span>Â is the declared return type of </span><span class="c2">F. </span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c8"><span class="c2"></span></p><a href="#" name="kix.1bfikjk2e9bd"></a><h3 class="c13"><a name="h.mwjqhj0r8mr"></a><span>Method Invocation</span></h3><p class="c13"><span>Method invocation can take several forms as specified below. </span></p><a href="#" name="kix.dveayw720vs7"></a><h4 class="c13"><a name="h.bq7ggoshcofg"></a><span>Ordinary Invocation</span></h4><p class="c13"><span>An ordinary method invocation </span><span class="c2">i</span><span>Â has the form </span><span class="c2">o.m(a</span><span class="c1">1</span><span class="c2">, â¦, a</span><span class="c1">n</span><span class="c2">, x</span><span class="c1">n+1</span><span class="c2">: a</span><span class="c1">n+1</span><span class="c2">, â¦, x</span><span class="c1">n+k</span><span class="c2">: a</span><span class="c1">n+k</span><span class="c2">). </span><span>Â Method invocation involves method lookup, defined next.</span></p><p class="c8"><span></span></p><p class="c13"><span>The result of</span><span class="c2">Â looking up a method m in object o with respect to library L</span><span>Â is the result of looking up method </span><span class="c2">m</span><span>Â in class </span><span class="c2">C</span><span>Â with respect to library </span><span class="c2">L,</span><span>Â where </span><span class="c2">C</span><span>Â is the class of </span><span class="c2">o.</span></p><p class="c8"><span></span></p><p class="c13"><span>The result of </span><span class="c2">looking up method m in class C with respect to library L</span><span>Â is:</span></p><p class="c8"><span></span></p><ol class="c16" start="1"><li class="c9"><span>If </span><span class="c2">C</span><span>Â declares an instance method named </span><span class="c2">m</span><span>Â that is accessible to </span><span class="c2">L,</span><span>Â  then that method is the result of the lookup. Otherwise, if </span><span class="c2">C</span><span>Â has a superclass </span><span class="c2">S,</span><span>Â then the result of the lookup is the result of looking up method </span><span class="c2">m</span><span>Â in </span><span class="c2">S </span><span>with respect to </span><span class="c2">L. </span><span>Otherwise, we say that the lookup has failed.</span></li></ol><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span>Evaluation of an ordinary method invocation </span><span class="c2">i</span><span>Â of the form </span><span class="c2">o.m(a</span><span class="c1">1</span><span class="c2">, â¦, a</span><span class="c1">n</span><span class="c2">, x</span><span class="c1">n+1</span><span class="c2">: a</span><span class="c1">n+1</span><span class="c2">, â¦, x</span><span class="c1">n+k</span><span class="c2">: a</span><span class="c1">n+k</span><span class="c2">)</span><span>Â proceeds as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>First, the expression </span><span class="c2">o</span><span>Â is evaluated </span><span>to a value </span><span class="c2">v</span><span class="c1">o</span><span class="c2">.</span><span>Â Next, the argument list </span><span class="c2">(a</span><span class="c1">1</span><span class="c2">, â¦, a</span><span class="c1">n</span><span class="c2">, x</span><span class="c1">n+1</span><span class="c2">: a</span><span class="c1">n+1</span><span class="c2">, â¦, x</span><span class="c1">n+k</span><span class="c2">: a</span><span class="c1">n+k</span><span class="c2">)</span><span>Â is evaluated yielding actual objects </span><span class="c2">o</span><span class="c1">1</span><span class="c2">, â¦, o</span><span class="c1">n+k</span><span>. Let </span><span class="c2">f </span><span>be the result of looking up method </span><span class="c2">Â m</span><span>Â in </span><span class="c2">v</span><span class="c1">o</span><span>Â  with respect to the current library </span><span class="c2">L.</span><span>Â If the method lookup succeeded,</span><span class="c2">Â </span><span>the body of </span><span class="c2">f</span><span>Â is executed with respect to the bindings that resulted from the evaluation of the argument list, and with </span><span class="c0 c5">this</span><span>Â bound to </span><span class="c2">v</span><span class="c1">o</span><span class="c2">. </span><span>The value of</span><span class="c2">Â i </span><span>is the value returned after </span><span class="c2">f</span><span>Â is executed.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>If the method lookup has failed, then let </span><span class="c2">g </span><span>be the result of </span><span class="c6"><a class="c4" href="#id.pu3ax3y80hzh">looking up getter</a></span><span>Â </span><span class="c2">m</span><span>Â in </span><span class="c2">v</span><span class="c10 c2">o</span><span>Â with respect to </span><span class="c2">L.</span><span>Â If the getter lookup succeeded, let </span><span class="c2">v</span><span class="c10 c2">g</span><span>Â be the value of the getter invocation </span><span class="c2">o.m.</span></p><p class="c13"><span>Then the value of</span><span class="c2">Â i </span><span>is the value of the method invocation </span><span class="c2">v</span><span class="c10 c2">g</span><span>.</span><span class="c0 c5">call</span><span class="c0">(</span><span class="c2">a</span><span class="c1">1</span><span class="c2">, â¦, a</span><span class="c1">n</span><span class="c2">, x</span><span class="c1">n+1</span><span class="c2">: a</span><span class="c1">n+1</span><span class="c2">, â¦, x</span><span class="c1">n+k</span><span class="c2">: a</span><span class="c1">n+k</span><span class="c0">)</span><span>. </span></p><p class="c8"><span></span></p><p class="c13"><span>If getter lookup has also failed, then a new instance </span><span class="c2">im </span><span>Â of the predefined class Â </span><span class="c0">InvocationMirror</span><span>Â  is created </span><span>by calling its</span><span>Â </span><span>factory constructor</span><span>Â with arguments </span><span class="c0">âmâ</span><span>, Â </span><span class="c0 c5">this</span><span class="c0">,</span><span>Â </span><span class="c0">[</span><span class="c2">o</span><span class="c1">1</span><span class="c2">, â¦, o</span><span class="c1">n</span><span class="c0">] </span><span>and</span><span class="c0">Â {</span><span class="c2">x</span><span class="c1">n+1</span><span class="c0 c2">:</span><span class="c2">o</span><span class="c1">n+1</span><span class="c2">, â¦, x</span><span class="c1">n+k</span><span class="c2">Â :</span><span class="c1">Â </span><span class="c2">o</span><span class="c1">n+k</span><span class="c0">}. Then</span><span>Â </span><span>the method </span><span class="c0">noSuchMethod() </span><span>is looked up in </span><span class="c0 c2">o</span><span>Â and invoked with argument </span><span class="c2">im</span><span class="c0">,</span><span>Â and the result of this invocation is the result of evaluating </span><span class="c2">i</span><span>.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">Notice that the wording carefully avoids re-evaluating the receiver </span><span class="c3 c2">o</span><span class="c3">Â and the arguments </span><span class="c3 c2">a</span><span class="c1 c3">i</span><span class="c3">. </span></p><p class="c8"><span class="c18"></span></p><p class="c13"><span>Let </span><span class="c2">T</span><span>Â be the Â static type of </span><span class="c2">o.</span><span>Â It is a static type warning if </span><span class="c2">T</span><span>Â does not have an </span><span class="c7"><a class="c4" href="#id.zeletzevxf8t">accessible</a></span><span>Â  instance member named </span><span class="c2">m.</span><span class="c18">Â </span><span>If </span><span class="c2">T.m</span><span>Â exists, it is a static warning if the type </span><span class="c2">F</span><span>Â of </span><span class="c2">T.m</span><span>Â may not be assigned to a function type</span><span class="c2">.</span><span>Â If </span><span class="c2">T.m</span><span>Â does not exist, or if </span><span class="c2">F</span><span>Â is not a function type, the static type of </span><span class="c2">i</span><span>Â is </span><span class="c0 c5">dynamic</span><span>. Otherwise the static type of </span><span class="c2">i</span><span>Â is the declared return type of </span><span class="c2">F. </span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.as8nompbkrrt"></a><h4 class="c13"><a name="h.30hsq2v14fk2"></a><span>Cascaded Invocations</span></h4><p class="c8"><span class="c3"></span></p><p class="c13"><span>A </span><span class="c2">cascaded method invocation</span><span>Â has the form </span><span class="c2">e</span><span class="c2">..suffix </span><span>where </span><span class="c2">suffix</span><span>Â is a sequence of operator, method, getter or setter invocations.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="kix.qgl5b37992c5"></a><p class="c13"><span class="c2 c5">cascadeSection:<br></span><span class="c2">Â  Â  </span><span class="c2">Â &#39;..&#39; Â (cascadeSelector </span><span class="c7 c2"><a class="c4" href="#kix.xl2ewwstkqba">arguments</a></span><span class="c2">*)</span><span class="c2">(assignableSelector </span><span class="c7 c2"><a class="c4" href="#kix.xl2ewwstkqba">arguments</a></span><span class="c2">*)* (</span><span class="c6 c2"><a class="c4" href="#id.gs625gfxuh9m">assignmentOperator</a></span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.k68gukuq6cj9">expression</a></span><span class="c6 c2"><a class="c4" href="#id.k68gukuq6cj9">WithoutCascade</a></span><span class="c2">)?</span><span class="c2"><br></span><span class="c2">Â  Â  ;</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span class="c2 c5">cascadeSelector:<br></span><span class="c2">Â  Â  &#39;[ &#39; expression &#39;] &#39;</span></p><p class="c13"><span class="c2">Â  Â | </span><span class="c2">identifier</span></p><p class="c13"><span class="c2"><br></span><span class="c2">Â  Â  ;</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span>A cascaded method invocation expression of the form </span><span class="c2">e..suffix</span><span>Â is equivalent to the expression </span><span class="c0 c2">(t){t.suffix; </span><span class="c0 c2 c5">return</span><span class="c0 c2">Â t;}(e).</span></p><p class="c8"><span class="c18"></span></p><p class="c8"><span class="c18"></span></p><p class="c8"><span class="c18"></span></p><a href="#" name="id.fe2sq6esvhvp"></a><h4 class="c13"><a name="h.jwevbcchdb5f"></a><span>Static Invocation</span></h4><p class="c8"><span></span></p><p class="c13"><span>A static method invocation </span><span class="c2">i</span><span>Â has the form </span><span class="c2">C.m(a</span><span class="c1">1</span><span class="c2">, â¦, a</span><span class="c1">n</span><span class="c2">, x</span><span class="c1">n+1</span><span class="c2">: a</span><span class="c1">n+1</span><span class="c2">, â¦, x</span><span class="c1">n+k</span><span class="c2">: a</span><span class="c1">n+k</span><span class="c2">). </span><span>Â It is a static warning if </span><span class="c2">C</span><span>Â does not denote a class in the current scope. It is a static warning if </span><span class="c2">C</span><span>Â does not declare a </span><span>static method or getter </span><span class="c2">m</span><span class="c2">.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span class="c12 c2">Note that the absence of C or of C.m is statically detectable. Nevertheless, we choose not to define this situation as an error. Â The goal is to allow coding to proceed in the order that suits the developer rather than eagerly insisting on consistency. The warnings are given statically at compile-time to help developers catch errors. However, developers need not correct these problems immediately in order to make progress.</span></p><p class="c8"><span class="c12"></span></p><p class="c13"><span class="c3">As of this writing, the above situations are treated as compile time errors by the implementations. This will change over time.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">Note the requirement that C </span><span class="c3 c5">declare</span><span class="c3">Â the method. This means that static methods declared in superclasses of </span><span class="c3 c2">C</span><span class="c3">Â cannot be invoked via </span><span class="c3 c2">C.</span></p><p class="c8"><span></span></p><p class="c13"><span>Evaluation of </span><span class="c2">i</span><span>Â proceeds as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>If </span><span class="c2">C</span><span>Â does not denote a class in the current scope, or if </span><span class="c2">C</span><span>Â does not declare a </span><span>static method or getter </span><span class="c2">m</span><span class="c2">Â </span><span>Â a </span><span class="c0">NoSuchMethodError</span><span>Â is thrown. Otherwise, evaluation proceeds as follows:</span></p><p class="c8"><span></span></p><ol class="c16" start="1"><li class="c9"><span>I</span><span>f the member </span><span class="c2">m</span><span>Â declared by </span><span class="c2">C</span><span>Â is a getter, then </span><span class="c2">i</span><span>Â is equivalent to the expression </span><span class="c2">C.m.call(a</span><span class="c10 c2">1</span><span class="c2">, â¦, a</span><span class="c10 c2">n</span><span class="c2">, x</span><span class="c10 c2">n+1</span><span class="c2">: a</span><span class="c10 c2">n+1</span><span class="c2">, â¦, x</span><span class="c10 c2">n+k</span><span class="c2">: a</span><span class="c10 c2">n+k</span><span class="c2">)</span><span>.</span></li><li class="c9"><span>Otherwise, let </span><span class="c2">f</span><span>Â be the method </span><span class="c2">m</span><span>Â declared in class </span><span class="c2">C. </span><span>Next, the argument list </span><span class="c2">(a</span><span class="c1">1</span><span class="c2">, â¦, a</span><span class="c1">n</span><span class="c2">, x</span><span class="c1">n+1</span><span class="c2">: a</span><span class="c1">n+1</span><span class="c2">, â¦, x</span><span class="c1">n+k</span><span class="c2">: a</span><span class="c1">n+k</span><span class="c2">)</span><span>Â is evaluated. The body of </span><span class="c2">f</span><span>Â is then executed with respect to the bindings that resulted from the evaluation of the argument list. The value of</span><span class="c2">Â i </span><span>is the value returned after the body of </span><span class="c2">f</span><span>Â is executed.</span></li></ol><p class="c8"><span class="c2"></span></p><p class="c13"><span>It is a static type warning if the type </span><span class="c2">F</span><span>Â of </span><span class="c2">C.m</span><span>Â may not be assigned to a function type. Â If </span><span class="c2">F</span><span>Â is not a function type, or if </span><span class="c2">C.m</span><span>Â does not exist, the static type of </span><span class="c2">i</span><span>Â is </span><span class="c0 c5">dynamic</span><span>.</span><span>Â Otherwise the static type of </span><span class="c2">i</span><span>Â is the declared return type of </span><span class="c2">F. </span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.mmuk7ayxh6r9"></a><h4 class="c13"><a name="h.x8qjjxmvmrg9"></a><span>Super Invocation</span></h4><p class="c8"><span></span></p><p class="c13"><span>A super method invocation </span><span class="c2">i </span><span>has the form </span><span class="c0 c2 c5">super</span><span class="c2">.m(a</span><span class="c1">1</span><span class="c2">, â¦, a</span><span class="c1">n</span><span class="c2">, x</span><span class="c1">n+1</span><span class="c2">: a</span><span class="c1">n+1</span><span class="c2">, â¦, x</span><span class="c1">n+k</span><span class="c2">: a</span><span class="c1">n+k</span><span class="c2">). </span><span>Evaluation of </span><span class="c2">i</span><span>Â proceeds as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>First, the argument list </span><span class="c2">(a</span><span class="c1">1</span><span class="c2">, â¦, a</span><span class="c1">n</span><span class="c2">, x</span><span class="c1">n+1</span><span class="c2">:</span><span class="c2">Â a</span><span class="c1">n+1</span><span class="c2">, â¦, x</span><span class="c1">n+k</span><span class="c2">: a</span><span class="c1">n+k</span><span class="c2">)</span><span>Â is evaluated yielding actual objects </span><span class="c2">o</span><span class="c1">1</span><span class="c2">, â¦, o</span><span class="c1">n+k</span><span class="c2">.</span><span>Â Let </span><span class="c2">S</span><span>Â be the superclass of the immediately enclosing class </span><span>and let </span><span class="c2">f </span><span>be the result of </span><span class="c6"><a class="c4" href="#kix.dveayw720vs7">looking up method</a></span><span>Â </span><span class="c2">m</span><span>Â in </span><span class="c2">S</span><span>Â with respect to the current library </span><span class="c2">L.</span><span>Â If the method lookup succeeded,</span><span class="c2">Â </span><span>the body of </span><span class="c2">f</span><span>Â is executed with respect to the bindings that resulted from the evaluation of the argument list, and with </span><span class="c0 c5">this</span><span>Â bound to the current value of </span><span class="c0 c5">this</span><span>. The value of</span><span class="c2">Â i </span><span>is the value returned after </span><span class="c2">f</span><span>Â is executed.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>If the method lookup has failed, then let </span><span class="c2">g </span><span>be the result of </span><span class="c6"><a class="c4" href="#id.pu3ax3y80hzh">looking up getter</a></span><span>Â </span><span class="c2">m</span><span>Â in </span><span class="c2">S</span><span>Â with respect to </span><span class="c2">L.</span><span>Â If the getter lookup succeeded, let </span><span class="c2">v</span><span class="c10 c2">g</span><span>Â be the value of the getter invocation </span><span class="c5">super</span><span class="c2">.m. </span><span>Then the value of</span><span class="c2">Â i </span><span>is the value of the method invocation </span><span class="c2">v</span><span class="c10 c2">g</span><span>.</span><span class="c0 c5">call</span><span class="c0">(</span><span class="c2">a</span><span class="c1">1</span><span class="c2">, â¦, a</span><span class="c1">n</span><span class="c2">, x</span><span class="c1">n+1</span><span class="c2">: a</span><span class="c1">n+1</span><span class="c2">, â¦, x</span><span class="c1">n+k</span><span class="c2">: a</span><span class="c1">n+k</span><span class="c0">)</span><span>.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>If the getter lookup has also failed, Â then a new instance </span><span class="c2">im </span><span>Â of the predefined class Â </span><span class="c0">InvocationMirror</span><span>Â  is created Â </span><span>by </span><span>calling</span><span>Â its factory</span><span>Â constructor with arguments </span><span class="c0">â</span><span class="c0">m</span><span class="c0">â</span><span>, Â </span><span class="c0 c5">this</span><span class="c0">,</span><span>Â </span><span class="c0">[</span><span class="c2">e</span><span class="c1">1</span><span class="c2">, â¦, e</span><span class="c1">n</span><span class="c0">] </span><span>and</span><span class="c0">Â {</span><span class="c2">x</span><span class="c1">n+1</span><span class="c0 c2">:</span><span class="c2">e</span><span class="c1">n+1</span><span class="c2">, â¦, x</span><span class="c1">n+k</span><span class="c2">Â :</span><span class="c1">Â </span><span class="c2">e</span><span class="c1">n+k</span><span class="c0">}.</span><span>Â Then</span><span>Â the method </span><span class="c0">noSuchMethod() </span><span>is looked up in </span><span class="c0 c2">S</span><span>Â and invoked with argument </span><span class="c2">im</span><span class="c0">,</span><span>Â and the result of this invocation is the result of evaluating </span><span class="c2">i</span><span>.</span></p><p class="c8"><span class="c18"></span></p><p class="c13"><span>It is a compile-time error if a super method invocation occurs in a top-level function or variable initializer, in an instance variable initializer or initializer list, in class </span><span class="c0">Object,</span><span>Â in a factory constructor, </span><span>or in a static method or variable initializer.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>It is a static type warning if </span><span class="c2">S</span><span>Â does not have an </span><span class="c7"><a class="c4" href="#id.zeletzevxf8t">accessible</a></span><span>Â instance member named </span><span class="c2">m. </span><span>If </span><span class="c2">S.m</span><span>Â exists, it is a static warning if </span><span>the type </span><span class="c2">F</span><span>Â of </span><span class="c2">S.m</span><span>Â may not be assigned to a function type</span><span class="c2">.</span><span>Â If </span><span class="c2">S.m</span><span>Â does not exist, or if </span><span class="c2">F</span><span>Â is not a function type, the static type of </span><span class="c2">i</span><span>Â is </span><span class="c0 c5">dynamic</span><span>. Otherwise the static type of </span><span class="c2">i</span><span>Â is the declared return type of </span><span class="c2">F. </span></p><p class="c8"><span></span></p><a href="#" name="id.3drgiqgu864y"></a><h4 class="c13"><a name="h.4d637niex9m0"></a><span>Sending Messages</span></h4><p class="c8"><span></span></p><p class="c13"><span>Messages are the sole means of communication among isolates. Messages are sent by invoking specific Â methods in the Dart libraries; there is no specific syntax for sending a message. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">In other words, the methods supporting sending messages embody primitives of Dart that are not accessible to ordinary code, much like the methods that spawn isolates.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.pu3ax3y80hzh"></a><h3 class="c13"><a name="h.2hfie11p4p4e"></a><span>Getter and Setter Lookup</span></h3><p class="c8"><span></span></p><p class="c13"><span>The result of</span><span class="c2">Â looking up a </span><span class="c7 c2"><a class="c4" href="#kix.wlocpej6rvqa">getter</a></span><span class="c2">Â (respectively </span><span class="c7 c2"><a class="c4" href="#kix.i4xvz9z9edz">setter</a></span><span class="c2">) m in object o</span><span>Â </span><span class="c2">with respect to library L</span><span>Â is the result of looking up getter (respectively setter) </span><span class="c2">m</span><span>Â in class </span><span class="c2">C</span><span>Â with respect to </span><span class="c2">L,</span><span>Â where </span><span class="c2">C</span><span>Â is the class of </span><span class="c2">o.</span></p><p class="c8"><span></span></p><p class="c13"><span>The result of </span><span class="c2">looking up getter (respectively setter) m in class C with respect to library L</span><span>Â is:</span></p><p class="c8"><span></span></p><ol class="c16" start="2"><li class="c9"><span>If </span><span class="c2">C</span><span>Â declares an instance Â getter (respectively setter) named </span><span class="c2">m</span><span>Â that is accessible to </span><span class="c2">L,</span><span>Â  then that getter (respectively setter) is the result of the lookup. Otherwise, if </span><span class="c2">C</span><span>Â has a superclass </span><span class="c2">S,</span><span>Â then the result of the lookup is the result of looking up getter (respectively setter) </span><span class="c2">m</span><span>Â in </span><span class="c2">S</span><span>Â with respect to </span><span class="c2">L. </span><span>Otherwise, we say that the lookup has failed.</span></li></ol><p class="c8"><span></span></p><h3 class="c13 c37"><a name="h.j5ym95e31kn6"></a></h3><a href="#" name="id.lharm2td3qkb"></a><h3 class="c13"><a name="h.qnxio27bibb"></a><span>Getter Invocation</span></h3><p class="c8"><span></span></p><p class="c13"><span>A getter invocation provides access to the value of a property.</span></p><p class="c8"><span></span></p><p class="c13"><span>Evaluation of a getter invocation </span><span class="c2">i</span><span>Â of the form </span><span class="c2">e.m</span><span>Â proceeds as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>First, the expression </span><span class="c2">e</span><span>Â is evaluated to an object </span><span class="c2">o.</span><span>Â Then, the getter function </span><span class="c2">m</span><span>Â is </span><span class="c6"><a class="c4" href="#id.pu3ax3y80hzh">looked up</a></span><span>Â in </span><span class="c2">o </span><span>with respect to the current library,</span><span>Â and its body is executed with </span><span class="c0 c5">this</span><span>Â bound to </span><span class="c2">o</span><span>. Â The value of the getter invocation expression is the result returned by the call to the getter function. </span></p><p class="c8"><span></span></p><p class="c13"><span>If the getter lookup has failed, then a new instance </span><span class="c2">im </span><span>Â of the predefined class Â </span><span class="c0">InvocationMirror</span><span>Â  is created</span><span>, such that :</span></p><ol class="c16" start="1"><li class="c9"><span class="c0 c2">im</span><span class="c0">.isGetter</span><span>Â evaluates to </span><span class="c0 c5">true</span><span>.</span></li><li class="c9"><span class="c0 c2">im</span><span class="c0">.memberName</span><span>Â evaluates to â</span><span class="c0">mâ</span><span>.</span></li><li class="c9"><span class="c0 c2">im</span><span class="c0">.positionalArguments</span><span>Â evaluates to the value of </span><span class="c0">[]</span><span>.</span></li><li class="c9"><span class="c0 c2">im</span><span class="c0">.namedArguments</span><span>Â evaluates to the value of </span><span class="c0">{}</span><span>.</span></li></ol><p class="c8"><span></span></p><p class="c13"><span>Then</span><span>Â the method </span><span class="c0">noSuchMethod() </span><span>is looked up in </span><span class="c0 c2">o</span><span>Â and invoked with argument </span><span class="c2">im</span><span class="c0">,</span><span>Â and the result of this invocation is the result of evaluating </span><span class="c2">i</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>Let </span><span class="c2">T</span><span>Â be the Â static type of </span><span class="c2">e.</span><span>Â It is a static type warning if </span><span class="c2">T</span><span>Â does not have a getter named </span><span class="c2">m.</span><span class="c18">Â </span><span>The static type of </span><span class="c2">i</span><span>Â is the declared return type of </span><span class="c2">T.m,</span><span>Â if </span><span class="c2">T.m</span><span>Â exists; otherwise the static type of </span><span class="c2">i</span><span>Â  is </span><span class="c0 c5">dynamic</span><span class="c0">.</span><span>Â </span></p><p class="c8"><span></span></p><p class="c13"><span>Evaluation of a getter invocation </span><span class="c2">i</span><span>Â of the form </span><span class="c2">C.m</span><span>Â proceeds as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>If there is no class </span><span class="c2">C</span><span>Â in the enclosing lexical scope of </span><span class="c2">i,</span><span>Â or if Â </span><span class="c2">C</span><span>Â does not declare, implicitly or explicitly, a getter named </span><span class="c2">m,</span><span>Â a </span><span class="c0">NoSuchMethodError</span><span>Â is thrown. </span><span>Otherwise, the getter function </span><span class="c2">C.m</span><span>Â is invoked. The value of </span><span class="c2">i</span><span>Â is the result returned by the call to the getter function. </span></p><p class="c8"><span></span></p><p class="c13"><span>It is a static warning if there is no class </span><span class="c2">C</span><span>Â in the enclosing lexical scope of </span><span class="c2">i,</span><span>Â or if Â </span><span class="c2">C</span><span>Â does not declare, implicitly or explicitly, a getter named </span><span class="c2">m.</span><span class="c18">Â </span><span>The static type of </span><span class="c2">i</span><span>Â is the declared return type of </span><span class="c2">C.m </span><span>Â if it exists or </span><span class="c0 c5">dynamic</span><span>Â otherwise</span><span class="c0">.</span><span>Â </span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">As of this writing, the above situations are treated as compile time errors by the implementations. </span></p><p class="c8"><span></span></p><p class="c13"><span>Evaluation of a top-level getter invocation </span><span class="c2">i</span><span>Â of the form </span><span class="c2">m</span><span>, where </span><span class="c2">m</span><span>Â is an identifier, </span><span>proceeds as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>The getter function </span><span class="c2">m</span><span>Â is invoked. The value of </span><span class="c2">i</span><span>Â is the result returned by the call to the getter function.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">Note that the invocation is always defined. Per the rules for </span><span class="c6"><a class="c4" href="#id.ayq1ul833tkz">identifier references</a></span><span class="c3">, an identifier will not be treated as a top level getter invocation unless the getter </span><span class="c3 c2">i</span><span class="c3">Â is defined. </span></p><p class="c8"><span></span></p><p class="c13"><span>The static type of </span><span class="c2">i</span><span>Â is the declared return type of </span><span class="c2">m</span><span class="c0">.</span><span>Â </span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.lc2fh7iv9xwt"></a><h3 class="c13"><a name="h.wkwl6fs6jml0"></a><span>Assignment</span></h3><p class="c13"><span>An assignment changes the value associated with a mutable variable or property.</span></p><p class="c8"><span></span></p><a href="#" name="id.gs625gfxuh9m"></a><p class="c13"><span class="c2 c5">assignmentOperator:</span><span class="c2"><br> Â  Â  Â &#39;=&#39;<br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.5bozvn25ytz">compoundAssignmentOperator</a></span><span class="c2"><br> Â  Â ;<br></span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>Evaluation of an assignment </span><span class="c2">a</span><span>Â of the form </span><span class="c2">v = e</span><span>Â proceeds as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>If there is no </span><span>declaration </span><span class="c2">d</span><span>Â with name </span><span class="c2">v=</span><span>Â in the lexical scope</span><span>Â enclosing the assignment, then:</span></p><ol class="c16" start="1"><li class="c9"><span>Â If </span><span class="c2">a</span><span>Â occurs inside a top level or static function (be it function, method, getter, or setter) or variable initializer, evaluation of </span><span class="c2">a</span><span>Â causes a </span><span class="c0">NoSuchMethodError</span><span>Â to be thrown.</span></li><li class="c9"><span>Otherwise, the assignment is equivalent to the assignment </span><span class="c0 c5">this</span><span class="c2">.v = e.</span><span>Â </span></li></ol><p class="c8"><span></span></p><p class="c13"><span>Otherwise, Â let </span><span class="c2">d</span><span>Â be the innermost declaration whose name is </span><span class="c2">v,</span><span>Â if it exists.</span></p><p class="c8"><span></span></p><p class="c13"><span>If </span><span class="c2">d</span><span>Â is the declaration of a local or </span><span>library</span><span>Â variable, the expression </span><span class="c2">e</span><span>Â is evaluated to an object </span><span class="c2">o.</span><span>Â Then, the variable </span><span class="c2">v</span><span>Â is bound to </span><span class="c2">o.</span><span>Â The value of the assignment expression is</span><span class="c2">Â o.</span><span>Â </span></p><p class="c8"><span></span></p><p class="c13"><span>Otherwise, if </span><span class="c2">d</span><span>Â is the declaration of a static variable in class </span><span class="c2">C,</span><span>Â then the assignment is equivalent to the assignment </span><span class="c2">C.v = e.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>Otherwise, the assignment is equivalent to the assignment </span><span class="c0 c5">this</span><span class="c2">.v = e.</span><span>Â </span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>In checked mode, it is a dynamic type error if </span><span class="c2">o</span><span>Â is not </span><span class="c0 c5">null</span><span>Â and the interface of the class of </span><span class="c2">o</span><span>Â is not a subtype of the </span><span class="c7"><a class="c4" href="#id.93yudg3nk9o1">actual type</a></span><span>Â of </span><span class="c2">v</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a static type warning if the static type of </span><span class="c2">e</span><span>Â may not be assigned to the static type of </span><span class="c2">v. </span><span>The static type of the expression </span><span class="c2">v = e</span><span class="c1">Â </span><span>is the static type of </span><span class="c2">e</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>Evaluation of an assignment of the form </span><span class="c2">C.v = e</span><span>Â proceeds as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>If there is no class </span><span class="c2">C</span><span>Â in the enclosing lexical scope of the assignment, or if </span><span class="c2">C</span><span>Â does not declare, implicitly or explicitly, a setter </span><span class="c2">v=, </span><span>then a </span><span class="c0">NoSuchMethodError</span><span>Â is thrown</span><span class="c2">. </span><span>Otherwise, the expression </span><span class="c2">e</span><span>Â is evaluated to an object </span><span class="c2">o.</span><span>Â Then, the setter </span><span class="c2">C.v=</span><span>Â is invoked with its formal parameter bound to o. The value of the assignment expression is</span><span class="c2">Â o.</span><span>Â </span></p><p class="c8"><span></span></p><p class="c13"><span>It is a static warning if there is no class </span><span class="c2">C</span><span>Â in the enclosing lexical scope of the assignment, or if </span><span class="c2">C</span><span>Â does not declare, implicitly or explicitly, a setter </span><span class="c2">v=.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">As of this writing, the above situations are treated as compile time errors by the implementations. </span></p><p class="c8"><span></span></p><p class="c13"><span>In checked mode, it is a dynamic type error if </span><span class="c2">o</span><span>Â is not </span><span class="c0 c5">null</span><span>Â and the interface of the class of o is not a subtype of the static type of </span><span class="c2">C.v</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a static type warning if the static type of </span><span class="c2">e</span><span>Â may not be assigned to the static type of </span><span class="c2">C.v. </span><span>The static type of the expression </span><span class="c2">C.v = e</span><span class="c1">Â </span><span>is the static type of </span><span class="c2">e</span><span>.</span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span></span></p><p class="c13"><span>Evaluation of an assignment of the form </span><span class="c2">e</span><span class="c1">1</span><span class="c2">.v = e</span><span class="c1">2</span><span>Â proceeds as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>The expression </span><span class="c2">e</span><span class="c1">1</span><span>Â is evaluated to an object </span><span class="c2">o</span><span class="c1">1</span><span class="c2">.</span><span>Â Then, the expression </span><span class="c2">e</span><span class="c1">2 </span><span class="c22">Â </span><span>is evaluated to an </span><span>object </span><span class="c2">o</span><span class="c1">2</span><span class="c2">.</span><span>Â Then, the setter </span><span class="c2">v=</span><span>Â is looked up in </span><span class="c2">o</span><span class="c1">1</span><span>Â with respect to the current library</span><span class="c2">,</span><span>Â and its body is executed with its formal parameter bound to </span><span class="c2">o</span><span class="c1">2</span><span class="c2">Â </span><span>and </span><span class="c0 c5">this</span><span>Â bound to </span><span class="c2">o</span><span class="c1">2</span><span class="c2">.</span><span>Â  If the setter lookup has failed, then a new instance </span><span class="c2">im </span><span>Â of the predefined class Â </span><span class="c0">InvocationMirror</span><span>Â </span><span>is created, such that :</span></p><ol class="c16" start="5"><li class="c9"><span class="c0 c2">im</span><span class="c0">.isSetter</span><span>Â evaluates to </span><span class="c0 c5">true</span><span>.</span></li><li class="c9"><span class="c0 c2">im</span><span class="c0">.memberName</span><span>Â evaluates to â</span><span class="c0">v=â</span><span>.</span></li><li class="c9"><span class="c0 c2">im</span><span class="c0">.positionalArguments</span><span>Â evaluates to</span><span>Â </span><span class="c0">[</span><span class="c0 c2">o</span><span class="c1 c0">2</span><span class="c0">]</span><span>.</span></li><li class="c9"><span class="c0 c2">im</span><span class="c0">.namedArguments</span><span>Â evaluates to the value of </span><span class="c0">{}</span><span>.</span></li></ol><p class="c8"><span></span></p><p class="c13"><span>Then</span><span>Â the method </span><span class="c0">noSuchMethod() </span><span>is looked up in </span><span class="c0 c2">o</span><span class="c1 c0">1</span><span>Â with argument </span><span class="c2">im.</span><span>Â </span><span>The value of the assignment expression is </span><span class="c2">o</span><span class="c1">2</span><span class="c2">Â </span><span>irrespective of whether setter lookup has failed or succeeded.</span></p><p class="c8"><span></span></p><p class="c13"><span>In checked mode, it is a dynamic type error if </span><span class="c2">o</span><span class="c1">2</span><span>Â is not </span><span class="c0 c5">null</span><span>Â and the interface of the class of </span><span class="c2">o</span><span class="c1">2</span><span>Â is not a subtype of the </span><span class="c7"><a class="c4" href="#id.93yudg3nk9o1">actual type</a></span><span>Â of </span><span class="c0 c2">e</span><span class="c1 c0">1</span><span class="c2">.v</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>Let </span><span class="c2">T</span><span>Â be the static type of </span><span class="c2">e</span><span class="c1">1</span><span>. It is a static type warning if </span><span class="c2">T</span><span>Â does not have an accessible instance setter named </span><span class="c2">v=</span><span>. It is a static type warning if the static type of </span><span class="c0 c2">e</span><span class="c1 c0">2</span><span>Â may not be assigned to </span><span class="c2">T. </span><span>Â The static type of the expression </span><span class="c2">e</span><span class="c1">1</span><span class="c2">.v = e</span><span class="c1">2 </span><span>is the static type of </span><span class="c2">e</span><span class="c1">2</span><span>.</span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>Evaluation of an assignment of the form </span><span class="c2">e</span><span class="c1">1</span><span class="c2">[e</span><span class="c1">2</span><span class="c2">] = e</span><span class="c1">3</span><span>Â is equivalent to the evaluation of the expression </span><span class="c2">(a, i, e){a.[]=(i, e); </span><span class="c0 c5">return</span><span class="c2">Â e; } (e</span><span class="c1">1</span><span class="c2">, e</span><span class="c1">2</span><span class="c2">, e</span><span class="c1">3</span><span class="c2">). </span><span>The static type of the expression </span><span class="c2">e</span><span class="c1">1</span><span class="c2">[e</span><span class="c1">2</span><span class="c2">] = e</span><span class="c1">3 </span><span>is the static type of </span><span class="c2">e</span><span class="c1">3</span><span>.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>It is as static warning if an assignment of the form </span><span class="c2">v = e </span><span>occurs inside a top level or static function (be it function, method, getter, or setter) or variable initializer and there is no </span><span>declaration </span><span class="c2">d</span><span>Â with name </span><span class="c2">v=</span><span>Â in the lexical scope</span><span>Â enclosing the assignment.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.jkue5mysxwsv"></a><h4 class="c13"><a name="h.ctjzifgzeqep"></a><span>Compound Assignment</span></h4><p class="c8"><span></span></p><p class="c13"><span>A compound assignment of the form</span><span>Â </span><span class="c2">v op= e</span><span>Â is equivalent to </span><span class="c2">v = v op e. </span><span>A compound assignment of the form </span><span class="c2">C.v op= e</span><span>Â is equivalent to </span><span class="c2">C.v = C.v op e. </span><span>A compound assignment of the form </span><span class="c2">e</span><span class="c1">1</span><span class="c2">.v op= e</span><span class="c1">2</span><span>Â is equivalent to</span><span>Â </span><span class="c2">((x) =&gt; x.v = x.v op e</span><span class="c1">2</span><span class="c2">)(e</span><span class="c1">1</span><span class="c2">)</span><span class="c2">Â </span><span>where x is a variable that is not used in </span><span class="c2">e</span><span class="c1">2</span><span class="c2">. </span><span>A compound assignment of the form </span><span class="c2">e</span><span class="c1">1</span><span class="c2">[e</span><span class="c1">2</span><span class="c2">] op=e</span><span class="c1">3</span><span>Â is equivalent to </span><span class="c2">((a, i) =&gt; a[i] = a[i] op e</span><span class="c1">3</span><span class="c2">)(e</span><span class="c1">1</span><span class="c2">, e</span><span class="c1">2</span><span class="c2">) </span><span>where </span><span class="c2">a </span><span>and </span><span class="c2">i </span><span>are a variables that are not used in </span><span class="c2">e</span><span class="c1">3</span><span class="c2">.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.5bozvn25ytz"></a><p class="c13"><span class="c2 c5">compoundAssignmentOperator:</span><span class="c2"><br> Â  Â  Â â*=&#39;<br> Â  Â | &#39;/=&#39;<br> Â  Â | &#39;~/=&#39;<br> Â  Â | &#39;%=&#39;<br> Â  Â | &#39;+=&#39;<br> Â  Â | &#39;-=&#39;<br> Â  Â | &#39;&lt;&lt;=&#39;<br> Â  Â | &#39;&gt;&gt;=&#39;<br> Â  Â | &#39;&amp;=&#39;<br> Â  Â | &#39;^=&#39;<br> Â  Â | &#39;|=&#39;<br> Â  Â ;<br></span></p><a href="#" name="id.qbnp7zy55vr8"></a><h3 class="c13"><a name="h.fpalvmah8gsn"></a><span>Conditional</span></h3><p class="c8"><span></span></p><p class="c13"><span>A </span><span class="c2">conditional expression</span><span>Â evaluates one of two expressions based on a boolean condition.</span></p><p class="c8"><span></span></p><a href="#" name="id.u42blbh7fdm7"></a><p class="c13"><span class="c2 c5">conditionalExpression:</span><span class="c2"><br> Â  Â  </span><span class="c6 c2"><a class="c4" href="#id.c0s0d4oz9l0w">logicalOrExpression</a></span><span class="c2">Â </span><span class="c2">(&#39;?&#39; </span><span class="c6 c2"><a class="c4" href="#id.k68gukuq6cj9">expressionWithoutCascade</a></span><span class="c2">Â &#39;:&#39; </span><span class="c6 c2"><a class="c4" href="#id.k68gukuq6cj9">expressionWithoutCascade</a></span><span class="c2">)</span><span class="c2">?<br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>Evaluation of a conditional expression </span><span class="c2">c</span><span>Â of the form </span><span class="c2">e</span><span class="c1">1</span><span class="c2">Â ? e</span><span class="c1">2</span><span class="c2">Â : e</span><span class="c1">3</span><span>Â proceeds as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>First, </span><span class="c2">e</span><span class="c1">1</span><span>Â is evaluated to an object </span><span class="c2">o</span><span class="c1">1</span><span class="c2">.</span><span>Â In checked mode, it is a dynamic type error if </span><span class="c2">o</span><span class="c1">1</span><span>Â is not of type </span><span class="c0">bool. </span><span>Otherwise </span><span class="c2">o</span><span class="c1">1</span><span>Â is then subjected to </span><span class="c7"><a class="c4" href="#id.luoug0f1vx2f">boolean conversion</a></span><span>Â producing an object </span><span class="c2">r. </span><span>Â </span><span>If </span><span class="c2">r </span><span>is </span><span class="c0 c5">true</span><span>, then the value of </span><span class="c2">c</span><span>Â is the result of evaluating the expression </span><span class="c2">e</span><span class="c1">2</span><span class="c2">.</span><span>Â Otherwise the value of </span><span class="c2">c</span><span>Â is the result of evaluating the expression </span><span class="c2">e</span><span class="c1">3</span><span class="c2">. </span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span class="c2">Â </span><span>It is a static type warning if the type of </span><span class="c2">e</span><span class="c1">1</span><span>Â may not be assigned to </span><span class="c0">bool.</span><span>Â </span><span class="c2">Â </span><span>The static type of Â </span><span class="c2">c</span><span>Â is the least upper bound of the static type of </span><span class="c2">e</span><span class="c1">2</span><span>Â and the static type of </span><span class="c2">e</span><span class="c1">3</span><span class="c2">.</span></p><p class="c13"><span>Â </span></p><a href="#" name="id.hlq4iia0hdjd"></a><h3 class="c13"><a name="h.33dew20hjpt"></a><span>Logical Boolean Expressions</span></h3><p class="c8"><span></span></p><p class="c13"><span>The logical boolean expressions combine boolean objects using the boolean conjunction and disjunction operators.</span></p><p class="c13"><span class="c2"><br></span><a href="#" name="id.c0s0d4oz9l0w"></a><span class="c2 c5">logicalOrExpression:</span><span class="c2"><br> Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#id.3dq31ctuko9q">logicalAndExpression</a></span><span class="c2">Â (&#39;||&#39; </span><span class="c6 c2"><a class="c4" href="#id.3dq31ctuko9q">logicalAndExpression</a></span><span class="c2">)*<br> Â  Â ;<br><br></span><a href="#" name="id.3dq31ctuko9q"></a><span class="c2 c5">logicalAndExpression:</span><span class="c2"><br> Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#id.8ofycl50r6w5">bitwiseOrExpression</a></span><span class="c2">Â (&#39;</span><span class="c2">&amp;&amp;&#39; </span><span class="c6 c2"><a class="c4" href="#id.8ofycl50r6w5">bitwiseOrExpression</a></span><span class="c2">)*<br> Â  Â ;<br></span></p><p class="c13"><span>A </span><span class="c2">logical boolean expression</span><span>Â is </span><span>either a </span><span class="c7"><a class="c4" href="#id.5wxjf46dh7v0">bitwise expression</a></span><span>, or an invocation of a logical boolean operator on an expression </span><span class="c2">e</span><span class="c1">1</span><span>Â with argument </span><span class="c2">e</span><span class="c1">2</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>Evaluation of a logical boolean expression </span><span class="c2">b</span><span>Â of the form </span><span class="c2">e</span><span class="c1">1</span><span class="c2">Â || e</span><span class="c1">2</span><span class="c2">Â </span><span>causes the evaluation of </span><span class="c2">e</span><span class="c1">1</span><span>; i</span><span>f </span><span class="c2">e</span><span class="c1">1</span><span>Â evaluates to </span><span class="c0 c5">true</span><span>, the result of evaluating </span><span class="c2">b</span><span>Â is </span><span class="c0 c5">true</span><span>, otherwise </span><span class="c2">e</span><span class="c1">2</span><span>Â is evaluated to an object </span><span class="c2">o,</span><span>Â which is then subjected to </span><span class="c7"><a class="c4" href="#id.luoug0f1vx2f">boolean conversion</a></span><span>Â producing a an object </span><span class="c2">r,</span><span>Â which is the value of </span><span class="c2">b. </span></p><p class="c8"><span></span></p><p class="c13"><span>Evaluation a logical boolean expression </span><span class="c2">b</span><span>Â of the form </span><span class="c2">e</span><span class="c1">1</span><span class="c2">Â &amp;&amp; e</span><span class="c1">2</span><span class="c2">Â </span><span>causes the evaluation </span><span class="c2">e</span><span class="c1">1</span><span>; if </span><span class="c2">e</span><span class="c1">1</span><span>Â does not evaluate to </span><span class="c0 c5">true</span><span>, the result of evaluating </span><span class="c2">b</span><span>Â is </span><span class="c0 c5">false</span><span>, otherwise </span><span class="c2">e</span><span class="c1">2</span><span>Â is evaluated to an object </span><span class="c2">o,</span><span>Â which is then subjected to </span><span class="c7"><a class="c4" href="#id.luoug0f1vx2f">boolean conversion</a></span><span>Â producing an object </span><span class="c2">r,</span><span>Â which is the value of </span><span class="c2">b. </span></p><p class="c8"><span class="c18"></span></p><p class="c13"><span>The static type of a logical boolean expression is </span><span class="c0">bool.</span></p><p class="c8"><span></span></p><a href="#" name="id.5wxjf46dh7v0"></a><h3 class="c13"><a name="h.gxkncuzhsd9x"></a><span>Bitwise Expressions</span></h3><p class="c8"><span></span></p><p class="c13"><span>Bitwise expressions invoke the bitwise operators on objects.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c2"><br></span><a href="#" name="id.8ofycl50r6w5"></a><span class="c2 c5">bitwiseOrExpression:</span><span class="c2"><br> Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#id.ponnokpig962">bitwiseXorExpression</a></span><span class="c2">Â (&#39;|&#39; </span><span class="c6 c2"><a class="c4" href="#id.ponnokpig962">bitwiseXorExpression</a></span><span class="c2">)*<br> Â  Â | </span><span class="c0">super</span><span class="c2">Â (&#39;|&#39; </span><span class="c6 c2"><a class="c4" href="#id.ponnokpig962">bitwiseXorExpression</a></span><span class="c2">)+<br> Â  Â ;<br><br></span><a href="#" name="id.ponnokpig962"></a><span class="c2 c5">bitwiseXorExpression:</span><span class="c2"><br> Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#id.6jqdarh7i55f">bitwiseAndExpression</a></span><span class="c2">Â (&#39;^&#39; </span><span class="c6 c2"><a class="c4" href="#id.6jqdarh7i55f">bitwiseAndExpression</a></span><span class="c2">)*<br> Â  Â | </span><span class="c0">super</span><span class="c2">Â (&#39;^&#39; </span><span class="c6 c2"><a class="c4" href="#id.6jqdarh7i55f">bitwiseAndExpression</a></span><span class="c2">)+<br> Â  Â ;<br><br></span><a href="#" name="id.6jqdarh7i55f"></a><span class="c2 c5">bitwiseAndExpression:</span><span class="c2"><br> Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#id.t3kezrkaouv2">equalityExpression</a></span><span class="c2">Â (&#39;&amp;&#39; </span><span class="c6 c2"><a class="c4" href="#id.t3kezrkaouv2">equalityExpression</a></span><span class="c2">)*<br> Â  Â | </span><span class="c0">super</span><span class="c2">Â (&#39;&amp;&#39; </span><span class="c6 c2"><a class="c4" href="#id.t3kezrkaouv2">equalityExpression</a></span><span class="c2">)+</span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.mp6goh4wcueb"></a><p class="c13"><span class="c2 c5">bitwiseOperator:</span><span class="c2"><br> Â  Â  Â &#39;&amp;&#39;<br> Â  Â | &#39;^&#39;<br> Â  Â | &#39;|&#39;<br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>A </span><span class="c2">bitwise expression</span><span>Â is either an </span><span class="c7"><a class="c4" href="#id.i3yv71am0yah">equality expression</a></span><span>, or an invocation of a bitwise operator on either </span><span class="c0 c5">super</span><span>Â or an expression </span><span class="c2">e</span><span class="c1">1</span><span>, with argument </span><span class="c2">e</span><span class="c1">2</span><span>.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>A </span><span>bitwise expression </span><span>of the form Â </span><span class="c2">e</span><span class="c1">1</span><span class="c2">Â op e</span><span class="c1">2</span><span class="c2">Â </span><span>is equivalent to the method invocation </span><span class="c2">e1.op(e2).</span></p><p class="c13"><span>A bitwise expression of the form</span><span>Â  </span><span class="c0 c2 c5">super</span><span class="c2">Â op e</span><span class="c1">2</span><span class="c2">Â </span><span>is equivalent to the method invocation </span><span class="c0 c2 c5">super</span><span class="c2">.op(e</span><span class="c1">2</span><span class="c2">).</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span class="c3">It should be obvious that the static type rules for these expressions are defined by the equivalence above - ergo, by the type rules for method invocation and the signatures of the operators on the type </span><span class="c3 c2">e</span><span class="c1 c3">1</span><span class="c3 c2">.</span><span class="c3">Â The same holds in similar situations throughout this specification.</span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.i3yv71am0yah"></a><h3 class="c13"><a name="h.5kdfq4b9vyr1"></a><span>Equality</span></h3><p class="c8"><span></span></p><p class="c13"><span>Equality expressions test objects for identity or equality.</span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.t3kezrkaouv2"></a><p class="c13"><span class="c2 c5">equalityExpression:</span><span class="c2"><br> Â  Â  Â relationalExpression (</span><span class="c6 c2"><a class="c4" href="#id.udvn0y5cd5a9">equalityOperator</a></span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.5ev8aeaipufa">relationalExpression</a></span><span class="c2">)?<br> Â  Â | </span><span class="c0 c5">super</span><span class="c2">Â equalityOperator relationalExpression<br> Â  Â ;<br></span></p><a href="#" name="id.udvn0y5cd5a9"></a><p class="c13"><span class="c2 c5">equalityOperator:</span><span class="c2"><br> Â  Â  Â &#39;==&#39;<br> Â  Â | &#39;!=&#39;<br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>An </span><span class="c2">equality expression</span><span>Â is either a </span><span class="c7"><a class="c4" href="#id.t07xpf1d6trb">relational expression</a></span><span>, or an invocation of an equality operator </span><span>on </span><span>either </span><span class="c0 c5">super</span><span>Â or an expression </span><span class="c2">e</span><span class="c1">1</span><span>, with argument </span><span class="c2">e</span><span class="c1">2</span><span>.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>Evaluation of an equality expression </span><span class="c2">ee</span><span>Â of the form </span><span class="c2">e</span><span class="c10 c2">1</span><span class="c2">Â == e</span><span class="c10 c2">2</span><span class="c2">Â </span><span>proceeds as follows:</span></p><ol class="c16" start="1"><li class="c9"><span>The expression </span><span class="c2">e</span><span class="c10 c2">1</span><span>Â is evaluated to an object </span><span class="c2">o</span><span class="c10 c2">1</span><span>.</span></li><li class="c9"><span>The expression </span><span class="c2">e</span><span class="c10 c2">2</span><span>Â is evaluated to an object </span><span class="c2">o</span><span class="c10 c2">2</span><span>.</span></li></ol><ol class="c16" start="1"><li class="c9"><span>If either </span><span class="c2">o</span><span class="c10 c2">1</span><span>Â or </span><span class="c2">o</span><span class="c10 c2">2</span><span>Â is </span><span class="c0">null</span><span>, then </span><span class="c2">ee</span><span>Â evaluates to </span><span class="c0">identical(</span><span class="c2">o</span><span class="c10 c2">1</span><span class="c2">,o</span><span class="c10 c2">2</span><span class="c0">). </span><span>Otherwise,</span></li></ol><ol class="c16" start="3"><li class="c9"><span class="c2">ee</span><span>Â is equivalent to the method invocation </span><span class="c2">o</span><span class="c10 c2">1</span><span class="c2">.</span><span class="c0 c2 c5">==</span><span class="c2">(o</span><span class="c10 c2">2</span><span class="c2">).</span></li></ol><p class="c8"><span class="c2"></span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>Evaluation of an equality expression </span><span class="c2">ee</span><span>Â of the form </span><span class="c0 c2 c5">super</span><span class="c2">Â == e </span><span>proceeds as follows:</span></p><ol class="c16" start="1"><li class="c9"><span>The expression </span><span class="c2">e</span><span>Â is evaluated to an object </span><span class="c2">o</span><span>.</span></li><li class="c9"><span>If either </span><span class="c0 c5">this</span><span>Â or </span><span class="c2">o</span><span>Â is </span><span class="c0">null</span><span>, then </span><span class="c2">ee</span><span>Â evaluates to </span><span class="c0">identical(</span><span class="c0 c5">this</span><span class="c2">,o</span><span class="c0">)</span><span>. Otherwise,</span></li><li class="c9"><span class="c2">ee</span><span>Â is equivalent to the method invocation </span><span class="c0 c2 c5">super</span><span class="c2">.</span><span class="c0 c2 c5">==</span><span class="c2">(o).</span></li></ol><p class="c8"><span class="c2"></span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span class="c3">As a result of the above definition, user defined </span><span class="c0 c3 c5">==</span><span class="c3">Â methods can assume that their argument is non-null, and avoid the standard boiler-plate prelude:</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c0 c3">if (identical(null, arg)) return false;</span></p><p class="c8"><span class="c0 c3"></span></p><p class="c13"><span class="c3">Another implication is that there is never a need to use </span><span class="c0 c3">identical</span><span class="c3">Â to test against </span><span class="c0 c3">null,</span><span class="c3">Â nor should anyone ever worry about whether to write </span><span class="c0 c3">identical</span><span class="c3">(</span><span class="c0 c3">null, e) </span><span class="c3">or </span><span class="c0 c3">identical</span><span class="c3">(</span><span class="c0 c3">e, null)</span><span class="c3">.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>An equality expression of the form </span><span class="c2">e</span><span class="c1">1</span><span class="c2">Â != e</span><span class="c1">2 Â </span><span>is equivalent to the expression </span><span class="c2">!(e</span><span class="c1">1</span><span class="c2">Â == e</span><span class="c1">2 </span><span class="c2">). </span><span>An equality expression of the form Â </span><span class="c0 c2 c5">super</span><span class="c2">Â != e </span><span>is equivalent to the expression </span><span class="c2">!(</span><span class="c0 c2 c5">super</span><span class="c2">Â </span><span class="c2">== e</span><span class="c2">)</span><span class="c2">).</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>The static type of an equality expression is </span><span class="c0">bool.</span></p><p class="c8"><span class="c0"></span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.t07xpf1d6trb"></a><h3 class="c13"><a name="h.fmzbyxz4ly1c"></a><span>Relational Expressions</span></h3><p class="c8"><span></span></p><p class="c13"><span>Relational expressions invoke the relational operators on objects.</span></p><p class="c13"><span class="c2"><br></span><a href="#" name="id.5ev8aeaipufa"></a><span class="c2 c5">relationalExpression:</span><span class="c2"><br> Â  Â  Â shiftExpression (</span><span class="c6 c2"><a class="c4" href="#id.etj4op59hgoi">typeTest</a></span><span class="c2">Â | </span><span class="c6 c2"><a class="c4" href="#id.pjkdsymsshxy">typeCast</a></span><span class="c2">Â | relationalOperator shiftExpression)?<br> Â  Â | </span><span class="c0 c5">super</span><span class="c2">Â relationalOperator shiftExpression<br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span class="c2"><br></span><a href="#" name="id.dqm1hvagt3y5"></a><span class="c2 c5">relationalOperator:</span><span class="c2"><br> Â  Â  Â &#39;&gt;=&#39;<br> Â  Â | &#39;&gt;&#39;<br> Â  Â | &#39;&lt;=&#39;<br> Â  Â | &#39;&lt;&#39;<br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>A </span><span class="c2">relational expression</span><span>Â is either a </span><span class="c7"><a class="c4" href="#id.dvp94fjydf3m">shift expression</a></span><span>, or an invocation of a relational operator on Â on either </span><span class="c0 c5">super</span><span>Â or an expression </span><span class="c2">e</span><span class="c1">1</span><span>, </span><span>with argument </span><span class="c2">e</span><span class="c1">2</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>A relational expression of the form Â </span><span class="c2">e1 op e2 </span><span>is equivalent to the method invocation </span><span class="c2">e1.op(e2).</span></p><p class="c13"><span>A relational expression of the form Â </span><span class="c0 c2 c5">super</span><span class="c2">Â op e2 </span><span>is equivalent to the method invocation </span><span class="c0 c2 c5">super</span><span class="c2">.op(e2).</span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.dvp94fjydf3m"></a><h3 class="c13"><a name="h.jmq7bvufo5ez"></a><span>Shift</span></h3><p class="c8"><span></span></p><p class="c13"><span class="c2">Shift expressions</span><span>Â invoke the shift operators on objects.</span></p><p class="c13"><span><br></span><a href="#" name="id.37ba2r89wwl"></a><span class="c2 c5">shiftExpression:</span><span class="c2"><br> Â  Â  Â additiveExpression (shiftOperator additiveExpression)*<br> Â  Â | </span><span class="c0 c5">super</span><span class="c2">Â (shiftOperator additiveExpression)+<br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.m87pll3ti0gq"></a><p class="c13"><span class="c2 c5">shiftOperator:</span><span class="c2"><br> Â  Â  Â &#39;&lt;&lt;&#39;<br> Â  Â | &#39;&gt;&gt;&#39; <br> Â  Â ;<br></span></p><p class="c13"><span>A </span><span class="c2">shift expression</span><span>Â is either an </span><span class="c7"><a class="c4" href="#id.lw482t2ir5le">additive expression</a></span><span>, or an invocation of a shift operator on Â </span><span>on </span><span>either </span><span class="c0 c5">super</span><span>Â or an expression </span><span class="c2">e</span><span class="c1">1</span><span>, with argument </span><span class="c2">e</span><span class="c1">2</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>A shift expression of the form Â </span><span class="c2">e1 op e2 </span><span>is equivalent to the method invocation </span><span class="c2">e1.op(e2).</span></p><p class="c13"><span>A shift expression of the form Â </span><span class="c0 c2 c5">super</span><span class="c2">Â op e2 </span><span>is equivalent to the method invocation </span><span class="c0 c2 c5">super</span><span class="c2">.op(e2).</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span class="c3">Note that this definition implies left-to-right evaluation order among shift expressions: </span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3 c2">e</span><span class="c1 c3">1</span><span class="c3 c2">Â &lt;&lt; e</span><span class="c1 c3">2</span><span class="c3 c2">Â &lt;&lt; e</span><span class="c1 c3">3</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">is evaluated as Â (</span><span class="c3 c2">e</span><span class="c1 c3">1</span><span class="c3 c2">Â &lt;&lt; e</span><span class="c1 c3">2</span><span class="c3 c2">Â ).&lt;&lt; (e</span><span class="c1 c3">3</span><span class="c3">) Â which is equivalent to (</span><span class="c3 c2">e</span><span class="c1 c3">1</span><span class="c3 c2">Â &lt;&lt; e</span><span class="c1 c3">2</span><span class="c3 c2">) &lt;&lt; e</span><span class="c1 c3">3</span><span class="c2 c47">.</span></p><p class="c13"><span class="c3">The same holds for additive and multiplicative expressions. </span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.lw482t2ir5le"></a><h3 class="c13"><a name="h.7hq9zn6blrwm"></a><span>Additive Expressions</span></h3><p class="c8"><span class="c2"></span></p><p class="c13"><span class="c2">Additive expressions</span><span>Â invoke the addition operators on objects.</span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span class="c2"><br></span><a href="#" name="id.8uueyjhsc89s"></a><span class="c2 c5">additiveExpression:</span><span class="c2"><br> Â  Â  Â multiplicativeExpression (additiveOperator multiplicativeExpression)*<br> Â  Â | </span><span class="c0 c5">super</span><span class="c2">Â (additiveOperator multiplicativeExpression)+<br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.zg2oy42p83ut"></a><p class="c13"><span class="c2 c5">additiveOperator:</span><span class="c2"><br> Â  Â  Â &#39;+&#39;<br> Â  Â | &#39;-&#39;<br> Â  Â ;<br></span></p><p class="c13"><span>An </span><span class="c2">additive expression</span><span>Â is either a </span><span class="c7"><a class="c4" href="#id.ksyfp4fbik8u">multiplicative expression</a></span><span>, or an invocation of an additive operator on Â on either </span><span class="c0 c5">super</span><span>Â or an expression </span><span class="c2">e</span><span class="c1">1</span><span>, with argument </span><span class="c2">e</span><span class="c1">2</span><span>.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>An additive expression of the form Â </span><span class="c2">e1 op e2 </span><span>is equivalent to the method invocation </span><span class="c2">e1.op(e2).</span></p><p class="c13"><span>An additive expression of the form Â </span><span class="c0 c2 c5">super</span><span class="c2">Â op e2 </span><span>is equivalent to the method invocation </span><span class="c0 c2 c5">super</span><span class="c2">.op(e2).</span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.ksyfp4fbik8u"></a><h3 class="c13"><a name="h.uofn135f1hb3"></a><span>Multiplicative Expressions</span></h3><p class="c8"><span></span></p><p class="c13"><span class="c2">Multiplicative expressions</span><span>Â invoke the multiplication operators on objects.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span class="c2"><br></span><a href="#" name="id.9keimk8xamh7"></a><span class="c2 c5">multiplicativeExpression:</span><span class="c2"><br> Â  Â  Â unaryExpression (multiplicativeOperator unaryExpression)*<br> Â  Â | </span><span class="c0 c5">super</span><span class="c2">Â (multiplicativeOperator unaryExpression)+<br> Â  Â ;<br></span></p><a href="#" name="id.q23phy16kl7s"></a><p class="c13"><span class="c2 c5">multiplicativeOperator:</span><span class="c2"><br> Â  Â  Â &#39;*&#39;<br> Â  Â | &#39;</span><span class="c2">/</span><span class="c2">&#39;<br> Â  Â | &#39;</span><span class="c2">%</span><span class="c2">&#39;<br> Â  Â | &#39;</span><span class="c2">~/</span><span class="c2">&#39;<br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span></span></p><p class="c13"><span>A </span><span class="c2">multiplicative expression</span><span>Â is either a </span><span class="c7"><a class="c4" href="#id.20somwjc6usp">unary expression</a></span><span>, or an invocation of a multiplicative operator on either </span><span class="c0 c5">super</span><span>Â or an expression </span><span class="c2">e</span><span class="c1">1</span><span>, with argument </span><span class="c2">e</span><span class="c1">2</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>A multiplicative expression of the form Â </span><span class="c2">e1 op e2 </span><span>is equivalent to the method invocation </span><span class="c2">e1.op(e2). </span><span>A multiplicative expression of the form Â </span><span class="c0 c2 c5">super</span><span class="c2">Â op e2 </span><span>is equivalent to the method invocation </span><span class="c0 c2 c5">super</span><span class="c2">.op(e2).</span></p><p class="c8"><span class="c2"></span></p><h3 class="c13"><a name="h.nctl41fjp9vk"></a><span class="c2"><br></span><a href="#" name="id.20somwjc6usp"></a><span>Unary Expressions</span></h3><p class="c8"><span></span></p><p class="c13"><span>Unary expressions invoke unary operators on objects.</span></p><p class="c13"><span><br></span><a href="#" name="id.ibekae2xw66d"></a><span class="c2 c5">unaryExpression:</span><span class="c2"><br> Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#id.ddbfdqqeafna">prefixOperator</a></span><span class="c2">Â unaryExpression<br> Â  Â | postfixExpression<br> Â  Â | </span><span class="c2">unaryOperator </span><span class="c0 c5">super</span><span class="c2"><br> Â  Â | &#39;-&#39; </span><span class="c0 c5">super</span><span class="c2">Â </span><span class="c2"><br> Â  Â | incrementOperator assignableExpression<br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span class="c2"></span></p><a href="#" name="kix.gf2hdz9iwix4"></a><p class="c13"><span class="c2 c5">prefixOperator:</span><span class="c2"><br> Â  Â  Â  &#39;-&#39;</span></p><p class="c13"><span class="c2">Â  Â  | </span><span class="c6 c2"><a class="c4" href="#kix.d4e5p7r887m5">unaryOperator</a></span><span class="c2"><br> Â  Â ;<br></span></p><a href="#" name="kix.qbry4ohsrg62"></a><p class="c13"><span class="c2 c5">unaryOperator:</span><span class="c2"><br> Â  Â  &#39;!&#39;<br> Â  Â | &#39;~&#39;<br> Â  Â ;</span></p><p class="c13"><span>A </span><span class="c2">unary expression</span><span>Â is either a </span><span class="c7"><a class="c4" href="#id.jzsb5y8clslk">postfix expression</a></span><span>, an invocation of a prefix operator on an expression </span><span class="c2">e,</span><span>Â or an invocation of a unary operator on either </span><span class="c0 c5">super</span><span>Â or an expression </span><span class="c2">e</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>The expression </span><span class="c2">!e</span><span>Â is equivalent to the expression </span><span class="c2">e? </span><span class="c0 c2 c5">false</span><span class="c2">: </span><span class="c0 c2 c5">true</span><span class="c2">.</span></p><p class="c13"><span>Evaluation of an expression of the form </span><span class="c0">++</span><span class="c0 c2">e </span><span>is equivalent to </span><span class="c0 c2">e</span><span class="c0">Â += 1.</span><span>Â  Evaluation of an expression of the form </span><span class="c0">--</span><span class="c0 c2">e</span><span>Â is equivalent to </span><span class="c0 c2">e</span><span class="c0">Â -= 1.</span><span>Â </span></p><p class="c8"><span></span></p><p class="c13"><span>A unary expression </span><span class="c2">u</span><span>Â of the form </span><span class="c2">op e</span><span>Â is equivalent to a method invocation Â expression </span><span class="c2">e.op().</span></p><p class="c13"><span>An expression of the form </span><span class="c2">op </span><span class="c0 c5">super</span><span>Â is equivalent to the method invocation </span><span class="c0 c5">super</span><span class="c2">.op().</span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span></span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.jzsb5y8clslk"></a><h3 class="c13"><a name="h.h035ru2uchdu"></a><span>Postfix Expressions</span></h3><p class="c8"><span></span></p><p class="c13"><span>Postfix expressions invoke the postfix operators on objects.</span></p><p class="c13"><span class="c2"><br></span><a href="#" name="id.v4mie360u0q2"></a><span class="c2 c5">postfixExpression:</span><span class="c2"><br> Â  Â  Â assignableExpression postfixOperator<br> Â  Â | primary selector*<br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.mdk3odnrh07m"></a><p class="c13"><span class="c2 c5">postfixOperator:</span><span class="c2"><br> Â  Â  Â incrementOperator<br> Â  Â ;<br><br><br></span><a href="#" name="kix.yizwlgqjrpzw"></a><span class="c2 c5">selector:</span><span class="c2"><br> Â  Â  Â assignableSelector<br> Â  Â | </span><span class="c7 c2"><a class="c4" href="#kix.xl2ewwstkqba">arguments</a></span><span class="c2"><br> Â  Â ;</span></p><p class="c13"><span class="c2"><br></span><a href="#" name="id.s3388kir88ok"></a><span class="c2 c5">incrementOperator:</span><span class="c2"><br> Â  Â  Â &#39;++&#39;<br> Â  Â | &#39;--&#39;<br> Â  Â ;<br></span></p><p class="c8"><span></span></p><p class="c13"><span>A </span><span class="c2">postfix expression</span><span>Â is either a primary expression, a function, method or getter invocation, or an invocation of a postfix operator on an expression </span><span class="c2">e</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>A postfix expression of the form </span><span class="c0 c2">v</span><span class="c0">++</span><span>, where </span><span class="c2">v</span><span>Â is an identifier, is equivalent to </span><span class="c2">(){var r = v; v = r + 1; return r}().</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span class="c12 c2">The above ensures that if v is a field, the getter gets called exactly once. Likewise in the cases below. </span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>A postfix expression of the form </span><span class="c0 c2">C.v </span><span class="c0">++</span><span>Â is equivalent to </span><span class="c2">(){var r = C.v; C.v = r + 1; return r}().</span></p><p class="c8"><span></span></p><p class="c13"><span>A</span><span>Â postfix expression of the form </span><span class="c2">e</span><span class="c1">1</span><span class="c2">.v</span><span class="c0">++</span><span>Â is equivalent to </span><span class="c2">(x){var r = x.v; x.v = r + 1; return r}(e</span><span class="c1">1</span><span class="c2">).</span></p><p class="c8"><span></span></p><p class="c13"><span>A postfix expression of the form </span><span class="c2">e</span><span class="c1">1</span><span class="c2">[e</span><span class="c1">2</span><span class="c2">]</span><span class="c0">++</span><span>Â is equivalent to </span><span class="c2">(a, i){var r = a[i]; a[i] = r + 1; return r}(e</span><span class="c1">1</span><span class="c2">, e</span><span class="c1">2</span><span class="c2">)</span></p><p class="c8"><span></span></p><p class="c13"><span>A postfix expression of the form </span><span class="c0 c2">v--</span><span>, where </span><span class="c2">v</span><span>Â is an identifier, is equivalent to </span><span class="c2">(){var r = v; v = r - 1; return r}().</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>A postfix expression of the form </span><span class="c0 c2">C.v--</span><span>Â is equivalent to </span><span class="c2">(){var r = C.v; C.v = r - 1; return r}().</span></p><p class="c8"><span></span></p><p class="c13"><span>A postfix expression of the form </span><span class="c2">e</span><span class="c1">1</span><span class="c2">.v--</span><span>Â is equivalent to </span><span class="c2">(x){var r = x.v; x.v = r - 1; return r}(e</span><span class="c1">1</span><span class="c2">).</span></p><p class="c8"><span></span></p><p class="c13"><span>A postfix expression of the form </span><span class="c2">e</span><span class="c1">1</span><span class="c2">[e</span><span class="c1">2</span><span class="c2">]</span><span class="c0">--</span><span>Â is equivalent to </span><span class="c2">(a, i){var r = a[i]; a[i] = r - 1; return r}(e</span><span class="c1">1</span><span class="c2">, e</span><span class="c1">2</span><span class="c2">)</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.i8uc5yxjszau"></a><h3 class="c13"><a name="h.dt5sshf3wb90"></a><span>Assignable Expressions</span></h3><p class="c8"><span></span></p><p class="c13"><span>Assignable expressions are expressions that can appear on the left hand side of an assignment. This section describes how to evaluate these expressions when they do not constitute the complete left hand side of an assignment.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">Of course, if assignable expressions always appeared </span><span class="c12 c2 c5">as</span><span class="c12 c2">Â the left hand side, one would have no need for their value, and the rules for evaluating them would be unnecessary. However, Â assignable expressions can be subexpressions of other expressions and therefore must be evaluated.</span></p><p class="c8"><span></span></p><p class="c8"><span class="c2"></span></p><a href="#" name="kix.3nqu822r00nf"></a><p class="c13"><span class="c2 c5">assignableExpression:</span><span class="c2"><br> Â  Â  Â primary (arguments* assignableSelector)+<br> Â  Â | </span><span class="c0 c5">super</span><span class="c2">Â assignableSelector<br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2"><br> Â  Â ;<br></span></p><a href="#" name="kix.sozsnkf6qfzk"></a><p class="c13"><span class="c2 c5">assignableSelector:</span><span class="c2"><br> Â  Â  Â &#39;[&#39; </span><span class="c6 c2"><a class="c4" href="#id.1u3vxuwrz6py">expression</a></span><span class="c2">Â &#39;]&#39;<br> Â  Â | &#39;.&#39; </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2"><br> Â  Â ;<br></span></p><p class="c13"><span>An </span><span class="c2">assignable expression</span><span>Â is either:</span></p><ol class="c16" start="1"><li class="c9"><span>Â An identifier. </span></li><li class="c9"><span>An invocation of a method, getter or list access operator on</span><span>Â an expression </span><span class="c2">e</span><span>.</span></li><li class="c9"><span>An invocation of a getter or list access operator on </span><span class="c0 c5">super</span><span>.</span></li></ol><p class="c8"><span class="c2"></span></p><p class="c13"><span>An assignable expression of the form </span><span class="c2">id</span><span>Â is evaluated as an </span><span class="c7"><a class="c4" href="#id.ayq1ul833tkz">identifier expression</a></span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>An assignable expression of the form </span><span class="c2">e.id(a</span><span class="c1">1</span><span class="c2">, â¦, a</span><span class="c1">n</span><span class="c2">)</span><span class="c2">Â </span><span>is evaluated as a </span><span class="c7"><a class="c4" href="#kix.1bfikjk2e9bd">method invocation</a></span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>An assignable expression of the form </span><span class="c2">e.id </span><span>is evaluated as a </span><span class="c7"><a class="c4" href="#id.lharm2td3qkb">getter invocation</a></span><span>.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>An assignable expression of the form </span><span class="c2">e</span><span class="c1">1</span><span class="c2">[e</span><span class="c1">2</span><span class="c2">]</span><span>Â is evaluated as a </span><span class="c7"><a class="c4" href="#kix.1bfikjk2e9bd">method invocation</a></span><span>Â of the operator method </span><span class="c2">[]</span><span>Â on </span><span class="c2">e</span><span class="c1">1 </span><span>with argument </span><span class="c2">e</span><span class="c1">2</span><span class="c2">.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>An assignable expression of the form </span><span class="c0 c2 c5">super</span><span class="c2">.id </span><span>is evaluated as a </span><span class="c7"><a class="c4" href="#id.lharm2td3qkb">getter invocation</a></span><span>.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>An assignable expression of the form </span><span class="c0 c2 c5">super</span><span class="c2">[e</span><span class="c1">2</span><span class="c2">]</span><span>Â is equivalent to the </span><span class="c7"><a class="c4" href="#kix.1bfikjk2e9bd">method invocation</a></span><span>Â  </span><span class="c0 c2 c5">super</span><span class="c0">.</span><span class="c2">[e</span><span class="c1">2</span><span class="c2">].</span></p><p class="c8"><span></span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.ayq1ul833tkz"></a><h3 class="c13"><a name="h.igni7ynd65c8"></a><span>Identifier Reference</span></h3><p class="c8"><span></span></p><p class="c13"><span>An </span><span class="c2">identifier expression</span><span>Â consists of a single identifier; it provides access to an object via an unqualified name.</span></p><p class="c8"><span></span></p><a href="#" name="id.te0njh1fhw7g"></a><p class="c13"><span class="c2 c5">identifier:</span><span class="c2"><br> Â  Â  </span><span class="c2">Â  IDENTIFIER</span></p><p class="c13"><span class="c2">Â  Â  ;</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.m0fl3pkjxvo8"></a><p class="c13"><span class="c2 c5">IDENTIFIER_NO_DOLLAR:</span><span class="c2"><br> Â  Â  Â IDENTIFIER_START_NO_DOLLAR IDENTIFIER_PART_NO_DOLLAR*<br> Â  Â ;<br><br></span><a href="#" name="id.8h9okiij55u5"></a><span class="c2 c5">IDENTIFIER:</span><span class="c2"><br> Â  Â  Â IDENTIFIER_START IDENTIFIER_PART*<br> Â  Â ;<br><br></span><span class="c28 c2">Â  Â  ;</span></p><p class="c8"><span class="c28 c2"></span></p><a href="#" name="id.xz9q4hxlymsw"></a><p class="c13"><span class="c2 c5">BUILT_IN_IDENTIFIER:<br></span><span class="c2">Â  Â  Â  </span><span class="c0 c5">abstract</span></p><p class="c13"><span class="c2">Â  Â  | </span><span class="c0 c5">as</span></p><p class="c13"><span class="c0 c5">Â  Â  </span><span>|</span><span class="c0 c5">Â dynamic</span></p><p class="c13"><span class="c2">Â  Â  | </span><span class="c0 c5">export</span></p><p class="c13"><span class="c2">Â  Â  | </span><span class="c0 c5">external </span><span class="c2"><br> Â  Â | </span><span class="c0 c5">factory</span><span class="c2"><br> Â  Â | </span><span class="c0 c5">get</span><span class="c2"><br> Â  Â | </span><span class="c0 c5">implements</span></p><p class="c13"><span class="c2">Â  Â  | </span><span class="c0 c5">import</span></p><p class="c13"><span class="c2">Â  Â  | </span><span class="c0 c5">library</span><span class="c2"><br> Â  Â | </span><span class="c0 c5">operator</span></p><p class="c13"><span class="c2">Â  Â  | </span><span class="c0 c5">part</span><span class="c2"><br> Â  Â | </span><span class="c0 c5">set</span><span class="c2"><br> Â  Â | </span><span class="c0 c5">static</span><span class="c2"><br> Â  Â | </span><span class="c0 c5">typedef</span><span class="c2"><br> Â  Â ;<br></span><span class="c28 c2"><br></span><span class="c2"><br> </span><a href="#" name="id.becabfpst9n7"></a><span class="c2 c5">IDENTIFIER_START:</span><span class="c2"><br> Â  Â  Â IDENTIFIER_START_NO_DOLLAR<br> Â  Â | &#39;$&#39;<br> Â  Â ;<br><br></span><a href="#" name="id.dcqdfpfnuwcu"></a><span class="c2 c5">IDENTIFIER_START_NO_DOLLAR:</span><span class="c2"><br> Â  Â  Â LETTER<br> Â  Â | &#39;_&#39;<br> Â  Â ;<br><br> </span><a href="#" name="id.mwwr4imbfjxy"></a><span class="c2 c5">IDENTIFIER_PART_NO_DOLLAR:</span><span class="c2"><br> Â  Â  Â IDENTIFIER_START_NO_DOLLAR<br> Â  Â | DIGIT<br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span class="c2"><br></span><a href="#" name="id.v0bgahf2n7x"></a><span class="c2 c5">IDENTIFIER_PART:</span><span class="c2"><br> Â  Â  Â IDENTIFIER_START<br> Â  Â | DIGIT<br> Â  Â ;<br><br><br><br></span><a href="#" name="id.xsv95i3z7eli"></a><span class="c2 c5">qualified:</span><span class="c2"><br> Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2">Â (&#39;.&#39; </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2">)?<br> Â  Â ;</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span>A built-in identifier is one of the identifiers produced by the </span><span>production</span><span>Â </span><span>BUILT_IN_IDENTIFIER. It is a compile-time error if a built-in identifier is used as the declared name of a class, type parameter or type alias. It is a compile-time error to use a built-in identifier other than </span><span class="c0 c5">dynamic </span><span>as a type annotation. </span></p><p class="c8"><span class="c0"></span></p><p class="c13"><span class="c12 c2">Built-in identifiers are identifiers that are used as keywords in Dart, but are not reserved words in Javascript. To minimize incompatibilities when porting Javascript code to Dart, we do not make these into reserved words. A built-in identifier may not be used to name a class or type. Â In other words, they are treated as reserved words when used as types. This eliminates many confusing situations without causing compatibility problems. After all, a Javascript program has no type declarations or annotations so no clash can occur. Â Furthermore, types should begin with an uppercase letter (see the appendix) and so no clash should occur in any Dart user program anyway.</span></p><p class="c8"><span></span></p><p class="c13"><span>Evaluation of an identifier expression </span><span class="c2">e</span><span>Â of the form </span><span class="c2">id</span><span>Â proceeds as follows:</span></p><p class="c13"><span>Let </span><span class="c2">d</span><span>Â be the innermost declaration in the enclosing lexical scope whose name is </span><span class="c2">id. </span><span>Â If no such declaration exists in the lexical scope, let </span><span class="c2">d</span><span>Â be the declaration of the inherited </span><span>member</span><span>Â named </span><span class="c2">id</span><span>Â if it exists. </span></p><p class="c8"><span></span></p><ol class="c16" start="1"><li class="c9"><span>If </span><span class="c2">d</span><span>Â is a class or type alias </span><span class="c2">T</span><span>, the value of </span><span class="c2">e</span><span>Â is the unique instance of class </span><span class="c0">Type</span><span>Â reifying </span><span class="c2">T</span><span>. </span><span class="c2">This feature is not fully supported in the M2 release.</span></li><li class="c9"><span>If </span><span class="c2">d</span><span>Â is a type parameter </span><span class="c2">T</span><span>, then the value of </span><span class="c2">e</span><span>Â is the value of the actual type argument corresponding to </span><span class="c2">T</span><span>Â that was Â passed to the generative constructor that created the current binding of </span><span class="c0 c5">this</span><span>. </span><span class="c3">We are assured that </span><span class="c0 c3 c5">this</span><span class="c3">Â is well defined, because if we were in a static member the reference to </span><span class="c3 c2">T</span><span class="c3">Â would be a </span><span class="c6"><a class="c4" href="#id.64iudgj9wjj1">compile-time error</a></span><span class="c3">.</span></li></ol><ol class="c16" start="1"><li class="c9"><span>If </span><span class="c2">d</span><span>Â is a library variable then:</span></li></ol><ol class="c39" start="1"><li class="c11 c30"><span>If d is of one of the forms </span><span class="c0 c2 c5">var</span><span class="c0 c2">Â v = e</span><span class="c10 c0 c2">i</span><span class="c0 c2">; , T v = e</span><span class="c10 c0 c2">i</span><span class="c0 c2">; , </span><span class="c0 c2 c5">final</span><span class="c0 c2">Â v = e</span><span class="c10 c0 c2">i</span><span class="c0 c2">;</span><span>Â </span><span class="c0 c2">,</span><span>Â </span><span class="c0 c2 c5">final</span><span class="c0 c2">Â T v = e</span><span class="c10 c0 c2">i</span><span class="c0 c2">;</span><span>Â </span><span class="c0">,</span><span>Â and no value has yet been stored into </span><span class="c2">v</span><span>Â then the initializer expression </span><span class="c0 c2">e</span><span class="c10 c0 c2">i</span><span>Â is evaluated. If, during the evaluation of </span><span class="c2">e</span><span class="c1">i</span><span>, the getter for </span><span class="c2">v</span><span>Â is referenced, a </span><span class="c0">CyclicInitializationError</span><span>Â is thrown. If the evaluation succeeded yielding an object </span><span class="c2">o</span><span>, let </span><span class="c2">r = o,</span><span>Â otherwise let </span><span class="c2">r = </span><span class="c0 c2">null</span><span class="c2">.</span><span>Â In any case, </span><span class="c2">r</span><span>Â is stored into </span><span class="c2">v.</span><span>Â The value of </span><span class="c2">e</span><span>Â is </span><span class="c2">r. </span></li><li class="c11 c30"><span>If </span><span class="c2">d</span><span>Â is of one of the forms </span><span class="c0 c2 c5">const</span><span class="c0 c2">Â v = e;</span><span>Â or </span><span class="c0 c2 c5">const</span><span class="c0 c2">Â T v = e;</span><span>Â the result of the getter is the value of the compile time constant </span><span class="c0 c2">e</span><span>. Otherwise</span></li><li class="c11 c30"><span class="c2">e</span><span>Â evaluates to the current binding of </span><span class="c2">id.</span><span>Â  </span></li></ol><ol class="c16" start="2"><li class="c9"><span>If </span><span class="c2">d</span><span>Â is a local variable or formal parameter then </span><span class="c2">e</span><span>Â evaluates to the current binding of </span><span class="c2">id.</span><span>Â  </span></li><li class="c9"><span>If </span><span class="c2">d</span><span>Â is a static method, top level function or local function then </span><span class="c2">e</span><span>Â evaluates to the function defined by </span><span class="c2">d.</span></li></ol><ol class="c16" start="1"><li class="c9"><span>If </span><span class="c2">d</span><span>Â is the declaration of a static variable or static getter declared in class </span><span class="c2">C,</span><span>Â then </span><span class="c2">e</span><span>Â is equivalent to the </span><span class="c7"><a class="c4" href="#id.lharm2td3qkb">getter invocation</a></span><span>Â </span><span class="c2">C.id. </span></li><li class="c9"><span>If </span><span class="c2">d</span><span>Â is the declaration of a top level getter, then </span><span class="c2">e</span><span>Â is equivalent to the </span><span class="c7"><a class="c4" href="#id.lharm2td3qkb">getter invocation</a></span><span>Â </span><span class="c2">id. </span></li><li class="c9"><span>Otherwise, if </span><span class="c2">e </span><span>occurs inside a top level or static function (be it function, method, getter, Â or setter) or variable initializer, evaluation of </span><span class="c2">e </span><span>causes a </span><span class="c0">NoSuchMethodError</span><span>Â to be thrown.</span></li><li class="c9"><span>Otherwise </span><span class="c2">e</span><span>Â is equivalent to the </span><span class="c7"><a class="c4" href="#id.hu9dfddw6bhy">property extraction</a></span><span>Â  </span><span class="c0 c5">this</span><span class="c2">.id. </span></li></ol><p class="c8"><span></span></p><p class="c13"><span>It is as static warning if an identifier expression of the form </span><span class="c2">id </span><span>occurs inside a top level or static function (be it function, method, getter, or setter) or variable initializer and there is no </span><span>declaration </span><span class="c2">d</span><span>Â with name </span><span class="c2">id</span><span>Â in the lexical scope</span><span>Â enclosing the expression.</span></p><p class="c8"><span></span></p><a href="#" name="id.8l84oujmjm7p"></a><h3 class="c13"><a name="h.x0ar1hv8tolv"></a><span>Type Test</span></h3><p class="c8"><span></span></p><p class="c13"><span>The </span><span class="c2">is-expression</span><span>Â tests if an object is a member of a type.</span></p><a href="#" name="id.etj4op59hgoi"></a><p class="c13"><span class="c2 c5">typeTest:</span></p><p class="c13"><span>Â  </span><span class="c2">isOperator type</span></p><p class="c13"><span>;</span></p><p class="c8"><span></span></p><a href="#" name="id.j4kla99osbuu"></a><p class="c13"><span class="c2 c5">isOperator:</span><span class="c2"><br></span><span class="c0 c5">is</span><span class="c2">Â </span><span class="c2">&#39;!&#39;</span><span class="c2">?<br> Â  Â ;<br></span></p><p class="c13"><span>Evaluation of the is-expression </span><span class="c2">e</span><span>Â </span><span class="c0 c5">is</span><span>Â </span><span class="c2">T</span><span>Â proceeds as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>The expression </span><span class="c2">e</span><span>Â is evaluated to a value </span><span class="c2">v.</span><span>Â Then, if the interface of the class of </span><span class="c2">v</span><span>Â is a subtype of </span><span class="c2">T,</span><span>Â the is-expression evaluates to </span><span class="c0 c5">true.</span><span>Â Otherwise it evaluates to </span><span class="c0 c5">false.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">It follows that </span><span class="c0 c3 c2">e</span><span class="c0 c3">Â </span><span class="c0 c3 c5">is</span><span class="c0 c3">Â </span><span class="c0 c3">Object</span><span class="c3">Â is always true. This makes sense in a language where everything is an object. </span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">Also note that </span><span class="c3 c5">null</span><span class="c3">Â </span><span class="c0 c3 c5">is</span><span class="c0 c3">Â </span><span class="c0 c3 c2">T</span><span class="c0 c3">Â </span><span class="c3">is false unless </span><span class="c3 c2">T = </span><span class="c0 c3">Object</span><span class="c3">, </span><span class="c3 c2">T = </span><span class="c0 c3 c5">dynamic</span><span class="c0 c3">Â </span><span class="c3">or </span><span class="c3 c2">T = </span><span class="c0 c3">Null</span><span class="c3">. Since the class Null is not exported by the core library, the latter will not occur in user code. The former two are useless, as is anything of the form </span><span class="c0 c3 c2">e</span><span class="c0 c3">Â </span><span class="c0 c3 c5">is</span><span class="c0 c3">Â Object </span><span class="c3">or</span><span class="c0 c3">Â </span><span class="c0 c3 c2">e</span><span class="c0 c3">Â </span><span class="c0 c3 c5">is</span><span class="c0 c3">Â </span><span class="c0 c3 c5">dynamic</span><span class="c0 c3">.</span><span class="c3">Â  Users should test for a null value directly rather than via a type test on </span><span class="c0 c3">Object</span><span class="c3">.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span>The is-expression </span><span class="c2">e</span><span>Â </span><span class="c0 c5">is!</span><span>Â </span><span class="c2">T</span><span>Â is equivalent to the expression </span><span class="c0">!(</span><span class="c0 c2">e</span><span class="c0">Â </span><span class="c0 c5">is</span><span class="c0">Â </span><span class="c0 c2">T</span><span class="c0">).</span></p><p class="c13"><span>It is a run-time error if </span><span class="c2">T</span><span>Â does not denote a type available in the current lexical scope. It is a compile-time error if </span><span class="c2">T </span><span>is a parameterized type of the form </span><span class="c2">G&lt;T</span><span class="c1">1</span><span class="c2">, .., T</span><span class="c1">n</span><span class="c2">&gt;</span><span>Â and </span><span class="c2">G</span><span>Â is not a generic type with </span><span class="c2">n</span><span>Â type parameters.</span></p><p class="c8"><span></span></p><p class="c13"><span>Note, that, in checked mode, it is a dynamic type error if a malformed typed is used in a type test as specified </span><span class="c7"><a class="c4" href="#id.xmnezjjgjrld">below</a></span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a static warning if </span><span class="c2">T</span><span>Â does not denote a type available in the current lexical scope. The static type of an is-expression is </span><span class="c0">bool.</span></p><p class="c8"><span class="c0"></span></p><p class="c8"><span class="c0"></span></p><a href="#" name="id.y1kn7e2pvkf4"></a><h2 class="c13"><a name="h.4pppxtxtu3v2"></a><span>Type Cast</span></h2><p class="c8"><span></span></p><p class="c13"><span>The </span><span class="c2">cast-expression</span><span>Â ensures that an object is a member of a type.</span></p><p class="c8"><span class="c2 c5"></span></p><a href="#" name="id.pjkdsymsshxy"></a><p class="c13"><span class="c2 c5">typeCast</span><span class="c2 c5">:</span></p><p class="c13"><span>Â  </span><span class="c2">asOperator type</span></p><p class="c13"><span>;</span></p><p class="c8"><span></span></p><a href="#" name="id.ys7f1mb1ntkp"></a><p class="c13"><span class="c2 c5">asOperator:</span><span class="c2"><br></span><span class="c0 c5">a</span><span class="c0 c5">s</span><span class="c2">Â </span><span class="c2"><br> Â  Â ;<br></span></p><p class="c13"><span>Evaluation of the cast expression </span><span class="c2">e</span><span>Â </span><span class="c0 c5">as</span><span>Â </span><span class="c2">T</span><span>Â proceeds as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>The expression </span><span class="c2">e</span><span>Â is evaluated to a value </span><span class="c2">v.</span><span>Â Then, if the interface of the class of </span><span class="c2">v</span><span>Â is a subtype of </span><span class="c2">T,</span><span>Â the cast-expression evaluates to </span><span class="c2">v. </span><span>Otherwise, if </span><span class="c2">v</span><span>Â is </span><span class="c0 c5">null</span><span>, the cast-expression evaluates to </span><span class="c2">v</span><span>. Â In all other cases, Â a </span><span class="c0">CastError</span><span>Â </span><span>is thrown.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a run-time error if </span><span class="c2">T</span><span>Â does not denote a type available in the current lexical scope. It is a compile-time error if </span><span class="c2">T </span><span>is a parameterized type of the form </span><span class="c2">G&lt;T</span><span class="c1">1</span><span class="c2">, .., T</span><span class="c1">n</span><span class="c2">&gt;</span><span>Â and </span><span class="c2">G</span><span>Â is not a generic type with </span><span class="c2">n</span><span>Â type parameters.</span></p><p class="c8"><span></span></p><p class="c13"><span>Note, that, in checked mode, it is a dynamic type error if a malformed typed is used in a type cast as specified </span><span class="c7"><a class="c4" href="#id.xmnezjjgjrld">below</a></span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a static warning if </span><span class="c2">T</span><span>Â does not denote a type available in the current lexical scope. The static type of a cast expression </span><span class="c2">e</span><span>Â </span><span class="c0 c5">as</span><span>Â </span><span class="c2">T </span><span>is</span><span>Â </span><span class="c2">T</span><span>.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.o0w0gbeh8j5q"></a><h2 class="c13"><a name="h.mbzyefis3od1"></a><span class="c27">Argument Definition Test</span></h2><p class="c8"><span class="c27 c5"></span></p><p class="c13"><span>An </span><span class="c2">argument definition test</span><span>Â is an expression that tests whether a formal parameter is bound to an object explicitly passed to a method or function.</span></p><p class="c8"><span></span></p><a href="#" name="id.e295wdblj6pq"></a><p class="c13"><span class="c2 c5">argumentDefinitionTest:<br></span><span class="c2">Â  Â â?â identifier<br> Â  Â ;<br></span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>An argument definition test </span><span class="c2">e</span><span>Â of the form </span><span class="c0">?v</span><span>Â  evaluates to </span><span class="c0 c5">true</span><span>Â iff the currently executing invocation of the function that declares </span><span class="c0">v</span><span>Â explicitly provided an argument for the formal parameter </span><span class="c0">v</span><span>; otherwise </span><span class="c2">e</span><span>Â evaluates to </span><span class="c0 c5">false</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile time error if </span><span class="c0">v</span><span>Â does not denote a </span><span>formal parameter</span><span>. The static type of an argument definition test is </span><span class="c0">bool</span><span>.</span></p><p class="c8"><span></span></p><p class="c8"><span class="c0 c18"></span></p><a href="#" name="id.u641de9n8yy"></a><h2 class="c13"><a name="h.hqr7euivxf2k"></a><span>Statements</span></h2><p class="c8"><span></span></p><a href="#" name="id.mfp056u1wxhj"></a><p class="c13"><span class="c2 c5">statements:</span><span class="c2"><br> Â  Â  Â statement*<br> Â  Â ;<br></span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.qxr443r6wu5w"></a><p class="c13"><span class="c2 c5">statement:</span><span class="c2"><br> Â  Â  Â label* nonLabelledStatement<br> Â  Â ;<br><br></span><a href="#" name="id.2dzd2wull4bz"></a><span class="c2 c5">nonLabelledStatement:</span><span class="c2"><br> Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#kix.kx7urn183i41">block</a></span><span class="c2">Â </span></p><p class="c13"><span class="c2">Â  Â  | </span><span class="c6 c2"><a class="c4" href="#id.3w5sf7ft3qq9">localVariableDeclaration</a></span><span class="c2">Â &#39;;&#39;<br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.j9iezeasgfnv">forStatement</a></span></p><p class="c13"><span class="c2">Â  Â  | </span><span class="c6 c2"><a class="c4" href="#id.b80lsgnffs3l">whileStatement</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.kghbfwy46xn3">doStatement</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.24iylhdjyza7">switchStatement</a></span></p><p class="c13"><span class="c2">Â  Â  | </span><span class="c6 c2"><a class="c4" href="#id.vkbrdfhx12yq">ifStatement</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.oz9orks2j6lc">tryStatement</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.xweryammo2zi">breakStatement</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.ia1g5wsdvip7">continueStatement</a></span></p><p class="c13"><span class="c2">Â  Â  | </span><span class="c6 c2"><a class="c4" href="#id.vdmucwmxk5sb">returnStatement</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.g07b8yer9ws5">expressionStatement</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.rszxnavlorex">assertStatement</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.f3xfjsjv5oad">localFunctionDeclaration</a></span><span class="c2"><br> Â  Â ;<br></span></p><p class="c8"><span class="c2"></span></p><h3 class="c13"><a name="h.cl7xuoqlaaeh"></a><span>Blocks</span></h3><p class="c8"><span></span></p><p class="c13"><span>A block statement supports sequencing of code.</span></p><p class="c8"><span></span></p><p class="c13"><span>Execution of a block statement </span><span class="c2">{s</span><span class="c1">1</span><span class="c2">Â â¦ Â s</span><span class="c1">n</span><span class="c2">}</span><span>Â proceeds as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>For </span><span class="c2">i = 1 .. n,</span><span>Â </span><span class="c2">s</span><span class="c1">i</span><span class="c22">Â </span><span>is executed.</span></p><p class="c8"><span></span></p><h3 class="c13"><a name="h.xqzpebdcgm4"></a><span>Expression Statements</span></h3><p class="c8"><span></span></p><p class="c13"><span>An expression statement consists of an expression that does not begin with a non-constant </span><span class="c6"><a class="c4" href="#id.riie55qjrb82">map literal</a></span><span>Â that has no explicit type arguments. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">The restriction on maps is designed to resolve an ambiguity in the grammar, when a statement begins with {.</span></p><p class="c8"><span></span></p><a href="#" name="id.g07b8yer9ws5"></a><p class="c13"><span class="c2 c5">expressionStatement:</span></p><p class="c13"><span class="c2">Â  </span><span class="c6 c2"><a class="c4" href="#id.1u3vxuwrz6py">expression</a></span><span class="c2">? &#39;;&#39;<br></span></p><p class="c13"><span>Execution of an expression statement </span><span class="c0 c2">e</span><span class="c0">; </span><span>proceeds by evaluating </span><span class="c2">e.</span><span>Â </span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error if a </span><span>non-constant map literal</span><span>Â that has no explicit type arguments appears in a place where a statement is expected.</span></p><p class="c8"><span></span></p><p class="c8"><span><br></span><span class="c2"><br></span></p><h3 class="c13"><a name="h.w2e1gboc13um"></a><a href="#" name="id.pj2yk2bhjoki"></a><span>Local Variable Declaration</span></h3><p class="c8"><span></span></p><p class="c13"><span>A </span><span class="c2">variable declaration statement</span><span>Â declares a new local variable.</span></p><p class="c8"><span></span></p><a href="#" name="id.3w5sf7ft3qq9"></a><p class="c13"><span class="c2 c5">localVariableDeclaration:</span></p><p class="c13"><span class="c2">Â  Â  Â initializedVariableDeclaration &#39;;&#39;</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span>Executing a variable declaration statement of one of the forms </span><span class="c0 c2 c5">var</span><span class="c2">Â v = e;, T v = e;</span><span>, </span><span class="c0 c2 c5">const </span><span class="c2">v = e; , </span><span class="c0 c2 c5">const</span><span>Â </span><span class="c2">T v = e;, </span><span class="c0 c2 c5">final </span><span class="c2">v = e;</span><span>Â or</span><span class="c2">Â </span><span class="c0 c2 c5">final </span><span class="c2">T v = e; </span><span>proceeds as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>The expression </span><span class="c2">e</span><span>Â is evaluated to an object </span><span class="c2">o</span><span>. Then, the variable </span><span class="c2">v</span><span>Â is set to </span><span class="c2">o</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>A variable declaration statement of the form </span><span class="c0 c2 c5">var</span><span class="c2">Â v;</span><span>Â is equivalent to </span><span class="c0 c2 c5">var</span><span class="c2">Â v = null;</span><span>.</span></p><p class="c13"><span>A variable declaration statement of the form </span><span class="c2">T v;</span><span>Â is equivalent to </span><span class="c2">T v = null;</span><span>. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">This holds regardless of the type T. For example,</span><span class="c0 c3">Â int i;</span><span class="c3">Â does not cause </span><span class="c0 c3">i</span><span class="c3">Â to be initialized to zero. Instead, </span><span class="c0 c3">i</span><span class="c3">Â is initialized to </span><span class="c0 c3 c5">null</span><span class="c3">, just as if we had written </span><span class="c0 c3 c5">var</span><span class="c0 c3">Â i;</span><span class="c3">Â or </span><span class="c0 c3">Object i;</span><span class="c3">Â or </span><span class="c0 c3">Collection&lt;String&gt; i;</span></p><p class="c13"><span class="c12 c2">To do otherwise would undermine the optionally typed nature of Dart, causing type annotations to modify program behavior.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error if </span><span class="c2">e</span><span>Â refers to the name </span><span class="c2">v </span><span>or the name </span><span class="c2">v=.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">This rule may seem redundant in light of the scoping rules above. After all: </span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c0 c3">f() { // a top level function</span></p><p class="c13"><span class="c0 c3 c5">Â  var</span><span class="c0 c3">Â v = v* 2;</span></p><p class="c13"><span class="c0 c3">}</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">is already an error since </span><span class="c3 c2">v</span><span class="c3">Â is not yet in scope in its own initializer. However, consider the more insidious:</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c0 c3 c5">var</span><span class="c0 c3">Â v = 0; // top level variable </span></p><p class="c13"><span class="c0 c3">f() { // a top level function</span></p><p class="c13"><span class="c0 c3">Â  </span><span class="c0 c3 c5">var</span><span class="c0 c3">Â v = v* 2; // compile-time error</span></p><p class="c13"><span class="c0 c3">}</span></p><p class="c8"><span class="c3"></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.cvqb48le1je"></a><h3 class="c13"><a name="h.4o2dnbvusvi5"></a><span>Local Function Declaration</span></h3><p class="c8"><span></span></p><p class="c13"><span>A function declaration statement declares a new local function. </span></p><p class="c8"><span></span></p><a href="#" name="id.f3xfjsjv5oad"></a><p class="c13"><span class="c2 c5">localFunctionDeclaration:</span><span class="c2"><br> Â  Â  </span><span class="c6 c2"><a class="c4" href="#id.7ttlaph5nhkh">functionSignature</a></span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.twypn7sgnd3j">functionBody</a></span><span class="c2"><br> Â  Â ;<br></span></p><p class="c13"><span>A function declaration statement of one of the forms </span><span class="c2">id signature {statements}</span><span>Â or </span><span class="c2">T id signature {statements}</span><span>Â causes a new function named </span><span class="c2">id</span><span>Â to be added to the innermost enclosing scope at the point immediately following the function declaration statement.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">As for all function declarations, the function is also made available under its name in the functionâs formal parameters scope.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">This implies that local functions can be directly recursive, but not mutually recursive. Consider these examples:</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c0 c3">top() { // a top level function </span></p><p class="c13"><span class="c0 c3">Â  f(x) =&gt; x &gt; 0? x*f(x-1): 1; // recursion is legal </span></p><p class="c13"><span class="c0 c3">Â  g1(x) =&gt; h(x, 1); // error: h is not in scope yet </span></p><p class="c13"><span class="c0 c3">Â  h(x, n) =&gt; x &gt; 1? h(x-1, n*x): n; // again, recursion is fine</span></p><p class="c13"><span class="c0 c3">Â  g2(x) =&gt; h(x, 1); // legal </span></p><p class="c13"><span class="c0 c3">Â  p1(x) =&gt; q(x,x); // illegal </span></p><p class="c13"><span class="c0 c3">Â  q1(a, b) =&gt; a &gt; 0 ? p1(a-1): b; // fine </span></p><p class="c13"><span class="c0 c3">Â  q2(a, b) =&gt; a &gt; 0 ? p2(a-1): b; // illegal </span></p><p class="c13"><span class="c0 c3">Â  p1(x) =&gt; q2(x,x); // fine</span></p><p class="c13"><span class="c0 c3">}</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">There is no way to write a pair of mutually recursive local functions, because one always has to come before the other is in scope. These cases are quite rare, and can always be managed by defining a pair of variables first, then assigning them appropriate closures:</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c0 c3">top2() { // a top level function </span></p><p class="c13"><span class="c0 c3">Â  </span><span class="c0 c3 c5">var</span><span class="c0 c3">Â p, q;</span></p><p class="c13"><span class="c0 c3">Â  p = (x) =&gt; q(x,x); // illegal </span></p><p class="c13"><span class="c0 c3">Â  q = (a, b) =&gt; a &gt; 0 ? p(a-1): b; // fine</span></p><p class="c13"><span class="c0 c3">}</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.bi8elx882av"></a><h3 class="c13"><a name="h.e62bkwgzzagn"></a><span>If</span></h3><p class="c8"><span></span></p><p class="c13"><span>The </span><span class="c2">if statement</span><span>Â allows for conditional execution of statements.</span></p><p class="c8"><span></span></p><a href="#" name="id.vkbrdfhx12yq"></a><p class="c13"><span class="c2 c5">ifStatement:</span><span class="c2"><br> Â  Â  Â </span><span class="c0 c5">if</span><span class="c2">Â &#39;(&#39; </span><span class="c6 c2"><a class="c4" href="#id.1u3vxuwrz6py">expression</a></span><span class="c2">Â &#39;)&#39; </span><span class="c6 c2"><a class="c4" href="#id.qxr443r6wu5w">statement</a></span><span class="c2">Â (</span><span class="c0 c5">else</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.qxr443r6wu5w">statement</a></span><span class="c2">)?<br> Â  Â ;<br></span></p><p class="c13"><span>Execution of an if statement of the form </span><span class="c0 c5">if</span><span class="c0">(</span><span class="c2">b</span><span class="c0">)</span><span class="c2">Â s</span><span class="c1">1</span><span class="c2">Â </span><span class="c0 c5">else</span><span class="c0">Â </span><span class="c2">s</span><span class="c1 c5">2</span><span>Â proceeds as follows:</span></p><p class="c13"><span class="c2">Â </span></p><p class="c13"><span>First, the expression </span><span class="c2">b </span><span>is evaluated to</span><span>Â </span><span>an object </span><span class="c2">o.</span><span>Â In checked mode, it is a dynamic type error if </span><span class="c2">o </span><span>is not of type </span><span class="c0">bool. </span><span>Otherwise, </span><span class="c2">o</span><span>Â is</span><span>Â then subjected to </span><span class="c7"><a class="c4" href="#id.luoug0f1vx2f">boolean conversion</a></span><span>, producing an object </span><span class="c2">r</span><span>. </span><span class="c2">Â </span><span>If </span><span class="c2">r </span><span>is </span><span class="c0 c5">true</span><span>, then the statement </span><span class="c2">s</span><span class="c1">1</span><span>Â is executed, otherwise statement </span><span class="c2">s</span><span class="c1">2</span><span>Â is executed.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span class="c2">Â </span><span>It is a static type warning if the type of the expression </span><span class="c2">b</span><span>Â may not be assigned to bool. </span><span class="c2">Â </span></p><p class="c13"><span class="c2">Â  </span></p><p class="c13"><span>Â An if statement of the form Â </span><span class="c0 c5">if</span><span>Â </span><span class="c0">(</span><span class="c2">b</span><span class="c0">)</span><span class="c2">Â s</span><span class="c1">1</span><span>Â is equivalent to the if statement </span><span class="c0 c5">if</span><span class="c0">(</span><span class="c2">b</span><span class="c0">)</span><span class="c2">Â s</span><span class="c1">1</span><span class="c2">Â </span><span class="c0 c5">else</span><span class="c0">Â {}</span><span class="c2">.</span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.nleo13o1ua6q"></a><h3 class="c13"><a name="h.phf2izoilhq7"></a><span>For</span></h3><p class="c8"><span></span></p><p class="c13"><span>The </span><span class="c2">for statement </span><span>supports iteration.</span></p><p class="c8"><span></span></p><a href="#" name="id.j9iezeasgfnv"></a><p class="c13"><span class="c2 c5">forStatement:</span><span class="c2"><br> Â  Â  </span><span class="c0 c5">for</span><span class="c2">Â &#39;(&#39; forLoopParts &#39;)&#39; </span><span class="c6 c2"><a class="c4" href="#id.qxr443r6wu5w">statement</a></span><span class="c2"><br> Â  Â ;</span></p><p class="c13"><span class="c2"><br></span><a href="#" name="id.ucs74xojg1ca"></a><span class="c2 c5">forLoopParts:</span><span class="c2"><br> Â  Â  Â forInitializerStatement </span><span class="c6 c2"><a class="c4" href="#id.1u3vxuwrz6py">expression</a></span><span class="c2">? &#39;;&#39; expressionList?<br> Â  Â | </span><span class="c7 c2"><a class="c4" href="#id.2xe95ykmes0u">declaredIdentifier</a></span><span class="c2">Â </span><span class="c0 c5">in</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.1u3vxuwrz6py">expression</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2">Â </span><span class="c0 c5">in</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.1u3vxuwrz6py">expression</a></span><span class="c2"><br> Â  Â ;<br><br></span><a href="#" name="id.318qfu71lbqa"></a><span class="c2 c5">forInitializerStatement:</span><span class="c2"><br> Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#id.3w5sf7ft3qq9">localVariableDeclaration</a></span><span class="c2">Â &#39;;&#39;<br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.1u3vxuwrz6py">expression</a></span><span class="c2">? &#39;;&#39;<br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>The for statement has two forms - the traditional for loop and the foreach statement.</span></p><p class="c8"><span></span></p><a href="#" name="id.7ych0h3g6q1o"></a><h4 class="c13"><a name="h.30cq61pcbhlr"></a><span>For Loop</span></h4><p class="c8"><span></span></p><p class="c13"><span>Execution of a for statement of the form Â </span><span class="c0 c5">for</span><span class="c0">Â (</span><span class="c0 c5">var</span><span class="c0 c2">Â </span><span class="c0 c2">v = e</span><span class="c1 c0">0</span><span class="c1 c0">Â </span><span class="c0 c2">; c e</span><span class="c0">) </span><span class="c0 c2">s</span><span>Â proceeds as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>If </span><span class="c2">c</span><span>Â is empty let </span><span class="c2">câ</span><span>Â be true, otherwise let </span><span class="c2">câ</span><span>Â be </span><span class="c2">c. </span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>First the variable declaration statement </span><span class="c0 c5">var</span><span class="c0 c2">Â v = e</span><span class="c1 c0">0 </span><span>Â is executed. Then:</span></p><ol class="c20" start="1"><li class="c9"><span>If this is the first iteration of the for loop, let </span><span class="c2">vâ</span><span>Â be </span><span class="c2">v.</span><span>Â Otherwise, Â let </span><span class="c2">vâ</span><span>Â be the variable </span><span class="c2">vââ</span><span>Â created in the previous execution of step 4.</span></li><li class="c9"><span>The expression </span><span class="c2">[vâ/v]c</span><span>Â is evaluated and subjected to boolean conversion. If the result is </span><span class="c0 c5">false</span><span>, the for loop completes. Otherwise, execution continues at step 3.</span></li><li class="c9"><span>The statement </span><span class="c2">[vâ/v]s</span><span>Â is executed.</span></li><li class="c9"><span>Let vââ be a fresh variable. Â vââ is bound to the value of vâ.</span></li><li class="c9"><span>The expression [vââ/v]e is evaluated, and the process recurses at step 1.</span></li></ol><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">The definition above is intended to prevent the common error where users create a closure inside a for loop, intending to close over the current binding of the loop variable, and find (usually after a painful process of debugging and learning) that all the created closures have captured the same value - the one current in the last iteration executed.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">Instead, each iteration has its own distinct variable. Â The first iteration uses the variable created by the initial declaration. The expression executed at the end of each iteration uses a fresh variable vââ, bound to the value of the current iteration variable, and then modifies $vââ as required for the next iteration.</span></p><p class="c8"><span></span></p><a href="#" name="id.w7rqryp9rxgm"></a><h4 class="c13"><a name="h.7l7e185heu0v"></a><span>For</span><span>-in</span></h4><p class="c13"><span>A for statement of the form Â </span><span class="c0 c5">for</span><span class="c0">Â (</span><span class="c0 c2">varOrType?</span><span class="c0">Â id </span><span class="c0 c5">in</span><span class="c0">Â </span><span class="c0 c2">e</span><span class="c0">) </span><span class="c0 c2">s</span><span>Â is equivalent to the following code:</span></p><p class="c8"><span></span></p><p class="c13"><span class="c0">var n0 = e.iterator();</span></p><p class="c13"><span class="c0 c5">while</span><span class="c0">Â (n0.hasNext) {</span></p><p class="c13"><span class="c0">Â  Â </span><span class="c0 c2">varOrType?</span><span class="c0 c5">Â </span><span class="c0">id = n0.next();</span></p><p class="c13"><span class="c0">Â  Â s</span></p><p class="c13"><span class="c0">}</span></p><p class="c13"><span>where </span><span class="c0">n0</span><span>Â is an identifier that does not occur anywhere in the program.<br></span></p><a href="#" name="id.e6iow4tlr5al"></a><h3 class="c13"><a name="h.4t8k3tvkyul3"></a><span>While</span></h3><p class="c8"><span></span></p><p class="c13"><span>The </span><span class="c2">while statement</span><span>Â supports conditional iteration, where the condition is evaluated prior to the loop.</span></p><p class="c8"><span></span></p><a href="#" name="id.b80lsgnffs3l"></a><p class="c13"><span class="c2 c5">whileStatement:</span><span class="c2"><br> Â  Â  Â </span><span class="c0 c5">while</span><span class="c2">Â &#39;(&#39; </span><span class="c6 c2"><a class="c4" href="#id.1u3vxuwrz6py">expression</a></span><span class="c2">Â &#39;)&#39; </span><span class="c6 c2"><a class="c4" href="#id.qxr443r6wu5w">statement</a></span><span class="c2">Â  </span></p><p class="c13"><span class="c2">;</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>Execution of a while statement of the form </span><span class="c0 c5">while</span><span class="c2">Â </span><span class="c0">(</span><span class="c2">e</span><span class="c0">)</span><span class="c2">Â s</span><span class="c0">;</span><span>Â proceeds as follows: </span></p><p class="c8"><span></span></p><p class="c13"><span>The expression </span><span class="c2">e</span><span>Â is evaluated to an object </span><span class="c2">o.</span><span>Â In checked mode, it is a dynamic type error if </span><span class="c2">o </span><span>is not of type </span><span class="c0">bool. </span><span>Otherwise, </span><span class="c2">o</span><span class="c0">Â </span><span>is subjected to </span><span class="c7"><a class="c4" href="#id.luoug0f1vx2f">boolean conversion</a></span><span>, producing an object </span><span class="c2">r</span><span>. Â If </span><span class="c2">r</span><span>Â is </span><span class="c0 c5">true</span><span>, then </span><span class="c2">s</span><span>Â is executed and then the while statement is re-executed recursively. If </span><span class="c2">r</span><span>Â is </span><span class="c0 c5">false</span><span>, execution of the while statement is complete.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a static type warning if the type of </span><span class="c2">e </span><span>may not be assigned to </span><span class="c0">bool.</span><span>Â </span></p><p class="c13"><span>Â </span></p><a href="#" name="id.17r82ed5p6yq"></a><h3 class="c13"><a name="h.vj4ainfqsbwg"></a><span>Do</span></h3><p class="c8"><span></span></p><p class="c13"><span>The </span><span class="c2">do statement</span><span>Â supports conditional iteration, where the condition is evaluated after the loop.</span></p><p class="c8"><span></span></p><a href="#" name="id.kghbfwy46xn3"></a><p class="c13"><span class="c2 c5">doStatement:</span><span class="c2"><br> Â  Â </span><span class="c0 c5">do</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.qxr443r6wu5w">statement</a></span><span class="c2">Â </span><span class="c0 c5">while</span><span class="c2">Â &#39;(&#39; </span><span class="c6 c2"><a class="c4" href="#id.1u3vxuwrz6py">expression</a></span><span class="c2">Â &#39;)&#39; &#39;;&#39;<br> Â  Â  Â ;<br></span></p><p class="c13"><span>Execution of a do statement of the form </span><span class="c0 c5">do</span><span class="c2">Â s </span><span class="c0 c5">while</span><span class="c2">Â </span><span class="c0">(</span><span class="c2">e</span><span class="c0">);</span><span>Â proceeds as follows: </span></p><p class="c8"><span></span></p><p class="c13"><span>The statement s is executed. Then, the expression </span><span class="c2">e</span><span>Â is evaluated to an object </span><span class="c2">o.</span><span>Â In checked mode, it is a dynamic type error if </span><span class="c2">o </span><span>is not of type </span><span class="c0">bool. </span><span>Otherwise, </span><span class="c2">o</span><span class="c0">Â </span><span>is then subjected to </span><span class="c7"><a class="c4" href="#id.luoug0f1vx2f">boolean conversion</a></span><span>, producing an object </span><span class="c2">r</span><span>. If </span><span class="c2">r</span><span>Â is </span><span class="c0 c5">false</span><span>, execution of the do statement is complete. If </span><span class="c2">r</span><span>Â is </span><span class="c0 c5">true</span><span>, then the do statement is re-executed recursively. </span></p><p class="c8"><span></span></p><p class="c13"><span>It is a static type warning if the type of </span><span class="c2">e can</span><span>not be</span><span>Â assigned to </span><span class="c0">bool.</span><span>Â  </span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.9tgfidrdlcan"></a><h3 class="c13"><a name="h.50ae78s6gbw2"></a><span>Switch</span></h3><p class="c8"><span></span></p><p class="c13"><span>The </span><span class="c2">switch statement</span><span>Â supports dispatching control among a large number of cases.</span></p><p class="c8"><span></span></p><a href="#" name="id.24iylhdjyza7"></a><p class="c13"><span class="c2 c5">switchStatement:</span><span class="c2"><br> Â  Â  Â </span><span class="c0 c5">switch</span><span class="c2">Â &#39;(&#39; </span><span class="c6 c2"><a class="c4" href="#id.1u3vxuwrz6py">expression</a></span><span class="c2">Â &#39;)&#39; &#39;{&#39; switchCase* </span><span class="c2">defaultCase? </span><span class="c2">&#39;}&#39;<br> Â  Â ;<br></span></p><p class="c8"><span></span></p><a href="#" name="id.meo5bc6x9a9k"></a><p class="c13"><span class="c2 c5">switchCase:</span><span class="c2"><br> Â  Â  Â label* (</span><span class="c0 c5">case</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.k68gukuq6cj9">expression</a></span><span class="c2">Â &#39;:&#39;) </span><span class="c6 c2"><a class="c4" href="#id.mfp056u1wxhj">statements</a></span><span class="c2"><br> Â  Â ;<br><br></span><a href="#" name="id.btml234onbwc"></a><span class="c2 c5">defaultCase:</span><span class="c2"><br> Â  Â  Â label* </span><span class="c0 c5">default</span><span class="c2">Â &#39;:&#39; </span><span class="c6 c2"><a class="c4" href="#id.mfp056u1wxhj">statements</a></span><span class="c2"><br> Â  Â ;<br></span></p><p class="c13"><span>Given a switch statement of the form </span><span class="c0 c5">switch</span><span class="c0">Â (</span><span class="c0 c2">e</span><span class="c0">) { label</span><span class="c10 c0">11</span><span class="c0">Â â¦ label</span><span class="c10 c0">1j1</span><span class="c0">Â </span><span class="c0 c5">case</span><span class="c0">Â </span><span class="c0 c2">e</span><span class="c10 c0 c2">1</span><span class="c0">: </span><span class="c0 c2">s</span><span class="c10 c0 c2">1</span><span class="c0">Â â¦ label</span><span class="c10 c0">n1</span><span class="c0">Â ..label</span><span class="c10 c0">njn </span><span class="c0 c5">case</span><span class="c0">Â </span><span class="c0 c2">e</span><span class="c10 c0 c2">n</span><span class="c0">: </span><span class="c0 c2">s</span><span class="c10 c0 c2">n</span><span class="c0">Â </span><span class="c0 c5">default:</span><span class="c0">Â </span><span class="c0 c2">s</span><span class="c10 c0 c2">n+1</span><span class="c0">}</span><span>Â or the form </span><span class="c0 c5">switch</span><span class="c0">Â (</span><span class="c0 c2">e</span><span class="c0">) { label</span><span class="c10 c0">11</span><span class="c0">Â â¦ label</span><span class="c10 c0">1j1</span><span class="c0">Â </span><span class="c0 c5">case</span><span class="c0">Â </span><span class="c0 c2">e</span><span class="c10 c0 c2">1</span><span class="c0">: </span><span class="c0 c2">s</span><span class="c10 c0 c2">1</span><span class="c0">Â â¦ label</span><span class="c10 c0">n1</span><span class="c0">Â ..label</span><span class="c10 c0">njn </span><span class="c0 c5">case</span><span class="c0">Â </span><span class="c0 c2">e</span><span class="c10 c0 c2">n</span><span class="c0">: </span><span class="c0 c2">s</span><span class="c10 c0 c2">n</span><span class="c0">}, </span><span>i</span><span>t is a compile-time error if the expressions </span><span class="c2">e</span><span class="c10 c2">k</span><span>Â are not compile-time constants, for all 1 &lt;= </span><span class="c2">k</span><span>Â &lt;= </span><span class="c2">n</span><span>. </span><span>It is a compile-time error if values of the expressions </span><span class="c2">e</span><span class="c10 c2">k</span><span>Â are not instances of the same class </span><span class="c2">C</span><span>, for all 1 &lt;= </span><span class="c2">k</span><span>Â &lt;= </span><span class="c2">n</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">In other words,</span><span class="c3">Â </span><span class="c3">all the expressions in the cases evaluate to constants of the exact same class.</span><span class="c3">Â  Note that the values of the expressions are known at compile-time, and are independent of any static type annotations.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span>It is a compile-time error if the class </span><span class="c2">C</span><span>Â implements the operator ==.</span></p><p class="c13"><span class="c12 c2">The prohibition on user defined equality allows us to implement the switch efficiently for user defined types. We could formulate matching in terms of identity instead with the same efficiency. However, if a type defines an equality operator, programmers would find it quite surprising that equal objects did not match.</span></p><p class="c8"><span class="c0"></span></p><p class="c13"><span class="c3">The </span><span class="c0 c3 c5">switch</span><span class="c3">Â statement should only be used in</span><span class="c3">Â very limited situations</span><span class="c3">Â (e.g., interpreters or scanners). In cases where more generality is desired, users can use if statements; eventually, literal maps will be more general, and one may be able to </span><span class="c3">use patterns such as</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c0 c3">{ âaâ: () =&gt; 42</span><span class="c0 c3">;</span><span class="c0 c3">Â âbâ: () =&gt; print(ânot an Aâ); âcâ: () =&gt; foo(1, 2); }[e]();</span><span class="c3">Â </span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">instead of </span><span class="c0 c3 c5">switch</span></p><p class="c8"><span class="c0"></span></p><p class="c13"><span>Execution of a switch statement of the form Â </span><span class="c0 c5">switch</span><span class="c0">Â (</span><span class="c0 c2">e</span><span class="c0">) {label</span><span class="c10 c0">11</span><span class="c0">Â ..label</span><span class="c10 c0">1j1</span><span class="c0">Â </span><span class="c0 c5">case</span><span class="c0">Â </span><span class="c0 c2">e</span><span class="c10 c0 c2">1</span><span class="c0">: </span><span class="c0 c2">s</span><span class="c10 c0 c2">1</span><span class="c0">Â â¦ label</span><span class="c10 c0">n1</span><span class="c0">Â ..label</span><span class="c10 c0">njn </span><span class="c0 c5">case</span><span class="c0">Â </span><span class="c0 c2">e</span><span class="c10 c0 c2">n</span><span class="c0">: </span><span class="c0 c2">s</span><span class="c10 c0 c2">n</span><span class="c0">Â </span><span class="c0 c5">default:</span><span class="c0">Â </span><span class="c0 c2">s</span><span class="c10 c0 c2">n+1</span><span class="c0">}</span><span>Â or the form </span><span class="c0 c5">switch</span><span class="c0">Â (</span><span class="c0 c2">e</span><span class="c0">) { label</span><span class="c10 c0">11</span><span class="c0">Â â¦ label</span><span class="c10 c0">1j1</span><span class="c0">Â </span><span class="c0 c5">case</span><span class="c0">Â </span><span class="c0 c2">e</span><span class="c10 c0 c2">1</span><span class="c0">: </span><span class="c0 c2">s</span><span class="c10 c0 c2">1</span><span class="c0">Â â¦ label</span><span class="c10 c0">n1</span><span class="c0">Â ..label</span><span class="c10 c0">njn </span><span class="c0 c5">case</span><span class="c0">Â </span><span class="c0 c2">e</span><span class="c10 c0 c2">n</span><span class="c0">: </span><span class="c0 c2">s</span><span class="c10 c0 c2">n</span><span class="c0">} </span><span>proceeds as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>The statement </span><span class="c0 c5">var</span><span class="c0">Â </span><span class="c0 c2">id</span><span class="c0">Â = </span><span class="c0 c2">e</span><span class="c0">;</span><span>Â is evaluated, where </span><span class="c2">id </span><span>is a variable whose name is distinct from any other variable in the program. Â In checked mode, it is a run time error if the value of </span><span class="c0 c2">e</span><span>Â is not an instance of the same class as the constants </span><span class="c0 c2">e</span><span class="c10 c0 c2">1</span><span class="c0">Â â¦ </span><span class="c0 c2">e</span><span class="c10 c0 c2">n</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>Next, the case clause </span><span class="c0 c5">case</span><span class="c0">Â </span><span class="c0 c2">e</span><span class="c10 c0 c2">1</span><span class="c0">: </span><span class="c0 c2">s</span><span class="c10 c0 c2">1</span><span>Â is executed if it exists. If </span><span class="c0 c5">case</span><span class="c0">Â </span><span class="c0 c2">e</span><span class="c10 c0 c2">1</span><span class="c0">: </span><span class="c0 c2">s</span><span class="c10 c0 c2">1 </span><span>does not exist, then the default clause is executed by</span><span>Â executing </span><span class="c0 c2">s</span><span class="c10 c0 c2">n+1</span><span class="c0 c2">.</span></p><p class="c8"><span class="c0 c2"></span></p><p class="c13"><span class="c3">Note that if there are no case clauses </span><span class="c3">(</span><span class="c0 c3 c2">n = 0</span><span class="c3">)</span><span class="c3">, the type of </span><span class="c0 c3 c2">e</span><span class="c3">Â does not matter.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span>A case clause introduces a new scope, nested in the lexically surrounding scope. The scope of a case clause ends immediately after the case clauseâs statement.</span></p><p class="c8"><span></span></p><p class="c13"><span>Execution of a </span><span class="c0 c5">case</span><span>Â clause </span><span class="c0 c5">case</span><span class="c0">Â </span><span class="c0 c2">e</span><span class="c10 c0 c2">k</span><span class="c0">: </span><span class="c0 c2">s</span><span class="c10 c0 c2">k</span><span class="c10 c0">Â </span><span>of a switch statement </span><span class="c0 c5">switch</span><span class="c0">Â (</span><span class="c0 c2">e</span><span class="c0">) {label</span><span class="c10 c0">11</span><span class="c0">Â ..label</span><span class="c10 c0">1j1</span><span class="c0">Â </span><span class="c0 c5">case</span><span class="c0">Â </span><span class="c0 c2">e</span><span class="c10 c0 c2">1</span><span class="c0">: </span><span class="c0 c2">s</span><span class="c10 c0 c2">1</span><span class="c0">Â â¦ label</span><span class="c10 c0">n1</span><span class="c0">Â ..label</span><span class="c10 c0">njn </span><span class="c0 c5">case</span><span class="c0">Â </span><span class="c0 c2">e</span><span class="c10 c0 c2">n</span><span class="c0">: </span><span class="c0 c2">s</span><span class="c10 c0 c2">n</span><span class="c0">Â </span><span class="c0 c5">default:</span><span class="c0">Â </span><span class="c0 c2">s</span><span class="c10 c0 c2">n+1</span><span class="c0">} </span><span>proceeds as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>The expression </span><span class="c0 c2">e</span><span class="c10 c0 c2">k</span><span class="c0">Â == </span><span class="c0 c2">id </span><span class="c10 c0 c2">Â </span><span>is evaluated Â to an object </span><span class="c2">o</span><span>Â which is then subjected to boolean conversion yielding a value </span><span class="c2">v.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>If </span><span class="c2">v</span><span>Â is not </span><span class="c0 c5">true</span><span>, the following case, Â </span><span class="c0 c5">case</span><span class="c0">Â </span><span class="c0 c2">e</span><span class="c10 c0 c2">k+1</span><span class="c0">: </span><span class="c0 c2">s</span><span class="c10 c0 c2">k+1 </span><span>is executed if it exists. If </span><span class="c0 c5">case</span><span class="c0">Â </span><span class="c0 c2">e</span><span class="c10 c0 c2">k+1</span><span class="c0">: </span><span class="c0 c2">s</span><span class="c10 c0 c2">k+1 </span><span>does not exist, then the </span><span class="c0 c5">default</span><span>Â clause is executed by executing </span><span class="c0 c2">s</span><span class="c10 c0 c2">n+1</span><span class="c0 c2">.</span></p><p class="c13"><span>If </span><span class="c2">v</span><span>Â is </span><span class="c0 c5">true</span><span>, let </span><span class="c2">h</span><span>Â be the smallest integer such that </span><span class="c2">h &gt;= k</span><span>Â and </span><span class="c2">s</span><span class="c1">h</span><span>Â is non-empty. Â If no such </span><span class="c2">h</span><span>Â exists, let h = n + 1. The sequence </span><span>of statements </span><span class="c2">s</span><span class="c10 c2">h</span><span>Â is then executed</span><span>. Â If execution reaches the point after </span><span class="c0 c2">s</span><span class="c10 c0 c2">h</span><span>Â  then a runtime error occurs,</span><span>Â unless </span><span class="c2">h = n + 1</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>Execution of a </span><span class="c0 c5">case</span><span>Â clause </span><span class="c0 c5">case</span><span class="c0">Â </span><span class="c0 c2">e</span><span class="c10 c0 c2">k</span><span class="c0">: </span><span class="c0 c2">s</span><span class="c10 c0 c2">k</span><span class="c10 c0">Â </span><span>of a switch statement </span><span class="c0 c5">switch</span><span class="c0">Â (</span><span class="c0 c2">e</span><span class="c0">) {label</span><span class="c10 c0">11</span><span class="c0">Â ..label</span><span class="c10 c0">1j1</span><span class="c0">Â </span><span class="c0 c5">case</span><span class="c0">Â </span><span class="c0 c2">e</span><span class="c10 c0 c2">1</span><span class="c0">: </span><span class="c0 c2">s</span><span class="c10 c0 c2">1</span><span class="c0">Â â¦ label</span><span class="c10 c0">n1</span><span class="c0">Â ..label</span><span class="c10 c0">njn </span><span class="c0 c5">case</span><span class="c0">Â </span><span class="c0 c2">e</span><span class="c10 c0 c2">n</span><span class="c0">: </span><span class="c0 c2">s</span><span class="c10 c0 c2">n</span><span class="c0">} </span><span>proceeds as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>The expression </span><span class="c0 c2">e</span><span class="c10 c0 c2">k</span><span class="c0">Â == </span><span class="c0 c2">id </span><span class="c10 c0 c2">Â </span><span>is evaluated Â to an object </span><span class="c2">o</span><span>Â which is then subjected to boolean conversion yielding a value </span><span class="c2">v.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>If </span><span class="c2">v</span><span>Â is not </span><span class="c0 c5">true</span><span>, the following case, Â </span><span class="c0 c5">case</span><span class="c0">Â </span><span class="c0 c2">e</span><span class="c10 c0 c2">k+1</span><span class="c0">: </span><span class="c0 c2">s</span><span class="c10 c0 c2">k+1 </span><span>is executed if it exists. </span></p><p class="c13"><span>If </span><span class="c2">v</span><span>Â is </span><span class="c0 c5">true</span><span>, let </span><span class="c2">h</span><span>Â be the smallest integer such that </span><span class="c2">h &gt;= k</span><span>Â and </span><span class="c2">s</span><span class="c1">h</span><span>Â is non-empty. Â The sequence </span><span>of statements </span><span class="c2">s</span><span class="c10 c2">h</span><span>Â is executed</span><span>Â if it exists. Â If execution reaches the point after </span><span class="c0 c2">s</span><span class="c10 c0 c2">h</span><span>Â  then a runtime error occurs,</span><span>Â unless </span><span class="c2">h = n</span><span>.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">In other words, there is no implicit fall-through between cases. The last case in a switch (default or otherwise) can âfall-throughâ to the end of the statement.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span>It is a static warning if the type of </span><span class="c2">e</span><span>Â may not be assigned to the type of </span><span class="c2">e</span><span class="c10 c2">k</span><span>.</span><span>Â It is a static warning if </span><span>the last statement of the statement sequence </span><span class="c0 c2">s</span><span class="c10 c0 c2">k</span><span>Â is not a </span><span class="c0">break, continue, return</span><span>Â or </span><span class="c0">throw</span><span>Â statement.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">The behavior of switch cases intentionally differs from the C tradition. Â Implicit fall through is a known cause of programming errors and therefore disallowed. Â Why not simply break the flow implicitly at the end of every case, rather than requiring explicit code to do so? Â This would indeed be cleaner. Â It would also be cleaner to insist that each case have a single (possibly compound) statement. Â We have chosen not to do so in order to facilitate porting of switch statements from other languages. Â Implicitly breaking the control flow at the end of a case would silently alter the meaning of ported code that relied on fall-through, potentially forcing the programmer to deal with subtle bugs. </span><span class="c12 c2">Our design ensures that the difference is immediately brought to the coderâs attention. </span><span class="c12 c2">Â The programmer will be notified at compile-time if they forget to end a case with a statement that terminates the straight-line control flow. We could make this warning a compile-time error, but refrain from doing so because do not wish to force the programmer to deal with this issue immediately while porting code. Â If developers ignore the warning and run their code, a run time error will prevent the program from misbehaving in hard-to-debug ways (at least with respect to this issue).</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">The sophistication of the analysis of fall-through is another issue. For now, we have opted for a very straightforward syntactic requirement. There are obviously situations where code does not fall through, and yet does not conform to these simple rules, e.g.:</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c0 c2 c5">switch</span><span class="c12 c0 c2">Â (x) {</span></p><p class="c13"><span class="c12 c0 c2">Â </span><span class="c12 c0 c2 c5">case</span><span class="c12 c0 c2">Â 1: </span><span class="c12 c0 c2 c5">try</span><span class="c12 c0 c2">Â { â¦ </span><span class="c12 c0 c2 c5">return</span><span class="c12 c0 c2">;} </span><span class="c12 c0 c2 c5">finally</span><span class="c12 c0 c2">Â { â¦ </span><span class="c12 c0 c2 c5">return</span><span class="c12 c0 c2">;}</span></p><p class="c13"><span class="c12 c0 c2">}</span></p><p class="c8"><span class="c12 c0 c2"></span></p><p class="c13"><span class="c12 c2">Â Very elaborate code in a case clause is probably bad style in any case, and such code can always be refactored.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.vlflmf5cnfa1"></a><h3 class="c13"><a name="h.jodos9r2r9lz"></a><span>Try</span></h3><p class="c8"><span></span></p><p class="c13"><span>The </span><span class="c2">try statement</span><span>Â supports the definition of exception handling code in a structured way.</span></p><p class="c8"><span></span></p><a href="#" name="id.oz9orks2j6lc"></a><p class="c13"><span class="c2 c5">tryStatement:</span><span class="c2"><br> Â  Â  Â </span><span class="c0 c5">try</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#kix.kx7urn183i41">block</a></span><span class="c2">Â (</span><span class="c2">onPart+</span><span class="c2">Â finallyPart? | finallyPart)<br> Â  Â ;<br></span></p><p class="c8"><span class="c2 c5"></span></p><p class="c13"><span class="c2 c5">onPart:<br></span><span class="c2">Â  Â  Â  </span><span class="c2">catchPart</span><span class="c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=kix.kx7urn183i41">Â </a></span><span class="c6 c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=kix.kx7urn183i41">block</a></span></p><p class="c13"><span class="c2">Â  Â | </span><span class="c0 c5">on </span><span class="c2">type</span><span class="c0 c5">Â </span><span class="c0 c2">catchPart?</span><span class="c0 c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=kix.kx7urn183i41">Â </a></span><span class="c6 c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=kix.kx7urn183i41">block<br><br></a></span><span class="c2">Â  Â  ;</span></p><p class="c13"><span class="c2"><br></span><a href="#" name="id.d4869hyq37zh"></a><span class="c2 c5">catchPart:</span><span class="c2"><br> Â  Â  Â </span><span class="c0 c5">catch</span><span class="c2">Â &#39;(&#39; identifier (&#39;,&#39; identifier)? &#39;)&#39; <br> Â  Â ;<br><br></span><a href="#" name="id.phpx3xnrkle9"></a><span class="c2 c5">finallyPart:</span><span class="c2"><br> Â  Â  Â </span><span class="c0 c5">finally</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#kix.kx7urn183i41">block</a></span><span class="c2"><br> Â  Â ;<br></span></p><p class="c13"><span>A try statement consists of a block statement, followed by at least one of:</span></p><ol class="c20" start="1"><li class="c9"><span>A set of </span><span class="c0 c5">on-catch</span><span>Â clauses, each of which specifies (either explicitly or implicitly) the type of exception object to be handled,</span><span>Â one or two exception parameters and a block statement.</span></li><li class="c9"><span>A </span><span class="c0 c5">finally</span><span>Â clause, which consists of a block statement.</span></li></ol><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">The syntax is designed to be upward compatible with existing Javascript programs. The </span><span class="c12 c0 c5">on</span><span class="c12 c2">Â clause can be omitted, leaving what looks like a Javascript catch clause. </span></p><p class="c8"><span></span></p><p class="c13"><span>An </span><span class="c0 c5">on-catch</span><span>Â clause of the form </span><span class="c0 c5">on</span><span class="c0">Â </span><span class="c0 c2">T</span><span class="c0">Â </span><span class="c0 c5">catch</span><span class="c0">Â (</span><span class="c0 c2">p</span><span class="c10 c0 c2">1</span><span class="c0">, </span><span class="c0 c2">p</span><span class="c10 c0 c2">2</span><span class="c0">) </span><span class="c2">s</span><span>Â or </span><span class="c0 c5">on</span><span class="c0">Â </span><span class="c0 c2">T</span><span class="c0">Â </span><span class="c2">s</span><span class="c0">Â </span><span class="c2">matches</span><span>Â an object </span><span class="c2">o</span><span>Â if the type of </span><span class="c2">o</span><span>Â is a</span><span><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.hiljskbmppmb">Â </a></span><span class="c7"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.hiljskbmppmb">subtype</a></span><span>Â of </span><span class="c2">T.</span><span>Â  It is a static warning if </span><span class="c2">T</span><span>Â does not denote a type available in the lexical scope of the catch clause.</span></p><p class="c8"><span></span></p><p class="c13"><span>An </span><span class="c0 c5">on-catch</span><span>Â clause of the form </span><span class="c0 c5">on</span><span class="c0">Â </span><span class="c0 c2">T</span><span class="c0">Â </span><span class="c0 c5">catch</span><span class="c0">Â (</span><span class="c0 c2">p</span><span class="c10 c0 c2">1</span><span class="c0">) </span><span class="c2">s</span><span>Â is equivalent to an </span><span class="c0 c5">on-catch</span><span>Â clause </span><span class="c0 c5">on</span><span class="c0">Â </span><span class="c0 c2">T</span><span class="c0">Â </span><span class="c0 c5">catch</span><span class="c0">Â (</span><span class="c0 c2">p</span><span class="c10 c0 c2">1</span><span class="c0">, </span><span class="c0 c2">p</span><span class="c10 c0 c2">2</span><span class="c0">) </span><span class="c2">s, </span><span>where</span><span class="c2">Â p</span><span class="c10 c2">2</span><span class="c2">Â </span><span>is an identifier that does not occur anywhere else in the program.</span><span class="c2">Â  </span><span>Â </span></p><p class="c8"><span></span></p><p class="c13"><span>An </span><span class="c0 c5">on-catch</span><span>Â clause of the form </span><span class="c0 c5">catch</span><span class="c0">Â (</span><span class="c0 c2">p</span><span class="c0">) </span><span class="c2">s</span><span>Â is equivalent to an an </span><span class="c0 c5">on-catch</span><span>Â clause </span><span class="c0 c5">on </span><span class="c0">Object</span><span class="c0 c5">Â </span><span class="c0 c5">catch</span><span class="c0">Â (</span><span class="c0 c2">p</span><span class="c0">) </span><span class="c2">s</span><span class="c0 c2">. </span><span>An </span><span class="c0 c5">on-catch</span><span>Â clause of the form </span><span class="c0 c5">catch</span><span class="c0">Â (</span><span class="c0 c2">p</span><span class="c10 c0 c2">1</span><span class="c0">, </span><span class="c0 c2">p</span><span class="c10 c0 c2">2</span><span class="c0">) </span><span class="c2">s</span><span>Â is equivalent to an an </span><span class="c0 c5">on-catch</span><span>Â clause </span><span class="c0 c5">on </span><span class="c0">Object</span><span class="c0 c5">Â catch</span><span class="c0">Â (</span><span class="c0 c2">p</span><span class="c10 c0 c2">1</span><span class="c0">, </span><span class="c0 c2">p</span><span class="c10 c0 c2">2</span><span class="c0">) </span><span class="c2">s</span><span class="c0 c2">.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span>The </span><span class="c2">active stack trace</span><span>Â is an object whose </span><span class="c0">toString()</span><span>Â method produces a string that is a record of exactly those function activations within the current isolate that had not completed execution at the point where the current exception was thrown.</span></p><p class="c8"><span class="c12"></span></p><p class="c13"><span class="c3">This implies that no synthetic function activations may be added to the trace, nor may any source level activations be omitted. This means, for example, that any inlining of functions done as an optimization must not be visible in the trace. Similarly, any synthetic routines used by the implementation must not appear in the trace.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">Nothing is said about how any native function calls may be represented in the trace.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span>For each such function activation, the active stack trace includes the name of the function, the bindings of all its formal parameters, local variables and this, and the position at which the function was executing.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">The term position should not be interpreted as a line number, but rather as a precise position - the exact character index of the expression that raised the exception.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">The definition below is an attempt to characterize exception handling without resorting to a normal/abrupt completion formulation. It has the advantage that one need not specify abrupt completion behavior for every compound statement. Â On the other hand, it is new different and needs more thought.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span>A try statement </span><span class="c0 c5">try</span><span class="c0">Â </span><span class="c0 c2">s</span><span class="c10 c0 c2">1</span><span class="c0">Â </span><span class="c0 c2">on-catch</span><span class="c10 c0 c2">1</span><span class="c0">Â ... </span><span class="c0 c2">on-catch</span><span class="c10 c0 c2">n</span><span class="c0">Â </span><span class="c0 c5">finally</span><span class="c0">Â </span><span class="c0 c2">s</span><span class="c10 c0 c2">f Â </span><span>defines an exception handler </span><span class="c2">h</span><span>Â that executes as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>The </span><span class="c0 c5">on-catch</span><span>Â clauses are examined in order, starting with </span><span class="c2">on-catch</span><span class="c10 c2">1</span><span>, until either an </span><span class="c0 c5">on-catch</span><span>Â clause that matches the current exception is found, or the list of </span><span class="c0 c5">on-catch</span><span>Â clauses has been exhausted. If an </span><span class="c0 c5">on-catch</span><span>Â clause </span><span class="c2">on-catch</span><span class="c10 c2">k </span><span>is found, it is executed. If no </span><span class="c0 c5">on-catch</span><span>Â clause is found, the </span><span class="c0 c5">finally</span><span>Â clause is executed. Then, execution resumes at the end of the try statement.</span></p><p class="c13"><span>A </span><span class="c0 c5">finally</span><span>Â clause </span><span class="c0 c5">finally</span><span class="c0">Â </span><span class="c0 c2">s </span><span>defines an exception handler </span><span class="c2">h</span><span>Â that executes by executing the </span><span class="c0 c5">finally</span><span>Â clause. Then, execution resumes at the end of the try statement.</span></p><p class="c8"><span></span></p><p class="c13"><span>Execution of an </span><span class="c0 c5">on-catch</span><span>Â clause </span><span class="c0 c5">on</span><span class="c0 c2">Â T </span><span class="c0 c5">catch</span><span class="c0">Â (</span><span class="c0 c2">p</span><span class="c10 c0 c2">1</span><span class="c0">, </span><span class="c0 c2">p</span><span class="c10 c0 c2">2</span><span class="c0">) </span><span class="c0 c2">s</span><span>Â of a </span><span class="c0 c5">try</span><span>Â statement </span><span class="c2">t</span><span>Â proceeds as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>Variables </span><span class="c2">p</span><span class="c10 c2">1</span><span>Â of static type </span><span class="c2">T,</span><span>Â and </span><span class="c2">p</span><span class="c10 c2">2</span><span>Â of static type </span><span class="c0">StackTrace</span><span>Â are implicitly declared, with a scope comprising </span><span class="c2">s</span><span>. Â The variable </span><span class="c2">p</span><span class="c10 c2">1</span><span>Â is bound to the current exception, and </span><span class="c2">p</span><span class="c10 c2">2</span><span>Â is bound to the current stack trace. Next, the statement </span><span class="c2">s</span><span>Â is executed in the dynamic scope of the exception handler defined by the </span><span class="c0">finally</span><span>Â clause of </span><span class="c2">t</span><span>. Then, the current exception and </span><span>active</span><span>Â stack trace both become undefined.</span></p><p class="c8"><span></span></p><p class="c13"><span>Execution of a </span><span class="c0">finally</span><span>Â clause </span><span class="c0 c5">finally</span><span class="c0">Â </span><span class="c0 c2">s</span><span>Â of a try statement proceeds as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>The statement </span><span class="c2">s</span><span>Â is executed. Then, if the current exception is defined, control is transferred to the nearest dynamically enclosing exception handler.</span></p><p class="c8"><span></span></p><p class="c13"><span>Execution of a try statement of the form </span><span class="c0 c5">try</span><span class="c0">Â </span><span class="c0 c2">s</span><span class="c10 c0 c2">1</span><span class="c0">Â </span><span class="c0 c2">on-catch</span><span class="c10 c0 c2">1</span><span class="c0">Â ... </span><span class="c0 c2">on-catch</span><span class="c10 c0 c2">n</span><span class="c0">Â </span><span class="c0 c5">finally</span><span class="c0">Â </span><span class="c0 c2">s</span><span class="c10 c0 c2">f Â </span><span>proceeds as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>The statement </span><span class="c2">s</span><span class="c10 c2">1</span><span>Â is executed in the dynamic scope of the exception handler defined by the try statement. Then, the </span><span class="c0 c5">finally</span><span>Â clause is executed.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">Whether any of the on-catch clauses is executed depends on whether a matching exception has been raised by </span><span class="c3 c2">s</span><span class="c10 c3 c2">1</span><span class="c3">Â (see the specification of the </span><span class="c0 c3 c5">throw</span><span class="c3">Â statement).</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">If </span><span class="c3 c2">s</span><span class="c10 c3 c2">1</span><span class="c3">Â has raised an exception, it will transfer control to the try statementâs handler, which will examine the </span><span class="c0 c3 c5">on-catch</span><span class="c3">Â clauses in order for a match as specified above. If no matches are found, the handler will execute the </span><span class="c0 c3 c5">finally</span><span class="c3">Â clause.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">If a matching handler was found, it will execute first, and then the </span><span class="c0 c3 c5">finally</span><span class="c3">Â clause will be executed.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">If an exception is raised during execution of an </span><span class="c0 c3 c5">on-catch</span><span class="c3">Â clause, this will transfer control to the handler for the </span><span class="c0 c3 c5">finally</span><span class="c3">Â clause, causing the </span><span class="c0 c3 c5">finally</span><span class="c3">Â clause to execute in this case as well.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">If no exception was raised, the </span><span class="c0 c3 c5">finally</span><span class="c3">Â clause is also executed. Execution of the </span><span class="c0 c3 c5">finally</span><span class="c3">Â clause could also raise an exception, which will cause transfer of control to the next enclosing handler.</span></p><p class="c8"><span></span></p><p class="c13"><span>A try statement of the form </span><span class="c0 c5">try</span><span class="c0">Â </span><span class="c0 c2">s</span><span class="c10 c0 c2">1</span><span class="c0">Â </span><span class="c0 c2">on-catch</span><span class="c10 c0 c2">1</span><span class="c0">Â ... </span><span class="c0 c2">on-catch</span><span class="c10 c0 c2">n Â </span><span>is equivalent to the statement Â </span><span class="c0 c5">try</span><span class="c0">Â </span><span class="c0 c2">s</span><span class="c10 c0 c2">1</span><span class="c0">Â </span><span class="c0 c2">on-catch</span><span class="c10 c0 c2">1</span><span class="c0">Â ... </span><span class="c0 c2">on-catch</span><span class="c10 c0 c2">n</span><span class="c0">Â </span><span class="c0 c5">finally</span><span class="c0">Â </span><span class="c0 c2">{}</span></p><h3 class="c13 c37"><a name="h.877jl44ssm4x"></a></h3><a href="#" name="id.963bggxlx5wo"></a><h3 class="c13"><a name="h.q1wj04wamlw9"></a><span>Return</span></h3><p class="c8"><span></span></p><p class="c13"><span>The </span><span class="c2">return statement</span><span>Â returns a result to the caller of a function.</span></p><p class="c8"><span></span></p><a href="#" name="id.vdmucwmxk5sb"></a><p class="c13"><span class="c2 c5">returnStatement:</span><span class="c2"><br> Â  Â </span><span class="c0 c5">return</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.1u3vxuwrz6py">expression</a></span><span class="c2">? &#39;;&#39;<br> Â  Â ;</span></p><p class="c8"><span class="c0"></span></p><p class="c13"><span>Executing a return statement </span></p><p class="c8"><span></span></p><p class="c13"><span class="c0 c5">return</span><span class="c0">Â </span><span class="c0 c2">e</span><span class="c0">;</span></p><p class="c8"><span></span></p><p class="c13"><span>first causes evaluation of the expression </span><span class="c2">e,</span><span>Â producing an object </span><span class="c2">o.</span><span>Â Next, </span><span>control is transferred to the caller </span><span>of the current function activation, and the object </span><span class="c2">o</span><span>Â is provided to the caller as the result of the function call.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a static type warning if the type of </span><span class="c2">e</span><span>Â may not be assigned to the declared return type of the immediately enclosing function. </span></p><p class="c8"><span></span></p><p class="c13"><span>In checked mode, it is a dynamic type error if </span><span class="c2">o</span><span>Â is not </span><span class="c0 c5">null</span><span>Â and the runtime type of </span><span class="c2">o</span><span>Â is not a subtype of the actual return type of the immediately enclosing function.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error if a return statement of the form </span><span class="c0 c5">return </span><span class="c0 c2">e</span><span class="c0">;</span><span>Â appears in a </span><span class="c7"><a class="c4" href="#id.e2bn3056d7ls">generative constructor</a></span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">It is quite easy to forget to add the factory prefix for a constructor, accidentally converting a factory into a generative constructor. The static checker may detect a type mismatch in some, but not all, of these cases. The rule above helps catch such errors, which can otherwise be very hard to recognize. There is no real downside to it, as returning a value from a generative constructor is meaningless.</span></p><p class="c8"><span></span></p><p class="c13"><span>Let </span><span class="c2">f</span><span>Â be the function immediately enclosing a return statement of the form </span><span class="c0 c5">return</span><span class="c0">;</span><span>Â It is a static warning if both of the following conditions hold:</span></p><ol class="c16" start="1"><li class="c9"><span>Â </span><span class="c2">f</span><span>Â is not a generative constructor. </span></li><li class="c9"><span>The return type of </span><span class="c2">f</span><span>Â may not be assigned to </span><span class="c0 c5">void.</span><span>Â </span></li></ol><p class="c8"><span></span></p><p class="c13"><span class="c3">Hence, a static warning will not be issued if </span><span class="c3 c2">f</span><span class="c3">Â has no declared return type, since</span><span>Â </span><span class="c3">the return type would be </span><span class="c0 c3 c5">dynamic</span><span class="c3">Â and </span><span class="c0 c3 c5">dynamic</span><span class="c3">Â may be assigned to </span><span class="c0 c3 c5">void</span><span class="c3">. However, any function that declares a return type must return an expression explicitly.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c12 c2">This helps catch situations where users forget to return a value in a return statement.</span></p><p class="c8"><span></span></p><p class="c13"><span>A return statement with no expression, </span><span class="c0 c5">return</span><span class="c0">;</span><span>Â </span><span>is executed by e</span><span>xecuting the statement </span><span class="c0 c5">return</span><span class="c0">Â </span><span class="c0 c5">null</span><span class="c0">;</span><span>Â if it occurs inside a method, getter, setter or factory; otherwise, the return statement necessarily occurs inside a generative constructor,</span><span>Â in which case it is executed by executing </span><span class="c0 c5">return</span><span class="c0">Â </span><span class="c0 c5">this</span><span class="c0">;</span><span>.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">Despite the fact that </span><span class="c0 c3 c5">return</span><span class="c0 c3">;</span><span class="c3">Â is executed as if by a </span><span class="c0 c3 c5">return </span><span class="c0 c3 c2">e</span><span class="c0 c3">;</span><span class="c3">, i</span><span class="c3">t is important to understand that it is </span><span class="c3 c5">not</span><span class="c3">Â a static warning to include a statement of the form </span><span class="c0 c3 c5">return</span><span class="c0 c3">;</span><span class="c3">Â in a generative constructor. The rules relate only to the specific syntactic form </span><span class="c0 c3 c5">return </span><span class="c0 c3 c2">e</span><span class="c0 c3">;.</span></p><p class="c8"><span class="c0 c3"></span></p><p class="c13"><span class="c12 c2">The motivation for formulating </span><span class="c12 c0 c2 c5">return</span><span class="c12 c0 c2">; </span><span class="c12 c2">in this way stems from the basic requirement that all function invocations indeed return a value. Function invocations are expressions, and we cannot rely on a mandatory typechecker to always prohibit use of </span><span class="c12 c0 c2 c5">void</span><span class="c12 c2">Â functions in expressions. Hence, a return statement must always return a value, even if no expression is specified.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">The question then becomes, what value should a return statement return when no return expression is given. In a generative constructor, it is obviously the object being constructed (</span><span class="c12 c0 c2 c5">this</span><span class="c12 c2">). In void functions we use </span><span class="c12 c0 c2 c5">null</span><span class="c12 c2">. A void function is not expected to participate in an expression, which is why it is marked </span><span class="c12 c0 c2 c5">void</span><span class="c12 c2">Â in the first place. Hence, this situation is a mistake which should be detected as soon as possible. The static rules help here, but if the code is executed, using </span><span class="c12 c0 c2 c5">null</span><span class="c12 c2">Â leads to fast failure, which is desirable in this case. The same rationale applies for </span><span class="c12 c2">function bodies that do not contain a return statement at all</span><span class="c12 c2">.</span></p><p class="c8"><span class="c0"></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.va601vsgef9n"></a><h3 class="c13"><a name="h.k6ffi6ql1tjy"></a><span>Labels</span></h3><p class="c13"><span>A </span><span class="c2">label </span><span>is an identifier followed by a colon. A </span><span class="c2">labeled statement</span><span>Â is a statement prefixed by a label </span><span class="c2">L. </span><span>Â  A </span><span class="c2">labeled case clause </span><span>is a case clause within a </span><span class="c7"><a class="c4" href="#id.9tgfidrdlcan">switch statement</a></span><span>Â prefixed by a label </span><span class="c2">L.</span></p><p class="c13"><span class="c12 c2">The sole role of labels is to provide targets for the </span><span class="c7 c2"><a class="c4" href="#id.jzvs6ynykd2x">break</a></span><span class="c12 c2">Â and </span><span class="c7 c2"><a class="c4" href="#id.rmt74cjqdxyr">continue</a></span><span class="c12 c2">Â statements.</span></p><p class="c13"><span class="c2"><br></span><a href="#" name="kix.3phuboy3max"></a><span class="c2 c5">label:</span><span class="c2"><br> Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2">Â &#39;:&#39;<br> Â  Â ;<br></span></p><p class="c13"><span>The semantics of a labeled statement </span><span class="c2">L: s</span><span>Â are identical to those of the statement </span><span class="c2">s</span><span>. The namespace of labels is distinct from the one used for types, functions and variables.</span></p><p class="c8"><span></span></p><p class="c13"><span>The scope of a label that labels a statement </span><span class="c2">s</span><span>Â is </span><span class="c2">s. </span><span>The scope of a label that labels a case clause of a switch statement </span><span class="c2">s</span><span>Â is </span><span class="c2">s.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">Labels should be avoided by programmers at all costs. The motivation for including labels in the language is primarily making Dart a </span><span class="c12 c2">better</span><span class="c12 c2">Â target for code generation.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.jzvs6ynykd2x"></a><h3 class="c13"><a name="h.s4y8w9w8zyl0"></a><span>Break</span></h3><p class="c8"><span></span></p><p class="c13"><span>The </span><span class="c2">break statement</span><span>Â consists of the reserved word </span><span class="c0 c5">break</span><span>Â and an optional </span><span class="c7"><a class="c4" href="#id.va601vsgef9n">label</a></span><span>. </span></p><p class="c8"><span></span></p><a href="#" name="id.xweryammo2zi"></a><p class="c13"><span class="c2 c5">breakStatement:</span><span class="c2"><br> Â  Â  </span><span class="c0 c5">break</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2">? &#39;;&#39;<br> Â  Â ;<br></span></p><p class="c8"><span></span></p><p class="c13"><span>Let </span><span class="c2">s</span><span class="c1">b</span><span>Â be a break statement. If </span><span class="c2">s</span><span class="c1">b</span><span>Â is of the form </span><span class="c0 c5">break</span><span class="c0">Â </span><span class="c0 c2">L</span><span class="c0">;</span><span>Â then let </span><span class="c2">s</span><span class="c1">E</span><span>Â be the the innermost labeled statement with label </span><span class="c2">L</span><span>Â enclosing </span><span class="c2">s</span><span class="c1">b</span><span class="c2">.</span><span>Â If </span><span class="c2">s</span><span class="c1">b</span><span>Â is of the form </span><span class="c0 c5">break</span><span class="c0">; </span><span>then let </span><span class="c2">s</span><span class="c1">E</span><span>Â be the the innermost Â </span><span class="c7 c0 c5"><a class="c4" href="#id.17r82ed5p6yq">do</a></span><span>, </span><span class="c7 c0 c5"><a class="c4" href="#id.nleo13o1ua6q">for</a></span><span>, </span><span class="c7 c0 c5"><a class="c4" href="#id.9tgfidrdlcan">switch</a></span><span>Â or </span><span class="c7 c0 c5"><a class="c4" href="#id.e6iow4tlr5al">while</a></span><span>Â statement enclosing </span><span class="c2">s</span><span class="c1">b</span><span class="c2">.</span><span>Â It is a compile-time error if no such statement </span><span class="c2">s</span><span class="c1">E </span><span>exists within the innermost function in which </span><span class="c2">s</span><span class="c1">b</span><span>Â occurs. Â Furthermore, let </span><span class="c2">s</span><span class="c1">1</span><span class="c2">... s</span><span class="c1">n</span><span>Â be those try statements that are both enclosed in </span><span class="c2">s</span><span class="c1">E</span><span>Â and that enclose </span><span class="c2">s</span><span class="c1">b</span><span class="c2">,</span><span>Â and that have a </span><span class="c0 c5">finally</span><span>Â clause. Lastly, let </span><span class="c2">f</span><span class="c1">j</span><span>Â be the </span><span class="c0 c5">finally</span><span>Â clause of </span><span class="c2">s</span><span class="c1">j</span><span class="c2">, 1 &lt;= j &lt;= n. </span><span>Â  Executing </span><span class="c2">s</span><span class="c1">b</span><span>Â first executes </span><span class="c2">f</span><span class="c1">1</span><span class="c2">Â ... f</span><span class="c1">n</span><span>Â in innermost-clause-first order and then terminates</span><span>Â </span><span class="c2">s</span><span class="c1">E</span><span class="c2">.</span><span>Â </span></p><p class="c8"><span class="c18"></span></p><p class="c8"><span></span></p><a href="#" name="id.rmt74cjqdxyr"></a><h3 class="c13"><a name="h.hkf3vffzbfy6"></a><span>Continue</span></h3><p class="c8"><span></span></p><p class="c13"><span>The </span><span class="c2">continue statement</span><span>Â consists of the reserved word </span><span class="c0 c5">continue</span><span>Â and an optional </span><span class="c7"><a class="c4" href="#id.va601vsgef9n">label</a></span><span>. </span></p><p class="c8"><span></span></p><a href="#" name="id.ia1g5wsdvip7"></a><p class="c13"><span class="c2 c5">continueStatement:</span><span class="c2"><br> Â  Â </span><span class="c0 c5">continue</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2">? &#39;;&#39;<br> Â  Â  Â  Â ;<br></span></p><p class="c8"><span class="c18"></span></p><p class="c13"><span>Let </span><span class="c2">s</span><span class="c1">c</span><span>Â be a continue statement. If </span><span class="c2">s</span><span class="c1">c</span><span>Â is of the form </span><span class="c0 c5">continue</span><span class="c0">Â </span><span class="c0 c2">L</span><span class="c0">;</span><span>Â then let </span><span class="c2">s</span><span class="c1">E</span><span>Â be the the innermost labeled </span><span class="c7 c0 c5"><a class="c4" href="#id.17r82ed5p6yq">do</a></span><span>, </span><span class="c7 c0 c5"><a class="c4" href="#id.nleo13o1ua6q">for</a></span><span>Â or </span><span class="c7 c0 c5"><a class="c4" href="#id.e6iow4tlr5al">while</a></span><span>Â statement or </span><span>case clause with label </span><span class="c2">L</span><span>Â that encloses </span><span class="c2">s</span><span class="c1">c</span><span class="c2">.</span><span>Â If </span><span class="c2">s</span><span class="c1">c</span><span>Â is of the form </span><span class="c0 c5">continue</span><span class="c0">; </span><span>then let </span><span class="c2">s</span><span class="c1">E</span><span>Â be the the innermost Â </span><span class="c7 c0 c5"><a class="c4" href="#id.17r82ed5p6yq">do</a></span><span>, </span><span class="c7 c0 c5"><a class="c4" href="#id.nleo13o1ua6q">for</a></span><span>Â or </span><span class="c7 c0 c5"><a class="c4" href="#id.e6iow4tlr5al">while</a></span><span>Â statement enclosing </span><span class="c2">s</span><span class="c1">c</span><span class="c2">.</span><span>Â It is a compile-time error if no such statement or case clause </span><span class="c2">s</span><span class="c1">E </span><span>exists within the innermost function in which </span><span class="c2">s</span><span class="c1">c</span><span>Â occurs. Â Furthermore, let </span><span class="c2">s</span><span class="c1">1</span><span class="c2">... s</span><span class="c1">n</span><span>Â be those try statements that are both enclosed in </span><span class="c2">s</span><span class="c1">E</span><span>Â and that enclose </span><span class="c2">s</span><span class="c1">c</span><span class="c2">,</span><span>Â and that have a </span><span class="c0 c5">finally</span><span>Â clause. Lastly, let </span><span class="c2">f</span><span class="c1">j</span><span>Â be the </span><span class="c0 c5">finally</span><span>Â clause of </span><span class="c2">s</span><span class="c1">j</span><span class="c2">, 1 &lt;= j &lt;= n. </span><span>Â  Executing </span><span class="c2">s</span><span class="c1">c</span><span>Â first executes </span><span class="c2">f</span><span class="c1">1</span><span class="c2">Â ... f</span><span class="c1">n</span><span>Â in innermost-clause-first order. T</span><span>hen, if </span><span class="c2">s</span><span class="c1">E</span><span>Â is a case Â clause control is transferred to the case clause</span><span>; otherwise, </span><span class="c2">s</span><span class="c1">E</span><span>Â is necessarily a loop and execution resumes after the last statement in the loop body.</span></p><p class="c8"><span class="c18"></span></p><p class="c13"><span class="c3">In a while loop, that would be the boolean expression before the body. In a do loop, it would be the boolean expression after the body. In a for loop, it would be the increment clause. Â In other words, execution continues to the next iteration of the loop.</span></p><p class="c8"><span></span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span></span></p><a href="#" name="id.d0t8no72xrno"></a><h3 class="c13"><a name="h.cb5i0axenow6"></a><span>Assert</span></h3><p class="c8"><span></span></p><p class="c13"><span>An assert statement is used to disrupt normal execution if a given boolean condition does not hold.</span></p><p class="c8"><span></span></p><a href="#" name="id.rszxnavlorex"></a><p class="c13"><span class="c2 c5">assertStatement:</span><span class="c2"><br> Â  </span><span class="c0 c5">assert</span><span class="c2">Â &#39;(&#39; </span><span class="c6 c2"><a class="c4" href="#id.u42blbh7fdm7">conditionalExpression</a></span><span class="c2">Â &#39;)&#39; &#39;;&#39;<br> Â  Â  Â ;<br></span></p><p class="c13"><span>The assert statement has no effect in production mode. In checked mode, execution of an assert statement </span><span class="c0 c5">assert</span><span class="c0">(e);</span><span>Â </span><span>proceeds as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>The conditional expression </span><span class="c2">e</span><span>Â is evaluated to an object </span><span class="c2">o.</span><span>Â If the class of </span><span class="c2">o</span><span>Â is a subtype of </span><span class="c0">Function</span><span>Â then let </span><span class="c2">r</span><span>Â be the result of invoking </span><span class="c2">o</span><span>Â with no arguments. Otherwise, let </span><span class="c2">r</span><span>Â be </span><span class="c2">o.</span><span>Â  It is a</span><span>Â dynamic type error</span><span>Â if </span><span class="c2">o</span><span>Â is not of type </span><span class="c0">bool </span><span>or of type </span><span class="c0">Function</span><span>, or if </span><span class="c2">r</span><span>Â is not of type </span><span class="c0">bool.</span><span>Â  If </span><span class="c2">r</span><span>Â is </span><span class="c0 c5">false</span><span class="c5">,</span><span>Â we say that the </span><span class="c2">assertion failed</span><span>. If </span><span class="c2">r</span><span>Â is </span><span class="c0 c5">true</span><span class="c5">,</span><span>Â we say that the </span><span class="c2">assertion succeeded</span><span>. If the assertion succeeded, execution of the assert statement is complete. If the assertion failed, an </span><span class="c0">AssertionError</span><span>Â is </span><span class="c7"><a class="c4" href="#id.2p1bowyir5aa">thrown</a></span><span>.</span></p><p class="c8"><span class="c0"></span></p><p class="c13"><span>Â It is a static type warning if the type of </span><span class="c2">e</span><span>Â may not be assigned to either </span><span class="c0">bool</span><span>Â or </span><span class="c0">()</span><span class="c2">Â â</span><span class="c0">Â bool</span><span>Â </span></p><p class="c8"><span class="c0"></span></p><p class="c13"><span class="c12 c2">Why is this a statement, not a built in function call? Because it is handled magically so it has no effect and </span><span class="c12 c2 c5">no overhead</span><span class="c12 c2">Â in production mode. Also, in the absence of final methods. one could not prevent it being overridden (though there is no real harm in that). Overall, perhaps it could be defined as a function, and the overhead issue could be viewed as an optimization.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c8"><span class="c12"></span></p><p class="c8"><span></span></p><a href="#" name="id.3o1inam4xp4c"></a><h2 class="c13"><a name="h.9ljawpv6s0wp"></a><span>Libraries and Scripts</span></h2><p class="c8"><span></span></p><p class="c13"><span>A Dart program consists of one or more libraries, and may be built out of one or more {\em compilation units}. A compilation unit may be a library or a </span><span class="c6"><a class="c4" href="#id.bt926ffzxhiq">part</a></span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>A </span><span class="c2">library</span><span>Â consists of (a possibly empty) set of </span><span>imports</span><span>, and a set of top level declarations. A </span><span class="c2">top level declaration</span><span>Â is either a </span><span class="c7"><a class="c4" href="#id.o6h4ul6q3sru">class</a></span><span>, a </span><span class="c7"><a class="c4" href="#id.5bys07s0ifop">type alias declaration</a></span><span>, a </span><span class="c7"><a class="c4" href="#kix.v3h5pp33ioek">function</a></span><span>Â or a </span><span class="c7"><a class="c4" href="#kix.1b3yzqxc4cdw">variable declaration</a></span><span>.</span></p><p class="c8"><span></span></p><a href="#" name="id.8mpv6ds0oag5"></a><p class="c13"><span class="c2 c5">topLevelDefinition:</span><span class="c2"><br> Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#id.64pqsyyi6upg">classDefinition</a></span></p><p class="c13"><span class="c2">Â  Â  | </span><span class="c6 c2"><a class="c4" href="#id.irdsyrsz71yz">mixinApplication</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.h3l6oedgbv82">typeAlias</a></span></p><p class="c13"><span>Â  Â  </span><span>| </span><span class="c0 c5">external</span><span>Â </span><span class="c6 c2"><a class="c4" href="#id.7ttlaph5nhkh">functionSignature</a></span></p><p class="c13"><span>Â  Â  | </span><span class="c0 c5">external</span><span>Â getterSignature</span></p><p class="c13"><span>Â  Â  | </span><span class="c0 c5">external</span><span>Â setterSignature</span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.7ttlaph5nhkh">functionSignature</a></span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.twypn7sgnd3j">functionBody</a></span><span class="c2"><br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.mriqqq9dwbm5">returnType</a></span><span class="c2">? </span><span class="c6 c2"><a class="c4" href="#id.gxfpwladgq5d">getOrSet</a></span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.6xer2paz3k7q">formalParameterList</a></span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.twypn7sgnd3j">functionBody</a></span><span class="c2"><br> Â  Â | </span><span>(</span><span class="c0 c5">final </span><span class="c0">| </span><span class="c0 c5">const</span><span class="c0">)</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.qv2a3rupuer9">type</a></span><span class="c2">? staticFinalDeclarationList &#39;;&#39;<br> Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.prmcvifr6l2h">variableDeclaration</a></span><span class="c2">Â &#39;;&#39;<br> Â  Â ;<br></span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.gxfpwladgq5d"></a><p class="c13"><span class="c2 c5">getOrSet:</span></p><p class="c13"><span class="c2">Â  Â </span><span class="c0 c5">get </span></p><p class="c13"><span class="c2">Â | </span><span class="c0 c5">set</span></p><p class="c13"><span class="c2">Â ;<br></span></p><p class="c13"><span class="c2"><br></span><a href="#" name="id.k3wxok4u9obh"></a><span class="c2 c5">libraryDefinition:</span><span class="c2"><br> Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#id.1670myhga7st">libraryName</a></span><span class="c2">?</span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.bfclq926ibwi">importOrExport</a></span><span class="c2">* partDirective</span><span class="c2">*</span><span class="c2">Â </span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.8mpv6ds0oag5">topLevelDefinition</a></span><span class="c2">*</span></p><p class="c13"><span class="c2">Â  Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.1670myhga7st"></a><p class="c13"><span class="c2 c5">libraryName:</span></p><p class="c13"><span class="c2">Â  Â  </span><span class="c2">metadata </span><span class="c0 c5">library </span><span class="c2">identifier</span><span class="c2">Â (â.â identifier)*</span><span class="c2">Â â;â Â  ;</span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.bfclq926ibwi"></a><p class="c13"><span class="c2 c5">importOrExport:</span></p><p class="c13"><span class="c2">Â  Â </span><span class="c0 c5">libraryImport </span></p><p class="c13"><span class="c2">Â | </span><span class="c0 c5">libraryExport</span></p><p class="c13"><span class="c2">Â ;<br></span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>Libraries may be </span><span class="c2">explicitly named</span><span>Â or </span><span class="c2">implicitly named</span><span>. An explicitly named library </span><span>begins</span><span>Â with the word </span><span class="c0 c5">library </span><span>(possibly prefaced by any applicable metadata annotations)</span><span>,</span><span>Â followed by a </span><span>fully qualified</span><span>Â identifier that gives the name of the library.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">Technically, each dot and identifier is a separate token and so spaces between them are acceptable. However, the actual library name is the concatenation of the simple identifiers and dots and contains no spaces.</span></p><p class="c8"><span></span></p><p class="c13"><span>An implicitly named library has its name derived from the first URI where it is located. </span><span class="c18">Details TBD. For example, if the URI is a file path, the simple filename could be used as the library name. For more bizarre URIs, we will need to come up with a suitable rule.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">The name of a library is used to tie it to separately compiled parts of the library (called parts) and </span><span class="c12 c2">Â can be used for printing and, more generally, reflection. The name may be relevant for further language evolution (such as first class libraries) as well. In the future it may also serve to define a default prefix when importing.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c3">Names of libraries intended for widespread use should follow the well known reverse internet domain name convention.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span>Libraries are units of privacy. A private declaration declared within a library </span><span class="c2">L</span><span>Â can only be accessed by code within </span><span class="c2">L.</span><span>Â Any attempt to access a private member declaration from outside </span><span class="c2">L</span><span>Â will cause a run-time error.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">Since top level privates are not imported, using the top level privates of another library is never possible. </span></p><p class="c8"><span></span></p><p class="c13"><span>The </span><span class="c2">public namespace</span><span>Â of library </span><span class="c2">L</span><span>Â is the mapping that maps the simple name of each public top level member </span><span class="c2">m</span><span>Â of </span><span class="c2">L</span><span>Â to </span><span class="c2">m</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>The scope of a library </span><span class="c2">L</span><span>Â consists of the names introduced of all top level declarations declared in </span><span class="c2">L,</span><span>Â and the names added by </span><span class="c2">L</span><span>&#39;s imports</span><span class="c2">.</span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span></span></p><p class="c13"><span>Â </span></p><a href="#" name="id.8jajnornvp6l"></a><h3 class="c13"><a name="h.eyqxfqjhe14t"></a><span>Imports</span></h3><p class="c8"><span></span></p><p class="c13"><span>An </span><span class="c2">import</span><span>Â </span><span class="c2">directive </span><span>(often abbreviated as </span><span class="c2">import</span><span>) </span><span>specifies how a </span><span>namespace derived from</span><span>Â one</span></p><p class="c13"><span>library is to be used in the scope of another library. </span></p><a href="#" name="kix.r438bxskg4fe"></a><p class="c8"><span class="c2"></span></p><p class="c13"><span class="c2 c5">libraryI</span><span class="c2 c5">mport:</span></p><p class="c21 c13"><span class="c2">Â  Â  metadata </span><span class="c0 c5">import</span><span class="c2">Â  </span><span class="c2">uri</span><span class="c2">Â (</span><span class="c0 c5">as</span><span class="c2">Â identifier)? combinator* â;â</span></p><p class="c13"><span class="c2">;</span></p><a href="#" name="id.p046umbtqpmk"></a><p class="c13"><span class="c2 c5">combinator:</span></p><p class="c13"><span class="c2">Â </span><span class="c0 c5">show</span><span class="c2">Â identifierList</span></p><p class="c13"><span class="c2">Â | </span><span class="c0 c5">hide</span><span class="c2">Â identifierList</span></p><p class="c13"><span class="c2">;</span></p><p class="c8"><span></span></p><p class="c13"><span class="c2 c5">identifierList:</span></p><p class="c13"><span class="c0 c5">Â  </span><span class="c2">identifier (, identifier)*</span></p><p class="c13"><span>;</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span>An import specifies a URI </span><span class="c2">x</span><span>Â where the declaration of an imported library is to be found. It is a compile-time error if </span><span class="c2">x</span><span>Â is not a compile-time constant, or if </span><span class="c2">x</span><span>Â involves string interpolation. </span><span>It is a compile-time error if the compilation unit found at the specified URI is not a library declaration.</span><span>Â The interpretation of URIs is described in section 13.5 below.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span>The </span><span class="c2">current library</span><span>Â is the library currently being compiled. </span><span>The import modifies the import namespace of the current library in a manner that is determined by the imported library and by the optional elements of the import.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">Imports assume a global namespace of libraries (at least per isolate). They also assume the library is in control, rather than the other way around. </span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span>An import directive </span><span class="c2">I</span><span>Â may optionally include:</span></p><p class="c8"><span></span></p><ol class="c16" start="1"><li class="c9"><span>A prefix clause of the form </span><span class="c0 c5">as</span><span class="c0">Â Id</span><span>Â used to prefix names imported by </span><span class="c2">I</span><span>.</span></li><li class="c9"><span>Namespace combinator clauses used to restrict the set of names imported by </span><span class="c2">I</span><span>. </span><span>Currently, two namespace combinators are supported: </span><span class="c0 c5">hide</span><span>Â and </span><span class="c0 c5">show</span><span>.</span></li></ol><p class="c8"><span class="c3"></span></p><p class="c13"><span>Let </span><span class="c2">I</span><span>Â be an import directive that refers to a URI via the string </span><span class="c2">s</span><span class="c10 c2">1</span><span class="c2">. </span><span>Evaluation of </span><span class="c2">I Â </span><span>proceeds as follows:</span><span class="c2">Â </span></p><p class="c8"><span></span></p><p class="c13"><span>First,</span></p><p class="c13"><span>Â </span></p><ol class="c16" start="1"><li class="c9"><span>If the URI that is the value of </span><span class="c2">s</span><span class="c1">1</span><span>Â has not yet been accessed by an import or export directive in the current isolate then the contents of the URI are compiled to yield a library </span><span class="c2">B.</span><span>Â </span><span class="c3">Because libraries may have mutually recursive imports, care must be taken to avoid an infinite regress.</span></li></ol><p class="c8"><span></span></p><ol class="c16" start="1"><li class="c9"><span>Otherwise, the contents of the URI denoted by </span><span class="c2">s</span><span class="c1">1</span><span>Â have been compiled into a library </span><span class="c2">B</span><span>Â within the current isolate.</span></li></ol><p class="c8"><span class="c2"></span></p><p class="c8"><span></span></p><p class="c13"><span>Let </span><span class="c2">NS</span><span class="c10 c2">0</span><span class="c2">Â be</span><span>Â the</span><span><a class="c4" href="https://docs.google.com/a/google.com/document/d/1ElHPRnh_jIT_NaV-9H9q8q0H3LqDUOueBFbCGrFpuPg/edit#bookmark=id.lymamrq4rkhf">Â </a></span><span class="c7"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1ElHPRnh_jIT_NaV-9H9q8q0H3LqDUOueBFbCGrFpuPg/edit#bookmark=id.lymamrq4rkhf">exported namespace</a></span><span>Â of </span><span class="c2">B</span><span>. Then, for </span><span>each</span><span>Â combinator clause </span><span class="c2">C</span><span class="c10 c2">i</span><span class="c2">, 1 &lt;= i &lt;= n</span><span>, Â in </span><span class="c2">I</span><span>:</span></p><ol class="c16" start="1"><li class="c30 c31 c13"><span>If </span><span class="c2">C</span><span class="c10 c2">i</span><span>Â is of the form Â </span><span class="c0 c5">show</span><span>Â id</span><span class="c10">1</span><span>, â¦, id</span><span class="c10">k</span><span>Â , then let </span><span class="c2">NS</span><span class="c10 c2">i</span><span class="c2">Â = show([id</span><span class="c10 c2">1</span><span class="c2">, â¦, id</span><span class="c10 c2">k</span><span class="c2">], NS</span><span class="c10 c2">i-1</span><span class="c2">)</span><span>Â where </span><span class="c2">show(l,n)</span><span>Â takes a list of </span><span>identifiers</span><span>Â </span><span class="c2">l</span><span>Â and a namespace </span><span class="c2">n,</span><span>Â and produces a namespace that Â maps each name in </span><span class="c2">l</span><span>Â to the same element that </span><span class="c2">n</span><span>Â does. Furthermore, for each name </span><span class="c2">x</span><span>Â in </span><span class="c2">l</span><span>, if </span><span class="c2">n</span><span>Â defines the name Â </span><span class="c2">x=</span><span>Â then the new namespace maps </span><span class="c2">x=</span><span>Â to the same element that </span><span class="c2">n</span><span>Â does. Otherwise the resulting mapping is undefined.</span></li><li class="c30 c31 c13"><span>If </span><span class="c2">C</span><span class="c10 c2">i</span><span>Â is of the form Â </span><span class="c0 c5">hide</span><span>Â id</span><span class="c10">1</span><span>, â¦, id</span><span class="c10">k</span><span>Â , then let </span><span class="c2">NS</span><span class="c10 c2">i</span><span class="c2">Â = hide([id</span><span class="c10 c2">1</span><span class="c2">, â¦, id</span><span class="c10 c2">k</span><span class="c2">], NS</span><span class="c10 c2">i-1</span><span class="c2">)</span><span>Â where </span><span class="c2">hide(l, n)</span><span>Â takes a list of identifiers </span><span class="c2">l</span><span>Â and a namespace </span><span class="c2">n,</span><span>Â and produces a namespace that is identical to </span><span class="c2">n</span><span>Â except that for each name </span><span class="c2">k</span><span>Â in </span><span class="c2">l, k </span><span>and</span><span class="c2">Â k= </span><span>are undefined</span><span class="c2">.</span><span>Â </span></li></ol><p class="c8"><span></span></p><p class="c13"><span>Next, if </span><span class="c2">I</span><span>Â includes a prefix clause of the form </span><span class="c0 c5">as</span><span>Â </span><span class="c2">p</span><span>, let </span><span class="c2">NS = Â prefix(p, NS</span><span class="c1">n</span><span class="c2">) where prefix(id, n),</span><span>Â takes an identifier </span><span class="c2">id</span><span>Â and produces a namespace that has, for each entry mapping key </span><span class="c2">k</span><span>Â to declaration </span><span class="c2">d</span><span>Â in </span><span class="c2">n</span><span>, Â an entry mapping </span><span class="c2">id.k to d. </span><span>Otherwise, let </span><span class="c2">NS = NS</span><span class="c1">n</span><span class="c2">.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>It is a compile-time error if the current library declares a top-level member named </span><span class="c2">p.</span></p><p class="c8 c21"><span class="c2"></span></p><p class="c8"><span></span></p><p class="c8 c21"><span class="c2"></span></p><p class="c8 c21"><span class="c2"></span></p><p class="c21 c13"><span>Then, for each entry mapping key </span><span class="c2">k</span><span>Â to declaration </span><span class="c2">d</span><span>Â in </span><span class="c2">NS, d</span><span>Â is made available in the top level scope of </span><span class="c2">L</span><span>Â under the name </span><span class="c2">k</span><span>Â unless either:</span></p><ol class="c16" start="1"><li class="c41 c31 c13"><span>a declaration with the name </span><span class="c2">k </span><span>exists in </span><span class="c2">L, OR</span></li><li class="c31 c13 c41"><span>a </span><span class="c2">prefix </span><span>clause of the form Â </span><span class="c0 c5">as</span><span>Â </span><span class="c2">k</span><span>Â is used in </span><span class="c2">L</span><span>.</span></li></ol><p class="c8 c21"><span></span></p><p class="c21 c13"><span class="c12 c2">The greatly increases the chance that a member can be added to a library without breaking its importers.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span>If a name </span><span class="c2">N</span><span>Â is referenced by a library </span><span class="c2">L</span><span>Â and </span><span class="c2">N</span><span>Â is introduced into the top level scope </span><span class="c2">L</span><span>Â by more than one import then:</span></p><ol class="c16" start="1"><li class="c9"><span>It is a static warning if </span><span class="c2">N</span><span>Â is used as a type annotation.</span></li><li class="c9"><span>In checked mode, it is a dynamic error if </span><span class="c2">N</span><span>Â is used as a type annotation and referenced during a subtype test.</span></li><li class="c9"><span>Otherwise, it is a compile-time error.</span></li></ol><p class="c8"><span></span></p><p class="c13"><span class="c3">It is neither an error nor a warning if </span><span class="c3 c2">N</span><span class="c3">Â is introduced by two or more imports but never referred to.</span></p><p class="c8"><span class="c3"></span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c12 c2">The policy above makes libraries more robust in the face of additions made to their imports. Â </span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">A clear distinction needs to be made between this approach, and seemingly similar policies with respect to classes or interfaces. Â The use of a class or interface, and of its members, is separate from its declaration. The usage and declaration may occur in widely separated places in the code, and may in fact be authored by different people or organizations. Â It is important that errors are given at the offending declaration so that the party that receives the error can respond to it a meaningful way.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">In contrast a library comprises both imports and their usage; the library is under the control of a single party and so any problem stemming from the import can be resolved even if it is reported at the use site.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">On a related note, the provenance of the conflicting elements is not considered. An Â element that is imported via distinct paths may conflict with itself. This avoids variants of the well known &quot;diamond&quot; problem.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span>We say that the namespace </span><span class="c2">NS</span><span>Â has </span><span class="c2">been imported into L.</span></p><p class="c13"><span>It is a compile-time error to import two different libraries with the same name.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13 c21"><span>We say that the namespace </span><span class="c2">NS</span><span class="c2">Â </span><span class="c2">has been imported into L</span><span>.</span><span>Â </span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">A widely disseminated library should be given a name using the common inverted</span></p><p class="c13"><span class="c3">internet domain name convention, as in other popular languages.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">Note that no errors or warnings are given if one hides or shows a name that is not in a namespace. </span><span class="c12 c2">Â This prevents situations where removing a name from a library would cause breakage of a client library.</span></p><p class="c8"><span></span></p><p class="c13"><span>The dart core library is implicitly imported into every dart library other than itself via an Â import clause of the form</span></p><p class="c8"><span></span></p><p class="c13"><span class="c0 c5">import</span><span class="c0">Â  âdart:coreâ;</span></p><p class="c8"><span class="c0"></span></p><p class="c13"><span>unless the importing library explicitly imports </span><span class="c0">dart:core.</span></p><p class="c8"><span class="c0"></span></p><p class="c13"><span class="c3">Any import of </span><span class="c0 c3">dart:core</span><span class="c3">, whether restricted via </span><span class="c0 c3 c5">show</span><span class="c0 c3">, </span><span class="c0 c3 c5">hide</span><span class="c3">Â or </span><span class="c0 c3 c5">as</span><span class="c3">, preempts the automatic import.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c12 c2">It would be nice if there was nothing special about </span><span class="c12 c0 c2">dart:core</span><span class="c12 c2">. However, its use is pervasive, which leads to the decision to import it automatically. Â However, some library L Â may wish to define entities with names used by </span><span class="c12 c0 c2">dart:core</span><span class="c12 c2">Â (which it can easily do, as the names declared by a library take precedence). Other libraries may wish to use L and may want to use members of L that conflict with the core library without having to use a prefix. The above rule makes this possible, essentially canceling </span><span class="c12 c0 c2">dart:core</span><span class="c12 c2">&#39;s special treatment by means of yet another special rule. </span></p><p class="c8"><span></span></p><p class="c8"><span class="c27 c5"></span></p><p class="c8"><span></span></p><a href="#" name="kix.miugk9ur5wzt"></a><h3 class="c13"><a name="h.hn3xi6ounpdp"></a><span>Exports</span></h3><p class="c8 c21"><span class="c27 c5"></span></p><p class="c13"><span>A library </span><span class="c2">L</span><span>Â </span><span class="c2">exports</span><span>Â a </span><span class="c6"><a class="c4" href="#id.ph0zb6qp0qlw">namespace</a></span><span>, meaning that the declarations in the namespace are made available to other libraries if they choose to import </span><span class="c2">L.</span><span>Â  The namespace that </span><span class="c2">L</span><span>Â exports is known as its </span><span class="c2">exported namespace.</span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.ubaj6amlovp5"></a><p class="c13"><span class="c2 c5">libraryExport</span><span class="c2 c5">:</span></p><p class="c21 c13"><span class="c2">Â  Â  metadata </span><span class="c0 c5">export</span><span class="c2">Â  </span><span class="c2">uri</span><span class="c2">Â combinator* â;â</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>An export specifies a URI </span><span class="c2">x</span><span>Â where the declaration of an exported library is to be found. It is a compile-time error if the compilation unit found at the specified URI is not a library declaration.</span><span class="c2">Â  </span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>We say that a name </span><span class="c2">is exported by a library</span><span>Â (or equivalently, that a library </span><span class="c2">exports a name</span><span>) if the name is in the libraryâs exported namespace. </span><span>We say that a </span><span>declaration</span><span class="c2">Â is exported by a library</span><span>Â (or equivalently, that a library </span><span class="c2">exports a declaration</span><span>) if the declaration is in the libraryâs exported namespace.</span></p><p class="c8 c21"><span></span></p><p class="c13"><span>A library always exports all names and all declarations in its public namespace. In addition, a library may choose to re-export additional libraries via </span><span class="c2">export directives</span><span>, often referred to simply as </span><span class="c2">exports</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>Let </span><span class="c2">E</span><span>Â be an ex</span><span>port</span><span>Â directive that refers to a URI via the string </span><span class="c2">s</span><span class="c10 c2">1</span><span class="c2">. </span><span>Evaluation of </span><span class="c2">E Â </span><span>proceeds as follows:</span><span class="c2">Â </span></p><p class="c8"><span></span></p><p class="c13"><span>First,</span></p><p class="c13"><span>Â </span></p><ol class="c16" start="2"><li class="c9"><span>If the URI that is the value of </span><span class="c2">s</span><span class="c1">1</span><span>Â has not yet been accessed by an import or export directive in the current isolate then the contents of the URI are compiled to yield a library </span><span class="c2">B.</span><span>Â </span></li></ol><ol class="c16" start="2"><li class="c9"><span>Otherwise, the contents of the URI denoted by </span><span class="c2">s</span><span class="c1">1</span><span>Â have been compiled into a library </span><span class="c2">B</span><span>Â within the current isolate.</span></li></ol><p class="c8"><span class="c2"></span></p><p class="c8"><span></span></p><p class="c13"><span>Let </span><span class="c2">NS</span><span class="c10 c2">0</span><span class="c2">Â be</span><span>Â the exported namespace</span><span><a class="c4" href="https://docs.google.com/a/google.com/document/d/1ElHPRnh_jIT_NaV-9H9q8q0H3LqDUOueBFbCGrFpuPg/edit#bookmark=id.lymamrq4rkhf">Â </a></span><span>of </span><span class="c2">B</span><span>. Then, for each combinator clause </span><span class="c2">C</span><span class="c10 c2">i</span><span class="c2">, 1 &lt;= i &lt;= n</span><span>, Â in </span><span class="c2">E</span><span>:</span></p><ol class="c16" start="3"><li class="c30 c31 c13"><span>If </span><span class="c2">C</span><span class="c10 c2">i</span><span>Â is of the form Â </span><span class="c0 c5">show</span><span>Â id</span><span class="c10">1</span><span>, â¦, id</span><span class="c10">k</span><span>Â , then let </span><span class="c2">NS</span><span class="c10 c2">i</span><span class="c2">Â = show([id</span><span class="c10 c2">1</span><span class="c2">, â¦, id</span><span class="c10 c2">k</span><span class="c2">], NS</span><span class="c10 c2">i-1</span><span class="c2">)</span><span>.</span></li><li class="c30 c13 c31"><span>If </span><span class="c2">C</span><span class="c10 c2">i</span><span>Â is of the form Â </span><span class="c0 c5">hide</span><span>Â id</span><span class="c10">1</span><span>, â¦, id</span><span class="c10">k</span><span>Â , then let </span><span class="c2">NS</span><span class="c10 c2">i</span><span class="c2">Â = hide([id</span><span class="c10 c2">1</span><span class="c2">, â¦, id</span><span class="c10 c2">k</span><span class="c2">], NS</span><span class="c10 c2">i-1</span><span class="c2">). </span><span>Â </span></li></ol><p class="c8"><span></span></p><p class="c13"><span>For each entry mapping key </span><span class="c2">k</span><span>Â to declaration </span><span class="c2">d</span><span>Â  in </span><span class="c2">NS</span><span class="c1">n</span><span>Â  an entry mapping </span><span class="c2">k</span><span>Â to </span><span class="c2">d </span><span>is added to the exported namespace of </span><span class="c2">L</span><span>Â unless a Â top-level declaration with the name </span><span class="c2">k </span><span>exists in </span><span class="c2">L. Â </span><span>We say that </span><span class="c2">L re-exports library B, </span><span>and also that </span><span class="c2">L re-exports namespace ImportNamespace. </span><span>When no confusion can arise, we may simply state that </span><span class="c2">L re-exports B, </span><span>or that </span><span class="c2">L re-exports ImportNamespace.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>It is a compile-time error if a name </span><span class="c2">N</span><span>Â is re-exported by a library </span><span class="c2">L </span><span>and</span><span class="c2">Â N </span><span>is introduced into the export namespace of </span><span class="c2">L </span><span>by more than one export.</span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.bt926ffzxhiq"></a><h3 class="c13"><a name="h.dpvx6nmfj2hs"></a><span>Parts</span></h3><p class="c8"><span></span></p><p class="c13"><span>A library may be divided into </span><span class="c2">parts</span><span>, each of which can be stored in a separate location. A library identifies its parts by listing them via </span><span class="c0 c5">part</span><span>Â directives.</span></p><p class="c8"><span></span></p><p class="c13"><span>A </span><span class="c2">part directive</span><span>Â specifies a URI where a Dart compilation unit that should be incorporated into the current library may be found.</span></p><p class="c8"><span></span></p><a href="#" name="id.wbr98clsjafj"></a><p class="c13"><span class="c2 c5">partDirective:</span></p><p class="c13"><span class="c2">Â metadata </span><span class="c0 c5">part</span><span class="c2">Â  </span><span class="c6 c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.evk894mdov9u">stringLiteral</a></span><span class="c2">Â â;â</span></p><p class="c13"><span class="c2">Â  ;<br></span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.15klfu7k2hyi"></a><p class="c13"><span class="c2 c5">partHeader:<br></span><span class="c2">Â  Â  Â metadata </span><span class="c0 c5">part of </span><span class="c2">identifier</span><span class="c2">Â ( â.â identifier)* â;â</span><span class="c2"><br></span><span class="c2">Â  Â  ;</span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.bjytgxr2m61z"></a><p class="c13"><span class="c2 c5">partDeclaration:<br></span><span class="c2">Â  Â  Â partHeader Â </span><span class="c6 c2"><a class="c4" href="https://docs.google.com/a/google.com/document/d/1YblLwWryUj0VZBJ2xBgat4gYgH0mSFGuyrJpbcT5bTw/edit#bookmark=id.8mpv6ds0oag5">topLevelDefinition</a></span><span class="c2">* EOF<br> Â  Â ;</span><span class="c43 c2"><br></span></p><p class="c13"><span>A </span><span class="c2">part header</span><span>Â begins with Â </span><span class="c0 c5">part of</span><span>Â  followed by the name of the library the part belongs to. Â A </span><span class="c2">part declaration</span><span>Â consists of a part header followed by</span><span>Â a sequence of top level declarations.</span></p><p class="c8"><span></span></p><p class="c13"><span>Compiling a part directive of the form </span><span class="c0 c5">part</span><span class="c2">Â s; </span><span>causes the Dart system to attempt to compile the contents of the URI that is the value of </span><span class="c2">s.</span><span>Â The top level declarations at that URI are then compiled by the Dart compiler in the scope of the current library. It is a compile time error if the contents of the URI are not a valid part declaration. </span><span>It is a static warning if the referenced part declaration </span><span class="c2">p</span><span>Â names a library other than the current library as the library to which </span><span class="c2">p</span><span>Â belongs.</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error if </span><span class="c2">s</span><span>Â is not a compile-time constant, or if </span><span class="c2">s</span><span>Â involves string interpolation.</span></p><p class="c8"><span></span></p><h3 class="c13"><a name="h.ey3rvr2kjush"></a><span>Scripts</span></h3><p class="c8"><span></span></p><p class="c13"><span>A </span><span class="c2">script</span><span>Â is a library with a top level function </span><span class="c0">main().</span><span>Â </span></p><p class="c8"><span></span></p><a href="#" name="id.qkdy0hgohe8f"></a><p class="c13"><span class="c2 c5">scriptDefinition:</span></p><p class="c13"><span class="c2">Â  Â scriptTag? </span><span class="c6 c2"><a class="c4" href="#id.k3wxok4u9obh">libraryDefinition</a></span></p><p class="c13"><span class="c2">Â ;</span></p><p class="c8"><span></span></p><a href="#" name="kix.hxlcqdbry2h0"></a><p class="c13"><span class="c2 c5">scriptTag:</span></p><p class="c13"><span class="c2">Â  Â â#!â (~NEWLINE)* NEWLINE</span></p><p class="c13"><span class="c2">Â ;</span></p><p class="c8"><span></span></p><p class="c13"><span>A script may optionally begin with a </span><span class="c2">script tag</span><span>Â which can be used to identify the interpreter of the script to whatever computing environment the script is embedded in. The script tag must appear before any whitespace or comments. Â A script Â tag begins with the characters </span><span class="c0">#! </span><span>and ends at the end of the line. Any characters that follow </span><span class="c0">#!</span><span>Â in the script tag </span><span>are ignored by the Dart implementation.</span></p><p class="c8"><span></span></p><p class="c13"><span>A script </span><span class="c2">S</span><span>Â may be executed as follows:</span></p><p class="c8"><span></span></p><p class="c13"><span>First, </span><span class="c2">S</span><span>Â is compiled as a library as specified above. Then, the top level function </span><span class="c0">main()</span><span>Â that is in scope in </span><span class="c2">S</span><span>Â is invoked with no arguments. It is a run time error if </span><span class="c2">S</span><span>Â does not declare or import a top level function </span><span class="c0">main().</span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">The names of scripts are optional, in the interests of interactive, informal use. However, any script of long term value should be given a name as a matter of good practice. </span></p><p class="c8"><span class="c12 c2"></span></p><a href="#" name="id.m9puuhno3krn"></a><h3 class="c13"><a name="h.nzq6637fb0bx"></a><span>URIs</span></h3><p class="c8"><span></span></p><p class="c13"><span>URIs are specified by means of string literals:</span></p><p class="c8"><span></span></p><a href="#" name="id.t43fs6qvynik"></a><p class="c13"><span class="c2 c5">uri:</span></p><p class="c13"><span class="c2">Â  stringLiteral</span></p><p class="c13"><span class="c2">Â ;</span></p><p class="c8"><span></span></p><p class="c13"><span>It is a compile-time error if the string literal </span><span class="c2">x</span><span>Â that describes a URI is not a compile-time constant, or if </span><span class="c2">x</span><span>Â involves string interpolation.</span></p><p class="c8"><span></span></p><p class="c13"><span>This specification does not discuss the interpretation of URIs, with the following exceptions. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">The interpretation of URIs is mostly left to the surrounding computing environment. For example, if Dart is running in a web browser, that browser will likely interpret some URIs. While it might seem attractive to specify, say, that URIs are interpreted with respect to a standard such as IETF RFC 3986, in practice this will usually depend on the browser and cannot be relied upon.</span></p><p class="c8"><span></span></p><p class="c13"><span>A URI of the form </span><span class="c0">dart:s</span><span>Â is interpreted as a reference to a library </span><span class="c2">s</span><span>Â that is part of the Dart implementation.</span></p><p class="c8"><span></span></p><p class="c13"><span>A URI of the form </span><span class="c0">package:s</span><span>Â is interpreted as a URI of the form </span><span class="c0">packages/s</span><span>Â relative to an implementation specified location. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">This location will often be the location of the root library presented to the Dart compiler. However, implementations may supply means to override or replace this choice.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">The intent is that, during development, Dart programmers can rely on a package manager to find elements of their program. Such package managers may provide a directory structure starting at a directory </span><span class="c12 c0">packages</span><span class="c12 c2">Â where they place the required dart code (or links thereto).</span></p><p class="c8"><span></span></p><p class="c13"><span>Otherwise, any relative URI is interpreted as relative to the the location of the current library. All further interpretation of URIs is implementation dependent. </span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">This means it is dependent on the embedder.</span></p><p class="c8"><span class="c3"></span></p><p class="c8"><span class="c3"></span></p><p class="c8"><span class="c3"></span></p><p class="c8"><span class="c12 c2"></span></p><a href="#" name="id.438ffsdvzkfw"></a><h2 class="c13"><a name="h.9ca6j5czrg1m"></a><span>Types</span></h2><p class="c8"><span></span></p><p class="c13"><span>Dart supports optional typing based on interface types.</span></p><p class="c13"><span class="c12 c2">The type system is unsound, </span><span class="c12 c2">due to the covariance of generic types</span><span class="c12 c2">. This is a deliberate choice (and undoubtedly controversial). Â Experience has shown that sound type rules for generics fly in the face of programmer intuition. </span><span class="c12 c2">It is easy for tools to provide a sound type analysis if they choose</span><span class="c12 c2">, which may be useful for tasks like refactoring.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.hiljskbmppmb"></a><h3 class="c13"><a name="h.7tlgp5n9j12w"></a><span>Static Types</span></h3><p class="c13"><span class="c2">Static type annotations</span><span>Â are used in </span><span class="c7"><a class="c4" href="#kix.6b1cgvgf1cyq">variable declarations</a></span><span>Â (including </span><span class="c7"><a class="c4" href="#id.dbnqav8zbk9d">formal parameters</a></span><span>) and in the return types of </span><span class="c7"><a class="c4" href="#kix.v3h5pp33ioek">functions</a></span><span>, and in the bounds of type variables.</span><span>Â  Static type annotations are used during static checking and when running programs in checked mode. They have no effect whatsoever in production mode.</span></p><p class="c8"><span></span></p><a href="#" name="id.qv2a3rupuer9"></a><p class="c13"><span class="c2 c5">type:</span><span class="c2"><br> Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#id.op3nw89imb4w">typeName</a></span><span class="c2">Â </span><span class="c7 c2"><a class="c4" href="#id.okv2bn8j19mq">typeArguments</a></span><span class="c2">?<br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.op3nw89imb4w"></a><p class="c13"><span class="c2 c5">typeName:</span><span class="c2"><br> Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#id.xsv95i3z7eli">qualified</a></span><span class="c2"><br> Â  Â ;</span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.okv2bn8j19mq"></a><p class="c13"><span class="c2 c5">typeArguments:</span><span class="c2"><br> Â  Â  Â &#39;&lt;&#39; </span><span class="c7 c2"><a class="c4" href="#id.adfwlw3tslsh">typeList</a></span><span class="c2">Â &#39;&gt;&#39;<br> Â  Â ;<br><br></span><a href="#" name="id.adfwlw3tslsh"></a><span class="c2 c5">typeList:</span><span class="c2"><br> Â  Â  Â </span><span class="c7 c2"><a class="c4" href="#id.qv2a3rupuer9">type</a></span><span class="c2">Â (&#39;,&#39; </span><span class="c7 c2"><a class="c4" href="#id.qv2a3rupuer9">type</a></span><span class="c2">)*<br> Â  Â ;<br></span></p><p class="c8"><span></span></p><p class="c13"><span>A Dart implementation must provide a static checker that detects and reports exactly those situations this specification identifies as static warnings and only those situations. However:</span></p><ol class="c16" start="1"><li class="c9"><span>Running Â the static checker on a program </span><span class="c2">P</span><span>Â is not required for compiling and running </span><span class="c2">P.</span><span>Â  </span></li><li class="c9"><span>Running the static checker on a program </span><span class="c2">P</span><span>Â must not prevent successful compilation of </span><span class="c2">P</span><span>Â nor may it prevent the execution of </span><span class="c2">P,</span><span>Â regardless of whether any static warnings occur.</span></li></ol><p class="c13"><span class="c25">Nothing precludes additional tools that implement alternative static analyses (e.g., interpreting the existing type annotations in a sound manner such as either non-variant generics, or inferring declaration based variance from the actual declarations). However, using these tools must not preclude successful compilation and execution of Dart code.</span></p><p class="c8"><span class="c25"></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><h3 class="c13"><a name="h.6g03yyyk32we"></a><a href="#" name="id.xmnezjjgjrld"></a><span>Dynamic Type System</span></h3><p class="c13"><span>A Dart implementation must support execution in both </span><span class="c2">production mode</span><span>Â and </span><span class="c2">checked mode. </span><span>Â Those dynamic checks specified as occurring specifically in checked mode must be performed iff the code is executed in checked mode.</span></p><p class="c8"><span></span></p><p class="c13"><span>A type </span><span class="c2">T is malformed</span><span>Â iff:</span></p><ol class="c16" start="1"><li class="c9"><span class="c2">T</span><span>Â has the form </span><span class="c2">id </span><span>or the form Â </span><span class="c2">prefix.id,</span><span>Â and in the enclosing lexical scope, the name </span><span class="c2">id</span><span>Â (respectively </span><span class="c2">prefix.id</span><span>) does not denote a type.</span></li><li class="c9"><span class="c2">T</span><span>Â denotes a type variable in the enclosing lexical scope, but occurs in the signature or body of a static member.</span></li><li class="c9"><span class="c2">T</span><span>Â is a </span><span class="c7"><a class="c4" href="#id.nr95v4q1z9z0">parameterized type</a></span><span>Â of the form </span><span class="c2">G&lt;S</span><span class="c1">1</span><span class="c2">, .., S</span><span class="c1">n</span><span class="c2">&gt;,</span><span>Â and any of the following conditions hold:</span></li></ol><ol class="c39" start="1"><li class="c11 c30"><span>Either </span><span class="c2">G</span><span>Â or </span><span class="c2">S</span><span class="c1">i</span><span class="c2">, 1 &lt;= i &lt;= n</span><span>Â are malformed. </span></li><li class="c11 c30"><span class="c2">G</span><span>Â is not a generic type with </span><span class="c2">n</span><span>Â type parameters.</span></li><li class="c11 c30"><span>Let </span><span class="c2">T</span><span class="c1">i</span><span>Â be the type parameters of </span><span class="c2">G</span><span>Â (if any) and let </span><span class="c2">B</span><span class="c1">i</span><span>Â be the bound of </span><span class="c2">T</span><span class="c1">i</span><span class="c2">, 1 &lt;= i &lt;= n, </span><span>and </span><span class="c2">S</span><span class="c1">i</span><span>Â is not a subtype of </span><span class="c2">[S</span><span class="c1">1</span><span class="c2">, Â ..., S</span><span class="c1">n</span><span class="c2">/T</span><span class="c1">1</span><span class="c2">, Â ..., T</span><span class="c1">n</span><span class="c2">]B</span><span class="c1">i</span><span class="c2">, Â 1 &lt;= i &lt;= n,</span><span>Â </span></li></ol><p class="c8"><span></span></p><p class="c13"><span>In checked mode, it is a dynamic type error if a malformed type is used in a subtype test. In production mode, an undeclared type is treated as an instance of type </span><span class="c0 c5">dynamic</span><span>.</span></p><p class="c8"><span class="c49"></span></p><p class="c8"><span class="c3"></span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">Consider the following program</span></p><p class="c8"><span class="c3"></span></p><p class="c8"><span class="c0 c3 c5"></span></p><p class="c13"><span class="c0 c3 c5">typedef</span><span class="c0 c3">Â F(bool x);</span></p><p class="c13"><span class="c0 c3">f(foo x) =&gt; x;</span></p><p class="c13"><span class="c0 c3">main() {</span></p><p class="c13"><span class="c0 c3">Â  if (f is F) {</span></p><p class="c13"><span class="c0 c3">Â  Â  print(&quot;yoyoma&quot;);</span></p><p class="c13"><span class="c0 c3">Â  }</span></p><p class="c13"><span class="c0 c3">}</span></p><p class="c8"><span class="c0 c3"></span></p><p class="c13"><span class="c3">The type of the formal parameter of </span><span class="c0 c3">f</span><span class="c3">Â is </span><span class="c0 c3">foo</span><span class="c3">, which is undeclared in the lexical scope. This will lead to a static type warning. Running the program in production mode will print </span><span class="c0 c3">yoyoma</span><span class="c3">. In checked mode, however, the program will fail when executing the type test on the first line of </span><span class="c0 c3">main()</span><span class="c3">. Â A similar situation would arise if we wrote </span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c0 c3">f(foo x) =&gt; x;</span></p><p class="c13"><span class="c0 c3">main() {</span></p><p class="c13"><span class="c0 c3">Â  Â  Â print(f(&quot;yoyoma&quot;));</span></p><p class="c13"><span class="c0 c3">}</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">but the reason would be slightly different - the implicit type test triggered by passing </span><span class="c0 c3">âyoyomaâ</span><span class="c3">Â to </span><span class="c0 c3">f</span><span class="c3">Â would fail. In contrast, the program</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c0 c3">f(foo x) =&gt; x;</span></p><p class="c13"><span class="c0 c3">main() {</span></p><p class="c13"><span class="c0 c3">Â  Â  Â print(&quot;yoyoma&quot;);</span></p><p class="c13"><span class="c0 c3">}</span></p><p class="c8"><span class="c0 c3"></span></p><p class="c13"><span class="c3">runs without incident in both production mode and checked mode (though it too gives rise to a static warning). Â </span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">Some further examples</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c0 c3 c5">var</span><span class="c0 c3">Â i;</span></p><p class="c13"><span class="c0 c3">i Â j; // Â a variable j of type i (supposedly)</span></p><p class="c13"><span class="c0 c3">main() {</span></p><p class="c13"><span class="c0 c3">Â  Â  Â j = </span><span class="c0 c3 c5">new</span><span class="c0 c3">Â Object(); // fails in checked mode</span></p><p class="c13"><span class="c0 c3">}</span></p><p class="c8"><span class="c0 c3"></span></p><p class="c13"><span class="c3">Since</span><span class="c3 c2">Â i</span><span class="c3">Â is not a type, a static warning will be issue at the declaration of </span><span class="c3 c2">j.</span><span class="c3">Â However, the program can be executed in production mode without incident. In checked mode, the assignment to </span><span class="c3 c2">j</span><span class="c3">Â implicitly introduces a subtype test that checks whether the the type of the newly allocated object, </span><span class="c3 c2">Object</span><span class="c3">, is a subtype of the malformed type </span><span class="c3 c2">i</span><span class="c3">, which will cause a runtime error. However, no runtime error would occur </span><span class="c3">if </span><span class="c3 c2">j</span><span class="c3">Â was not used</span><span class="c3">, or if </span><span class="c3 c2">j</span><span class="c3">Â was assigned null (since no subtype check is performed in that case).</span></p><p class="c8"><span class="c0 c3"></span></p><p class="c8"><span class="c0 c3"></span></p><p class="c13"><span class="c12 c2">One could have chosen to treat undeclared types in checked mode as type </span><span class="c12 c0 c2 c5">dynamic</span><span class="c12 c2">, as is done in production mode. After all, a static warning has already been given. That is a legitimate design option, and it is ultimately a judgement call as to whether checked mode should be more or less aggressive in dealing with such a situation.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">Likewise, we could opt to ignore malformed types entirely in checked mode.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">For now, we have opted to treat a malformed type as an error type that has no subtypes or supertypes, and which causes a runtime error when tested against any other type.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c8"><span class="c3"></span></p><p class="c8"><span class="c3"></span></p><p class="c8"><span class="c3"></span></p><p class="c8"><span class="c3"></span></p><p class="c8"><span class="c3"></span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">Here is a different example involving malformed types:</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c0 c3 c5">class</span><span class="c0 c3">Â I&lt;T </span><span class="c0 c3 c5">extends</span><span class="c0 c3">Â num&gt; {}</span></p><p class="c13"><span class="c0 c3 c5">class</span><span class="c0 c3">Â J{}</span></p><p class="c8"><span class="c0 c3"></span></p><p class="c13"><span class="c0 c3 c5">class</span><span class="c0 c3">Â A&lt;T&gt; </span><span class="c0 c3 c5">implements</span><span class="c0 c3">Â J,</span><span class="c0 c3 c5">Â </span><span class="c0 c3">Â I&lt;T&gt; // type warning: T is not a subtype of num</span></p><p class="c13"><span class="c0 c3">{ ...</span></p><p class="c13"><span class="c0 c3">} </span></p><p class="c8"><span class="c3"></span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">Given the declarations above, the following</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c0 c3">I x = </span><span class="c0 c3 c5">new</span><span class="c0 c3">Â A&lt;String&gt;(); </span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">will cause a dynamic type error in checked mode, because the assignment requires a subtype test </span><span class="c0 c3">A&lt;String&gt;</span><span class="c3">Â &lt;: </span><span class="c0 c3">I</span><span class="c3">. To show that this holds, we need to show that </span><span class="c0 c3">A&lt;String&gt;</span><span class="c3">âª </span><span class="c0 c3">I&lt;String&gt;</span><span class="c3">, but </span><span class="c0 c3">I&lt;String&gt;</span><span class="c3">Â is a malformed type, causing the dynamic error. Â No error is thrown in production mode. Note that</span></p><p class="c8"><span class="c12 c0 c2"></span></p><p class="c13"><span class="c0 c3">J x = </span><span class="c0 c3 c5">new</span><span class="c0 c3">Â A&lt;String&gt;(); </span></p><p class="c8"><span class="c0 c3"></span></p><p class="c13"><span class="c3">does not cause a dynamic error, as there is no need to test against </span><span class="c0 c3">I&lt;String&gt;</span><span class="c3">Â in this case.</span><span class="c0 c3">Â </span></p><p class="c13"><span class="c3">Similarly, in production mode</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c0 c3">A x = </span><span class="c0 c3 c5">new</span><span class="c0 c3">Â A&lt;String&gt;();</span></p><p class="c13"><span class="c3">bool b = x is I;</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c0 c3">b</span><span class="c3">Â is bound to true, but in checked mode the second line causes a dynamic type error.</span></p><p class="c8"><span class="c12 c0 c2"></span></p><p class="c8"><span class="c0 c3"></span></p><p class="c8"><span class="c49"></span></p><p class="c8"><span></span></p><a href="#" name="id.5bys07s0ifop"></a><h3 class="c13"><a name="h.h8qq10r7b7a7"></a><span>Type Declarations</span></h3><a href="#" name="id.cogei5ciyfcy"></a><h4 class="c13"><a name="h.vv8c77hhsmtm"></a><span>Typedef</span></h4><p class="c8"><span></span></p><p class="c13"><span>A </span><span class="c2">type alias</span><span>Â declares a name for a type expression or </span><span class="c6"><a class="c4" href="#id.irdsyrsz71yz">mixin application</a></span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">Note that mixins are not supported in M2, and so typedefs remain restricted to functions.</span></p><p class="c8"><span></span></p><a href="#" name="id.h3l6oedgbv82"></a><p class="c13"><span class="c2 c5">typeAlias:</span><span class="c2"><br> Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#id.gtr1evk47jqd">metadata</a></span><span class="c0 c5"><a class="c4" href="#id.gtr1evk47jqd">Â </a></span><span class="c0 c5">typedef </span><span class="c6 c2"><a class="c4" href="#id.4sv9qfcyjwu0">typeAliasBody</a></span></p><p class="c13"><span class="c2">;</span></p><p class="c8"><span class="c2"></span></p><a href="#" name="id.4sv9qfcyjwu0"></a><p class="c13"><span class="c2 c5">typeAliasBody:</span><span class="c2"><br> Â  Â  </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.p9q99pefxn6v">typeParameters</a></span><span class="c2">?`=â </span><span class="c0 c5">abstract</span><span class="c0">?</span><span class="c0">Â </span><span class="c6 c2"><a class="c4" href="#id.kkw30c6ih30c">mixinApplication</a></span></p><p class="c13"><span>Â  Â | </span><span class="c6 c2"><a class="c4" href="#id.x1rn8p60orxh">functionTypeAlias</a></span></p><p class="c13"><span class="c2">;</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.x1rn8p60orxh"></a><p class="c13"><span class="c2 c5">functionTypeAlias:</span><span class="c2"><br> Â  Â  Â </span><span class="c6 c2"><a class="c4" href="#kix.yyd520hand9j">functionPrefix</a></span><span class="c2">Â </span><span class="c6 c2"><a class="c4" href="#id.p9q99pefxn6v">typeParameters</a></span><span class="c2">? </span><span class="c6 c2"><a class="c4" href="#id.6xer2paz3k7q">formalParameterList</a></span><span class="c2">Â &#39;;&#39;<br> Â  Â ;<br><br></span><a href="#" name="kix.yyd520hand9j"></a><span class="c2 c5">functionPrefix:</span><span class="c2"><br> Â  Â </span><span class="c6 c2"><a class="c4" href="#id.mriqqq9dwbm5">returnType</a></span><span class="c2">? </span><span class="c6 c2"><a class="c4" href="#id.te0njh1fhw7g">identifier</a></span><span class="c2"><br> Â  Â ;<br></span></p><p class="c13"><span>The effect of a type alias of the form Â </span><span class="c0 c5">typedef</span><span>Â </span><span class="c2">T id (T</span><span class="c1">1</span><span class="c2">Â p</span><span class="c1">1</span><span class="c2">, .., T</span><span class="c1">n</span><span class="c2">Â p</span><span class="c1">n</span><span class="c2">, [T</span><span class="c1">n+1</span><span class="c2">Â p</span><span class="c1">n+1</span><span class="c2">, â¦, T</span><span class="c1">n+k</span><span class="c2">Â p</span><span class="c1">n+k</span><span class="c2">]</span><span class="c2">)</span><span>Â declared in a library </span><span class="c2">L</span><span>Â is is to introduce the name </span><span class="c2">id</span><span>Â into the scope of </span><span class="c2">L,</span><span>Â bound to the function type </span><span class="c2">(T</span><span class="c1">1</span><span class="c2">, .., T</span><span class="c1">n</span><span class="c2">, [ T</span><span class="c1">n+1 </span><span class="c2">p</span><span class="c1">n+1</span><span class="c2">, â¦, Â T</span><span class="c1">n+k </span><span class="c2">p</span><span class="c1">n+k</span><span class="c2">]</span><span class="c2">) Â â T.</span><span>Â  </span><span>The effect of a type alias of the form Â </span><span class="c0 c5">typedef</span><span>Â </span><span class="c2">T id (T</span><span class="c10 c2">1</span><span class="c2">Â p</span><span class="c10 c2">1</span><span class="c2">, .., T</span><span class="c10 c2">n</span><span class="c2">Â p</span><span class="c10 c2">n</span><span class="c2">, {T</span><span class="c10 c2">n+1</span><span class="c2">Â p</span><span class="c10 c2">n+1</span><span class="c2">, â¦, T</span><span class="c10 c2">n+k</span><span class="c2">Â p</span><span class="c10 c2">n+k</span><span class="c2">})</span><span>Â declared in a library </span><span class="c2">L</span><span>Â is is to introduce the name </span><span class="c2">id</span><span>Â into the scope of </span><span class="c2">L,</span><span>Â bound to the function type </span><span class="c2">(T</span><span class="c10 c2">1</span><span class="c2">, .., T</span><span class="c10 c2">n</span><span class="c2">, { T</span><span class="c10 c2">n+1 </span><span class="c2">p</span><span class="c10 c2">n+1</span><span class="c2">, â¦, Â T</span><span class="c10 c2">n+k </span><span class="c2">p</span><span class="c10 c2">n+k</span><span class="c2">]}) Â â T.</span><span class="c2">Â </span><span>I</span><span>n either case, i</span><span>f no return type is specified, it is taken to be</span><span class="c2">Â </span><span class="c0 c5">dynamic.</span><span>Â Likewise, if a type annotation is omitted on a formal parameter, it is taken to be </span><span class="c0 c5">dynamic.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>The effect of a type alias of the form </span><span class="c0 c5">typedef</span><span>Â </span><span class="c2">C = M</span><span>; or the form </span><span class="c0 c5">typedef</span><span>Â </span><span class="c2">C&lt;T</span><span class="c10 c2">1</span><span class="c2">, .., T</span><span class="c10 c2">n</span><span class="c2">&gt; = M</span><span>; Â is to introduce the name </span><span class="c2">C</span><span>Â into the scope of </span><span class="c2">L,</span><span>Â bound to the class defined by the mixin application </span><span class="c2">M</span><span>. The name of the class is also set to </span><span class="c2">C</span><span>. Iff the type alias body includes the built-in identifier </span><span class="c0 c5">abstract</span><span>, the class being defined is an abstract class.</span></p><p class="c8"><span class="c2"></span></p><p class="c13"><span>It is a compile-time error if any default values are specified in the signature of a function type alias. It is a compile-time error if a typedef refers to itself via a chain of references that does not include a class type. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">Hence </span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c0 c3 c5">typedef</span><span class="c0 c3">Â F F(</span><span class="c0 c3">F</span><span class="c0 c3">Â f); </span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">is illegal, as are </span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c0 c3 c5">typedef</span><span class="c0 c3">Â B A();</span></p><p class="c13"><span class="c0 c3 c5">typedef</span><span class="c0 c3">Â A B();</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">but </span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c0 c3 c5">typedef</span><span class="c0 c3">Â D C();</span></p><p class="c13"><span class="c0 c3 c5">class</span><span class="c0 c3">Â D { C foo(){}}</span></p><p class="c8"><span class="c0 c3"></span></p><p class="c13"><span class="c3">is legal, because the references goes through a class declaration.</span></p><p class="c8"><span class="c3"></span></p><p class="c8"><span></span></p><a href="#" name="id.sos77naoaj3x"></a><h3 class="c13"><a name="h.36i2sfscvw0c"></a><span>Interface Types</span></h3><p class="c8"><span></span></p><p class="c13"><span>The implicit interface of class</span><span>Â </span><span class="c2">I</span><span>Â is a </span><span class="c2">direct supertype</span><span>Â of </span><span>the implicit interface of class</span><span>Â </span><span class="c2">J</span><span>Â iff:</span></p><ol class="c16" start="1"><li class="c9"><span>If </span><span class="c2">I</span><span>Â is </span><span class="c0">Object</span><span>, and </span><span class="c2">J</span><span>Â has no </span><span class="c0">extends</span><span>Â clause</span><span class="c2">.</span></li><li class="c9"><span>If </span><span class="c2">I</span><span>Â is listed in the </span><span class="c0">extends</span><span>Â clause of </span><span class="c2">J.</span></li><li class="c9"><span>If </span><span class="c2">I</span><span>Â is listed in the </span><span class="c0">implements</span><span>Â clause of </span><span class="c2">J.</span></li></ol><ol class="c16" start="1"><li class="c9"><span class="c2">If I is listed in the </span><span class="c0 c2">with</span><span class="c2">Â clause of J.</span></li></ol><ol class="c16" start="4"><li class="c9"><span class="c2">If J is a mixin application of the mixin of I.</span></li></ol><p class="c8"><span class="c43 c2"></span></p><p class="c8"><span class="c2 c43"></span></p><p class="c13"><span>A type </span><span class="c2">T</span><span>Â is </span><span class="c2">more specific than</span><span>Â a type </span><span class="c2">S,</span><span>Â written </span><span class="c2">T</span><span>Â âª </span><span class="c2">S, </span><span>Â if one of the following conditions is met:</span></p><ol class="c20" start="1"><li class="c9"><span class="c5">Reflexivity:</span><span>Â </span><span class="c2">T</span><span>Â is </span><span class="c2">S</span><span>.</span></li><li class="c9"><span class="c2">T</span><span>Â is </span><span class="c2">bottom</span><span>.</span></li><li class="c9"><span class="c2">S </span><span>is </span><span class="c0 c5">dynamic</span><span>.</span></li><li class="c9"><span class="c5">Direct supertype:</span><span>Â </span><span class="c2">S</span><span>Â is a direct supertype of </span><span class="c2">T</span><span>.</span></li><li class="c9"><span class="c2">T</span><span>Â is a type parameter and </span><span class="c2">S</span><span>Â is the upper bound of </span><span class="c2">T.</span></li><li class="c9"><span class="c5">Covariance:</span><span>Â </span><span class="c2">T</span><span>Â is of the form </span><span class="c2">I&lt;T</span><span class="c10 c2">1</span><span class="c2">, ..., T</span><span class="c10 c2">n</span><span class="c2">&gt;</span><span>Â and </span><span class="c2">S</span><span>Â is of the form </span><span class="c2">I&lt;S</span><span class="c10 c2">1</span><span class="c2">, ..., S</span><span class="c10 c2">n</span><span class="c2">&gt;</span><span>Â and </span><span class="c2">T</span><span class="c10 c2">i</span><span class="c10">Â </span><span>Â âª </span><span class="c2">S</span><span class="c10 c2">i </span><span class="c2">, 1 &lt;= i &lt;= n.</span></li><li class="c9"><span class="c5">Transitivity: </span><span class="c2">T</span><span>Â âª </span><span class="c2">U</span><span>Â and </span><span class="c2">U</span><span>Â âª </span><span class="c2">S</span><span>.</span></li></ol><p class="c8"><span></span></p><p class="c13"><span>âª is a</span><span><a class="c4" href="http://en.wikipedia.org/wiki/Partial_order">Â </a></span><span class="c32 c12"><a class="c4" href="http://en.wikipedia.org/wiki/Partial_order">partial order</a></span><span>Â on types.</span></p><p class="c13"><span class="c2">T</span><span>Â is a </span><span class="c2">subtype</span><span>Â of </span><span class="c2">S</span><span>, written </span><span class="c2">T</span><span>Â &lt;: </span><span class="c2">S, </span><span>iff </span><span class="c2">[bottom/</span><span class="c0 c5">dynamic</span><span class="c2">]T</span><span>Â âª </span><span class="c2">S</span><span>.</span></p><p class="c13"><span class="c12 c2">Note that &lt;: is not a partial order on types, it is only</span><span class="c12 c2"><a class="c4" href="http://en.wikipedia.org/wiki/Relation_(mathematics)">Â </a></span><span class="c32 c12 c2"><a class="c4" href="http://en.wikipedia.org/wiki/Relation_(mathematics)">binary relation</a></span><span class="c12 c2">Â on types. This is because &lt;: is not transitive. If it was, the subtype rule would have a cycle. For example:</span></p><p class="c13"><span class="c12 c2">List &lt;: List&lt;String&gt; and List&lt;int&gt; &lt;: List, but List&lt;int&gt; is not a subtype of List&lt;String&gt;.</span></p><p class="c13"><span class="c12 c2">Although &lt;: is not a partial order on types, it does contain a partial order, namely âª. This means that, barring raw types, intuition about classical subtype rules does apply.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c2">S</span><span>Â is a </span><span class="c2">supertype</span><span>Â of </span><span class="c2">T</span><span>, written </span><span class="c2">S</span><span>Â :&gt; </span><span class="c2">T</span><span>, iff </span><span class="c2">T</span><span>Â is a subtype of </span><span class="c2">S</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">The </span><span class="c3 c2">supertypes</span><span class="c3">Â of an interface are its direct supertypes and their supertypes.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span>A type </span><span class="c2">T</span><span>Â </span><span class="c2">may be assigned to</span><span>Â a type </span><span class="c2">S</span><span>, written Â T â S, iff either </span><span class="c2">T &lt;: S</span><span>Â or </span><span class="c2">S &lt;: T.</span></p><p class="c13"><span class="c12 c24 c2">This rule may surprise readers accustomed to conventional typechecking. The intent of the â relation is not to ensure that an assignment is correct. Instead, it aims to only flag assignments that are almost certain to be erroneous, without precluding assignments that may work.</span></p><p class="c8"><span class="c12 c24 c2"></span></p><p class="c13"><span class="c12 c24 c2">For example, assigning a value of static type Object to a variable with static type String, while not guaranteed to be correct, might be fine if the runtime value happens to be a string.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><a href="#" name="id.mmt307l7ge76"></a><h3 class="c13"><a name="h.hj977zpcf6uf"></a><span>Function Types</span></h3><p class="c8"><span></span></p><p class="c13"><span>Function types come in three variations:</span></p><ol class="c20" start="1"><li class="c9"><span>The types of functions that only have required parameters. These have the general form </span><span class="c2">(T</span><span class="c10 c2">1</span><span class="c2">, ..., T</span><span class="c10 c2">n</span><span class="c2">) â T.</span></li><li class="c9"><span>The types of functions with optional positional parameters. These have the general form </span><span class="c2">(T</span><span class="c10 c2">1</span><span class="c2">, ..., T</span><span class="c10 c2">n</span><span class="c2">, [T</span><span class="c10 c2">n+1</span><span class="c2">, â¦, T</span><span class="c10 c2">n+k</span><span class="c2">]) â T.</span></li><li class="c9"><span>The types of functions with named positional parameters. These have the general form </span><span class="c2">(T</span><span class="c10 c2">1</span><span class="c2">, ..., T</span><span class="c10 c2">n</span><span class="c2">, {T</span><span class="c10 c2">x1</span><span class="c2">Â x</span><span class="c10 c2">1</span><span class="c2">, â¦, T</span><span class="c10 c2">xk</span><span class="c2">Â x</span><span class="c10 c2">k</span><span class="c2">}) â T.</span></li></ol><p class="c8"><span class="c2"></span></p><p class="c13"><span>A function type </span><span class="c2">(T</span><span class="c10 c2">1</span><span class="c2">, ..., T</span><span class="c10 c2">n</span><span class="c2">) â T</span><span>Â is a subtype of the function type </span><span class="c2">(S</span><span class="c10 c2">1</span><span class="c2">, ..., S</span><span class="c10 c2">n</span><span class="c2">) â S,</span><span>Â if all of the following conditions are met:</span></p><ol class="c16" start="1"><li class="c9"><span>Either</span></li></ol><ol class="c39" start="1"><li class="c11 c30"><span class="c2">S</span><span>Â is </span><span class="c0">void</span><span>,</span></li><li class="c11 c30"><span>or </span><span class="c2">T</span><span>Â â </span><span class="c2">S</span><span>.</span></li></ol><ol class="c16" start="2"><li class="c9"><span>For all </span><span class="c2">i</span><span>Â , 1 &lt;= i &lt;= Â </span><span class="c2">n</span><span>, </span><span class="c2">T</span><span class="c10 c2">i</span><span>Â â </span><span class="c2">S</span><span class="c10 c2">i</span><span>.</span></li></ol><p class="c8"><span></span></p><p class="c13"><span>A function type </span><span class="c2">(T</span><span class="c10 c2">1</span><span class="c2">, ..., T</span><span class="c10 c2">n</span><span class="c2">, [T</span><span class="c10 c2">n+1</span><span class="c2">, â¦, T</span><span class="c10 c2">n+k</span><span class="c2">]) â T</span><span>Â is a subtype of the function type </span><span class="c2">(S</span><span class="c10 c2">1</span><span class="c2">, ..., S</span><span class="c10 c2">n</span><span class="c2">, [S</span><span class="c10 c2">n+1</span><span class="c2">, â¦, S</span><span class="c10 c2">n+m</span><span class="c2">]) â S,</span><span>Â if all of the following conditions are met:</span></p><ol class="c16" start="1"><li class="c9"><span>Either</span></li></ol><ol class="c39" start="1"><li class="c11 c30"><span class="c2">S</span><span>Â is </span><span class="c0">void</span><span>,</span></li><li class="c11 c30"><span>or </span><span class="c2">T</span><span>Â â </span><span class="c2">S</span><span>.</span></li></ol><ol class="c16" start="2"><li class="c9"><span class="c2">k &gt;= m and </span><span>for all </span><span class="c2">i</span><span>Â , 1 &lt;= i &lt;= </span><span class="c2">n+m</span><span>, </span><span class="c2">T</span><span class="c10 c2">i</span><span>Â â </span><span class="c2">S</span><span class="c10 c2">i</span><span>.</span></li></ol><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span>A function type </span><span class="c2">(T</span><span class="c10 c2">1</span><span class="c2">, ..., T</span><span class="c10 c2">n</span><span class="c2">, </span><span class="c2">{</span><span class="c2">T</span><span class="c10 c2">x1</span><span class="c2">Â x</span><span class="c10 c2">1</span><span class="c2">, â¦, T</span><span class="c10 c2">xk</span><span class="c2">Â x</span><span class="c10 c2">k</span><span class="c2">}</span><span class="c2">) â T</span><span>Â is a subtype of the function type </span><span class="c2">(S</span><span class="c10 c2">1</span><span class="c2">, ..., S</span><span class="c10 c2">n</span><span class="c2">, </span><span class="c2">{</span><span class="c2">S</span><span class="c10 c2">y1</span><span class="c2">Â y</span><span class="c10 c2">1</span><span class="c2">, â¦, S</span><span class="c10 c2">ym</span><span class="c2">Â y</span><span class="c10 c2">m</span><span class="c2">}</span><span class="c2">) â S,</span><span>Â if all of the following conditions are met:</span></p><ol class="c16" start="1"><li class="c9"><span>Either</span></li></ol><ol class="c39" start="1"><li class="c11 c30"><span class="c2">S</span><span>Â is </span><span class="c0">void</span><span>,</span></li><li class="c11 c30"><span>or </span><span class="c2">T</span><span>Â â </span><span class="c2">S</span><span>.</span></li></ol><ol class="c16" start="2"><li class="c9"><span>For all </span><span class="c2">i</span><span>Â , 1 &lt;= i &lt;= Â </span><span class="c2">n</span><span>, </span><span class="c2">T</span><span class="c10 c2">i</span><span>Â â </span><span class="c2">S</span><span class="c10 c2">i</span><span>.</span></li><li class="c9"><span class="c2">k &gt;= m</span><span>Â and </span><span class="c2">y</span><span class="c10 c2">i</span><span>Â in </span><span class="c2">{x</span><span class="c10 c2">1</span><span class="c2">, â¦, x</span><span class="c10 c2">k</span><span class="c2">}</span><span class="c2">,</span><span>Â </span><span class="c2">1 &lt;= i &lt;= m.</span></li><li class="c9"><span>For all </span><span class="c2">y</span><span class="c10 c2">i</span><span>Â in </span><span class="c2">{y</span><span class="c10 c2">1</span><span class="c2">, â¦, y</span><span class="c10 c2">m</span><span class="c2">}, y</span><span class="c10 c2">i</span><span class="c2">Â = x</span><span class="c10 c2">j</span><span class="c2">Â =&gt; T</span><span class="c10 c2">j</span><span>Â â </span><span class="c2">S</span><span class="c10 c2">i</span><span class="c2">.</span></li></ol><p class="c8"><span class="c2"></span></p><p class="c13"><span>In addition, the following subtype rules apply:</span></p><p class="c8"><span></span></p><p class="c13"><span class="c2">(T</span><span class="c10 c2">1</span><span class="c2">, ..., T</span><span class="c10 c2">n</span><span class="c2">, []) â T &lt;: (T</span><span class="c10 c2">1</span><span class="c2">, ..., T</span><span class="c10 c2">n</span><span class="c2">) â T.</span></p><p class="c13"><span class="c2">(T</span><span class="c10 c2">1</span><span class="c2">, ..., T</span><span class="c10 c2">n</span><span class="c2">) â T &lt;: (T</span><span class="c10 c2">1</span><span class="c2">, ..., T</span><span class="c10 c2">n</span><span class="c2">, {}) â T.</span></p><p class="c13"><span class="c2">(T</span><span class="c10 c2">1</span><span class="c2">, ..., T</span><span class="c10 c2">n</span><span class="c2">, {}) â T &lt;: (T</span><span class="c10 c2">1</span><span class="c2">, ..., T</span><span class="c10 c2">n</span><span class="c2">) â T.</span></p><p class="c13"><span class="c2">(T</span><span class="c10 c2">1</span><span class="c2">, ..., T</span><span class="c10 c2">n</span><span class="c2">) â T &lt;: (T</span><span class="c10 c2">1</span><span class="c2">, ..., T</span><span class="c10 c2">n</span><span class="c2">, []) â T.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">The naive reader might conclude that, since it is not legal to declare a function with an empty optional parameter list, these rules are pointless. However, the induce Â useful relationships between function types that declare no optional parameters and those that do.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span>A functi</span><span>ons is </span><span>always an instance of some class that implements the class </span><span class="c0">Func</span><span>tion.</span><span>Â All function types are subtypes of </span><span class="c0">Function</span><span>. If a type </span><span class="c2">I </span><span>includes a method named </span><span class="c0">call()</span><span>, and the type of </span><span class="c0">call()</span><span>Â is the function type</span><span class="c2">Â F, </span><span>then</span><span class="c2">Â I </span><span>is considered to be a subtype of </span><span class="c2">F.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c2">Â </span><span class="c0 c2">call </span><span class="c2">is not fully supported in the M2 release.</span></p><p class="c13"><span class="c25">Â </span></p><p class="c8"><span></span></p><a href="#" name="kix.5kehb35oxqwh"></a><h3 class="c13"><a name="h.myhds5lp5ovr"></a><span>Type dynamic</span></h3><p class="c8"><span></span></p><p class="c13"><span>The built-in identifier </span><span class="c0 c5">dynamic</span><span>Â denotes the </span><span class="c2">unknown type.</span><span>Â </span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span>If no static type annotation has been provided the type system assumes the declaration has the type </span><span class="c0 c5">dynamic</span><span>. If a generic type is used but type arguments are not provided, then the type arguments default to the unknown type.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c25">This means that given a generic declaration </span><span class="c25 c2">G&lt;T</span><span class="c1 c25">1</span><span class="c25 c2">, â¦, T</span><span class="c1 c25">n</span><span class="c25 c2">&gt;,</span><span class="c25">Â the type </span><span class="c25 c2">G</span><span class="c25">Â is equivalent to </span><span class="c25 c2">G&lt;dynamic, â¦, dynamic&gt;.</span></p><p class="c8"><span></span></p><p class="c13"><span>Type </span><span class="c0 c5">dynamic</span><span>Â </span><span>has methods for every possible identifier and arity, with every possible combination of named parameters</span><span>. These methods all have </span><span class="c0 c5">dynamic</span><span class="c0">Â </span><span>as their return type, and their formal parameters all have type </span><span class="c0 c5">dynamic</span><span>.</span></p><p class="c13"><span>Type </span><span class="c0 c5">dynamic</span><span class="c0">Â </span><span>has properties for every possible identifier. These properties all have type </span><span class="c0 c5">dynamic</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">From a usability perspective, we want to ensure that the checker does not issue errors everywhere an unknown type is used. The definitions above ensure that no secondary errors are reported when accessing an unknown type. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c12 c2">The current rules say that missing type arguments are treated as if they were the type dynamic. An alternative is to consider them as meaning </span><span class="c12 c0 c2">Object</span><span class="c12 c2">. Â This would lead to earlier error detection in checked mode, and more aggressive errors during static typechecking. For example:</span></p><p class="c8"><span class="c12 c0 c2"></span></p><p class="c13"><span class="c12 c0 c2">(1) typedAPI(G&lt;String&gt; g){...}</span></p><p class="c13"><span class="c12 c0 c2">(2) typedAPI(new G()); </span></p><p class="c8"><span class="c12 c0 c2"></span></p><p class="c13"><span class="c12 c2">Under the alternative rules, (2) would cause a runtime error in checked mode. This seems desirable from the perspective of error localization. However, when a dynamic error is raised at (2), the only way to keep running is rewriting (2) into</span></p><p class="c8"><span class="c12 c0 c2"></span></p><p class="c13"><span class="c12 c0 c2">(3) typedAPI(new G&lt;String&gt;());</span></p><p class="c8"><span class="c12 c0 c2"></span></p><p class="c13"><span class="c12 c2">This forces users to write type information in their client code just because they are calling a typed API. Â We do not want to impose this on Dart programmers, some of which may be blissfully unaware of types in general, and genericity in particular.</span></p><p class="c8"><span class="c12 c2"></span></p><p class="c13"><span class="c12 c2">What of static checking? Surely we would want to flag (2) when users have explicitly asked for static typechecking? Yes, but the reality is that the Dart static checker is likely to be running in the background by default. Engineering teams typically desire a âclean buildâ free of warnings and so the checker is designed to be extremely charitable. Other tools can interpret the type information more aggressively and warn about violations of conventional (and sound) static type discipline.</span></p><p class="c8"><span class="c12 c0 c2"></span></p><p class="c13"><span class="c12 c2">Â </span></p><a href="#" name="id.zh8hu6e5yqli"></a><h3 class="c13"><a name="h.a5hjb7g00phr"></a><span>Type Void</span></h3><p class="c8"><span></span></p><p class="c13"><span>The special type </span><span class="c0 c2 c5">void</span><span>Â may only be used as the return type of a function: it is a compile-time error to use </span><span class="c0 c5">void</span><span>Â in any other context. </span></p><p class="c8"><span></span></p><p class="c13"><span class="c3">For example, as a type argument, or as the type of a variable or parameter</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">Void is not an interface type. </span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">The only subtype relations that pertain to </span><span class="c0 c3 c5">void</span><span class="c3">Â are therefore:</span></p><ol class="c16" start="1"><li class="c9"><span class="c0 c3 c5">void</span><span class="c3">Â &lt;: </span><span class="c0 c3 c5">void</span><span class="c3">(by reflexivity)</span></li><li class="c9"><span class="c3">bottom &lt;: </span><span class="c0 c3 c5">void</span><span class="c3">Â (as bottom is a subtype of all types).</span></li><li class="c9"><span class="c0 c3 c5">void</span><span class="c3">Â &lt;: </span><span class="c0 c3 c5">dynamic</span><span class="c3">Â (as </span><span class="c0 c3 c5">dynamic</span><span class="c3">Â is a supertype of all types)</span></li></ol><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">Hence, the static checker will issue warnings if one attempts to access a member of the result of a </span><span class="c0 c3 c5">void</span><span class="c3">Â method invocation (even for members of </span><span class="c0 c3 c5">null,</span><span class="c3">Â such as </span><span class="c0 c3">==</span><span class="c3">). Â Likewise, passing the result of a </span><span class="c0 c3 c5">void</span><span class="c3">Â method as a parameter or assigning it to a variable will cause a warning unless the variable/formal parameter has type </span><span class="c0 c3 c5">dynamic</span><span class="c3">.</span></p><p class="c8"><span class="c3"></span></p><p class="c13"><span class="c3">On the other hand, it is possible to return the result of a </span><span class="c0 c3 c5">void</span><span class="c3">Â method from within a void method. One can also return </span><span class="c0 c3 c5">null;</span><span class="c3">Â or a value of type </span><span class="c0 c3 c5">dynamic</span><span class="c3">. Returning any other result will cause a type warning. In checked mode, a dynamic type error would arise if a non-null object was returned from a </span><span class="c0 c3 c5">void</span><span class="c3">Â method (since no object has runtime type </span><span class="c0 c3 c5">dynamic</span><span class="c3">).</span></p><p class="c8"><span class="c3"></span></p><p class="c8"><span class="c3"></span></p><a href="#" name="id.nr95v4q1z9z0"></a><h3 class="c13"><a name="h.6kyg74b28ed0"></a><span>Parameterized Types</span></h3><p class="c8"><span></span></p><p class="c13"><span>A </span><span class="c2">parameterized type</span><span>Â is an invocation of a generic type declaration.</span></p><p class="c8"><span></span></p><p class="c13"><span>Let </span><span class="c2">p = G&lt;A</span><span class="c1">1</span><span class="c2">, â¦, A</span><span class="c1">n</span><span class="c2">&gt;</span><span>Â be a parameterized type. </span></p><p class="c8"><span></span></p><p class="c13"><span>It is a static type warning if </span><span class="c2">G</span><span>Â is not an accessible generic type declaration with </span><span class="c2">n</span><span>Â type parameters. It is a static type warning if </span><span class="c2">A</span><span class="c1">i</span><span class="c2">, 1 &lt;= i &lt;= n</span><span>Â  does not denote a type in the enclosing lexical scope.</span></p><p class="c8"><span></span></p><p class="c13"><span>If </span><span class="c2">S</span><span>Â is the static type of a member </span><span class="c2">m</span><span>Â of G, then the static type of the member </span><span class="c2">m</span><span>Â of </span><span class="c2">G&lt;A</span><span class="c1">1</span><span class="c2">, â¦, A</span><span class="c1">n</span><span class="c2">&gt;</span><span>Â is </span><span class="c2">[A</span><span class="c1">1</span><span class="c2">, â¦, A</span><span class="c1">n</span><span class="c2">/T</span><span class="c1">1</span><span class="c2">, â¦, T</span><span class="c1">n</span><span class="c2">]S</span><span>Â where </span><span class="c2">T</span><span class="c1">1</span><span class="c2">, â¦, T</span><span class="c1">n </span><span>are the formal type parameters of </span><span class="c2">G. </span><span>Let </span><span class="c2">B</span><span class="c1">i</span><span class="c2">Â </span><span>be the bounds of </span><span class="c2">T</span><span class="c1">i</span><span class="c2">, 1 &lt;= i &lt;= n. </span><span>It is a static type warning if </span><span class="c2">A</span><span class="c1">i</span><span class="c2">Â </span><span>is not a subtype of </span><span class="c2">[A</span><span class="c1">1</span><span class="c2">, â¦, A</span><span class="c1">n</span><span class="c2">/T</span><span class="c1">1</span><span class="c2">, â¦, T</span><span class="c1">n</span><span class="c2">]B</span><span class="c1">i</span><span class="c2">, 1 &lt;= i &lt;= n.</span></p><p class="c8"><span class="c2"></span></p><p class="c8"><span class="c3"></span></p><a href="#" name="id.93yudg3nk9o1"></a><h4 class="c13"><a name="h.eu4kv2vjewua"></a><span>Actual Type of a Declaration</span></h4><p class="c8"><span class="c3"></span></p><p class="c13"><span>A type </span><span class="c2">T depends on a type parameter U</span><span>Â iff:</span></p><ol class="c16" start="1"><li class="c9"><span class="c2">T</span><span>Â is </span><span class="c2">U.</span></li><li class="c9"><span class="c2">T</span><span>Â is a parameterized type, and one of the type arguments of </span><span class="c2">T</span><span>Â depends on </span><span class="c2">U.</span></li></ol><p class="c8"><span></span></p><p class="c13"><span>Let </span><span class="c2">T</span><span>Â be the declared type of a declaration </span><span class="c2">d,</span><span>Â as it appears in the program source. The </span><span class="c2">actual type</span><span>Â of </span><span class="c2">d</span><span>Â is</span></p><p class="c8"><span></span></p><ol class="c16" start="1"><li class="c9"><span class="c2">[A</span><span class="c1">1</span><span class="c2">, ..., A</span><span class="c1">n</span><span class="c2">/U</span><span class="c1">1</span><span class="c2">, ..., U</span><span class="c1">n</span><span class="c2">]T</span><span>Â if </span><span class="c2">T</span><span>Â depends on type parameters </span><span class="c2">U</span><span class="c1">1</span><span class="c2">, ..., U</span><span class="c1">n</span><span class="c2">,</span><span>Â and </span><span class="c2">A</span><span class="c1">i</span><span>Â is the actual value of </span><span class="c2">U</span><span class="c1">i</span><span class="c2">, 1 &lt;= i &lt;= n.</span></li><li class="c9"><span class="c2">T</span><span>Â otherwise.</span></li></ol><p class="c8"><span class="c3"></span></p><p class="c8"><span class="c3"></span></p><a href="#" name="id.az0dpdfffqt3"></a><h4 class="c13"><a name="h.hegkdje9bscx"></a><span>Least Upper Bounds</span></h4><p class="c8"><span></span></p><p class="c13"><span>Given two interfaces </span><span class="c2">I</span><span>Â and </span><span class="c2">J,</span><span>Â let </span><span class="c2">S</span><span class="c1">I</span><span>Â be the set of superinterfaces of </span><span class="c2">I,</span><span>Â  let </span><span class="c2">S</span><span class="c1">J</span><span>Â be the set of superinterfaces of </span><span class="c2">J</span><span>Â and let</span><span class="c2">Â S = (I </span><img src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=%5Ccup%7B%7D"><span class="c2">S</span><span class="c1">I </span><span class="c2">)</span><img src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=%5Ccap%7B%7D"><span class="c2">Â (J </span><img src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=%5Ccup%7B%7D"><span class="c2">Â S</span><span class="c1">J </span><span class="c2">).</span><span>Â Furthermore, we define </span><span class="c2">S</span><span class="c1">n</span><span class="c2">Â = {T | T </span><img src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=%5Cin%7B%7D"><span class="c2">Â S Â </span><img src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=%5Cwedge%7B%7D"><span class="c2">Â depth(T) =n}</span><span>Â </span><span>for any finite </span><span class="c2">n,</span><span>Â where </span><span class="c2">depth(T)</span><span>Â is the number of steps in the longest inheritance path from </span><span class="c2">T</span><span>Â to </span><span class="c0">Object</span><span>. </span><span>Let </span><span class="c2">q</span><span>Â be the </span><span>larg</span><span>est number</span><span>Â such that </span><span class="c2">S</span><span class="c1">q</span><span>Â has cardinality one</span><span>. The least upper bound of </span><span class="c2">I</span><span>Â and </span><span class="c2">J</span><span>Â is the sole element of </span><span class="c2">S</span><span class="c1">q</span><span>.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c8"><span class="c3"></span></p><p class="c8"><span class="c3"></span></p><a href="#" name="id.o15g7g72qsq"></a><h2 class="c13"><a name="h.lhp7sn5lni0h"></a><span>Reference</span></h2><a href="#" name="id.72xk08vpsgpx"></a><h3 class="c13"><a name="h.h9utggye7amm"></a><span>Lexical Rules</span></h3><p class="c8"><span></span></p><p class="c13"><span>Dart source text is represented as a sequence of Unicode code points normalized to Unicode Normalization Form C. Â This sequence is first converted into a sequence of tokens according to the lexical rules given in this specification. Â At any point in the tokenization process, the longest possible token is recognized.</span></p><p class="c8"><span></span></p><a href="#" name="id.ezhiwl56w9dj"></a><h4 class="c13"><a name="h.huusvrzea3q"></a><span>Reserved Words</span><span>Â </span></h4><p class="c8"><span></span></p><p class="c13"><span>A </span><span class="c2">reserved word </span><span>may not be used as an identifier; it is a compile-time error if a reserved word is used where an identifier is expected.</span></p><p class="c8"><span></span></p><p class="c13"><span class="c0 c5">assert, break, case, catch, class, const, continue, default, do, else, extends, false, final, finally, for, if, in, is, new, null, return, super, switch, this, throw, true, try, var, void, while, with.</span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c13"><span class="c2">Â </span><a href="#" name="id.bptaecjachp1"></a><span class="c2 c5">LETTER</span><span class="c2 c5">:</span><span class="c2"><br> Â  Â  Â &#39;a&#39;..&#39;z&#39;<br> Â  Â | &#39;A&#39;..&#39;Z&#39;<br> Â  Â ;<br><br></span><a href="#" name="id.w2ucufslrxvb"></a><span class="c2 c5">DIGIT:</span><span class="c2"><br> Â  Â  Â &#39;0&#39;..&#39;9&#39;<br> Â  Â ;<br><br></span><a href="#" name="id.4583jo1p24zz"></a><span class="c2 c5">WHITESPACE:</span><span class="c2"><br> Â  Â  Â (&#39;\t&#39; | &#39; &#39; | NEWLINE)+<br> Â  Â ;<br></span></p><a href="#" name="id.itswtk9lwkoq"></a><h4 class="c13"><a name="h.gey5ehc2i2ad"></a><span>Comments</span></h4><p class="c8"><span></span></p><p class="c13"><span>Comments are sections of program text that are used for documentation.</span></p><p class="c13"><span class="c2"><br></span><a href="#" name="id.gl18l17xcban"></a><span class="c2 c5">SINGLE_LINE_COMMENT:</span><span class="c2"><br> Â  Â  Â &#39;//&#39; ~(NEWLINE)* (NEWLINE)?<br> Â  Â ;<br><br></span><a href="#" name="id.ec52omtr1lpp"></a><span class="c2 c5">MULTI_LINE_COMMENT:</span><span class="c2"><br> Â  Â  Â &#39;/*&#39; </span><span class="c2">(MULTI_LINE_COMMENT | ~ &#39;*/&#39;)*</span><span class="c2">Â &#39;*/&#39;<br> Â  Â ;</span></p><p class="c13"><span class="c2 c28">Â  <br></span><span>Dart supports both single-line and multi-line comments. A </span><span class="c2">single line </span><span class="c2">comment</span><span>Â begins with the token //. </span><span class="c24">Everything between </span><span class="c24">// and the</span><span class="c24">Â end of line must be ignored by the Dart compiler unless the comment is a documentation comment. </span></p><p class="c8"><span class="c24"></span></p><p class="c13"><span class="c24">A </span><span class="c24 c2">multi-line comment</span><span class="c24">Â begins with the token /* and ends with the token */. Â Everything between </span><span class="c24">/*</span><span class="c24">Â and </span><span class="c24">*/</span><span class="c24">Â must be ignored by the Dart compiler unless the comment is a documentation comment. Comments may nest.</span><span>Â </span></p><p class="c8"><span></span></p><p class="c13"><span class="c2">Documentation comments</span><span>Â are comments that begin with the </span><span>token</span><span>s /// or Â /**. Documentation comments are intended to be processed by a tool that produces human readable documentation. Below, we refer to any such tool as DartDoc, and owe refer to the output of DartDoc as ``the formatted output&#39;&#39;.</span></p><p class="c8"><span></span></p><p class="c13"><span>The scope of a documentation comment Â always excludes the imported namespace of the enclosing library. Only names declared in the enclosing library are considered in scope within a documentation comment.</span></p><p class="c8"><span></span></p><p class="c13"><span>The scope of a documentation comment immediately preceding the declaration of a class </span><span class="c2">C</span><span>Â is the instance scope of </span><span class="c2">C</span><span>, excluding any names introduced via the import namespace of the enclosing library.</span></p><p class="c8"><span></span></p><p class="c13"><span>The scope of a documentation comment immediately preceding the declaration of a function </span><span class="c2">f</span><span>Â  is the Â scope in force at the very beginning of the body of </span><span class="c2">f</span><span>, Â excluding any names introduced via the import namespace of the enclosing library.</span></p><p class="c8"><span></span></p><p class="c13"><span>Within a documentation comment, text is tokenized. Most tokens have no significance, and will be reproduced verbatim in the formatted output produced by the DartDoc tool. Â A number of tokens have special significance.</span></p><p class="c8"><span></span></p><p class="c13"><span>A blank line indicates that the following text will begin a new paragraph in the formatted output.</span></p><p class="c8"><span></span></p><p class="c13"><span>A token of the form </span><span class="c0">[id]</span><span>Â will be replaced by a link in the formatted output. The link will point at the declaration named </span><span class="c0">id</span><span>. The title of the link will be </span><span class="c0">id</span><span>. It is a static warning if </span><span class="c0">id</span><span>Â does not denote a declaration that available in the Â scope of the documentation comment. If </span><span class="c0">id</span><span>Â is the name of a class, the generated link will point at the class, even if the class has a constructor of the same name.</span></p><p class="c8"><span></span></p><p class="c13"><span>A token of the form </span><span class="c0">[</span><span class="c0 c5">new</span><span class="c0">Â c]</span><span>Â will be replaced by a link in the formatted output. The link will point at the declaration of a constructor named </span><span class="c0">c</span><span>. The title of the link will be </span><span class="c0">c</span><span>. Â It is a static warning if </span><span class="c0">c</span><span>Â does not denote a constructor that available in the Â scope of the documentation comment. </span></p><p class="c8"><span></span></p><p class="c13"><span>A token of the form </span><span class="c0">[:code:]</span><span>Â or </span><span class="c0">`code`</span><span>Â will render code as code in the formatted output.</span></p><p class="c8"><span></span></p><p class="c13"><span>A token of the form </span><span class="c0">*foo</span><span class="c22 c0">1</span><span class="c0">Â â¦ foo</span><span class="c22 c0">k</span><span class="c0">*</span><span>Â or </span><span class="c0">_foo</span><span class="c22 c0">1</span><span class="c0">Â â¦ foo</span><span class="c22 c0">k</span><span class="c0">_</span><span>Â will cause </span><span>foo</span><span class="c22">1</span><span>Â â¦ foo</span><span class="c22">k</span><span>Â to be emphasized in the formatted output.</span></p><p class="c8"><span></span></p><p class="c13"><span>A token of the form </span><span class="c0">**foo</span><span class="c22 c0">1</span><span class="c0">Â â¦ foo</span><span class="c22 c0">k</span><span class="c0">**</span><span>Â or </span><span class="c0">__foo</span><span class="c22 c0">1</span><span class="c0">Â â¦ foo</span><span class="c22 c0">k</span><span class="c0">__</span><span>Â will cause </span><span>foo</span><span class="c22">1</span><span>Â â¦ foo</span><span class="c22">k</span><span>Â to be strongly emphasized in the formatted output.</span></p><p class="c8"><span></span></p><p class="c13"><span>A token of the form </span><span class="c0">[id](uri)</span><span>Â  will be replaced by a link in the formatted output. The link will point at the declaration named </span><span class="c0">id</span><span>Â in </span><span class="c2">L</span><span>. The title of the link will be </span><span class="c0">id</span><span>. It is a static warning if </span><span class="c0">uri</span><span>Â is not the URI of a dart library </span><span class="c2">L</span><span>, or if </span><span class="c0">id</span><span>Â is not a name declared in the exported namespace of </span><span class="c2">L</span><span>. Â If </span><span class="c0">id</span><span>Â is the name of a class, the generated link will point at the class, even if the class has a constructor of the same name.</span></p><p class="c8"><span></span></p><p class="c13"><span>A token of the form </span><span class="c0">[</span><span class="c0 c5">new</span><span class="c0">Â c](uri)</span><span>Â will be replaced by a link in the formatted output. The link will point at the constructor named </span><span class="c0">c</span><span>Â in </span><span class="c2">L</span><span>. The title of the link will be </span><span class="c0">c</span><span>. It is a static warning if </span><span class="c0">uri</span><span>Â is not the URI of a dart library </span><span class="c2">L</span><span>, or if </span><span class="c0">c</span><span>Â is not the name of a constructor of a class declared in the exported namespace of </span><span class="c2">L</span><span>. </span></p><p class="c8"><span></span></p><p class="c13"><span>A token of the form </span><span class="c0">[s](uri)</span><span>Â where </span><span class="c0">s</span><span>Â is a string will be replaced by a link in the formatted output. The link will point at the URI given by </span><span class="c0">uri</span><span>. The title of the link will be the value of the string </span><span class="c0">s</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>A token of the form </span><span class="c0">&lt;uri&gt;</span><span>Â will be replaced by a link in the formatted output. The link will point at the location specified by </span><span class="c0">uri</span><span>.</span></p><p class="c8"><span></span></p><p class="c13"><span>A token of the form </span><span class="c0">## </span><span>indicates that the following text, up to the nearest newline, will appear as a heading in the formatted output. If the line in question ends with </span><span class="c0">##</span><span>, those two characters are elided in the formatted output.</span></p><p class="c8"><span></span></p><p class="c13"><span>A token of the form </span><span class="c0">*</span><span>Â indicates that the following text, up to the nearest blank line, will appear as a bulleted item in the formatted output.</span></p><p class="c8"><span></span></p><p class="c13"><span>A token of the form </span><span class="c0">n.</span><span>Â  where </span><span class="c0">n</span><span>Â is an integer indicates that the following text, up to the nearest blank line, will appear as a numbered item in the formatted output. The number used will be </span><span class="c0">n</span><span>.</span></p><p class="c13"><span>Â </span></p><p class="c8"><span></span></p><p class="c8"><span></span></p><p class="c8"><span class="c18"></span></p><p class="c8"><span></span></p><p class="c13"><span class="c18">Â </span></p><p class="c8"><span class="c18"></span></p><p class="c8"><span class="c18"></span></p><p class="c8"><span class="c18"></span></p><p class="c8"><span></span></p><a href="#" name="id.2yixkvmdnmcn"></a><h3 class="c13"><a name="h.sn1uuf2ffwwd"></a><span>Operator Precedence</span></h3><p class="c8"><span></span></p><p class="c13"><span>Operator precedence is given implicitly by the grammar</span><span>. </span></p><p class="c13"><span class="c3">The following non-normative table may be helpful:</span></p><p class="c8"><span class="c3"></span></p><p class="c8"><span class="c3"></span></p><a href="#" name="3e1735163e9ab0e26e4f6d9e303ecfbaa6c3f943"></a><a href="#" name="0"></a><table cellpadding="0" cellspacing="0" class="c35"><tbody><tr><td class="c17"><p class="c14 c13"><span class="c3">Description</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">Operator</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">Associativity</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">Precedence</span></p></td></tr><tr><td class="c17"><p class="c13 c14"><span class="c3">Unary postfix</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">. , </span><span class="c3">?id</span><span class="c3">, e++, e--, e1[e2], e1(),</span><span class="c3">Â ()</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">None</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">15</span></p></td></tr><tr><td class="c17"><p class="c14 c13"><span class="c3">Unary prefix</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">-e, !e, ~e, ++e, --e</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">None</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">14</span></p></td></tr><tr><td class="c17"><p class="c14 c13"><span class="c3">Multiplicative</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">*, /, ~/, %</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">Left</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">13</span></p></td></tr><tr><td class="c17"><p class="c14 c13"><span class="c3">Additive</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">+, -</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">Left</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">12</span></p></td></tr><tr><td class="c17"><p class="c14 c13"><span class="c3">Shift</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">&lt;&lt;, &gt;&gt;</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">Left</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">11</span></p></td></tr><tr><td class="c17"><p class="c14 c13"><span class="c3">Relational</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">&lt;, &gt;, &lt;=, &gt;=, </span><span class="c3 c5">as</span><span class="c3">, </span><span class="c3 c5">is</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">None</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">10</span></p></td></tr><tr><td class="c17"><p class="c14 c13"><span class="c3">Equality</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">==, !=</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">None</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">9</span></p></td></tr><tr><td class="c17"><p class="c14 c13"><span class="c3">Bitwise AND</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">&amp;</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">Left</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">8</span></p></td></tr><tr><td class="c17"><p class="c14 c13"><span class="c3">Bitwise XOR</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">^</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">Left</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">7</span></p></td></tr><tr><td class="c17"><p class="c14 c13"><span class="c3">Bitwise Or</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">|</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">Left</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">6</span></p></td></tr><tr><td class="c17"><p class="c14 c13"><span class="c3">Logical And</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">&amp;&amp;</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">Left</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">5</span></p></td></tr><tr><td class="c17"><p class="c14 c13"><span class="c3">Logical Or</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">||</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">Left</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">4</span></p></td></tr><tr><td class="c17"><p class="c14 c13"><span class="c3">Conditional</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">e1? e2 : e3</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">None</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">3</span></p></td></tr><tr><td class="c17"><p class="c14 c13"><span class="c3">Cascade</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">..</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">Left</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">2</span></p></td></tr><tr><td class="c17"><p class="c14 c13"><span class="c3">Assignment</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">=, *=, /=, +=, </span><span class="c3">=+</span><span class="c3">, ~=, %=, &lt;&lt;=, &gt;&gt;&gt;=, &gt;&gt;=, &amp;=, ^=</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">Right</span></p></td><td class="c17"><p class="c14 c13"><span class="c3">1</span></p></td></tr></tbody></table><p class="c8"><span class="c3"></span></p><p class="c8"><span class="c3"></span></p><p class="c8"><span></span></p><h2 class="c13"><a name="h.a49aki5jh8v5"></a><span>Appendix: Naming Conventions</span></h2><p class="c8"><span></span></p><p class="c13"><span class="c3">The following naming conventions are customary in Dart programs.</span></p><p class="c8"><span class="c3"></span></p><ol class="c16" start="1"><li class="c9"><span class="c3">The names of compile time constant variables never use lower case letters. If they consist of multiple words, those words are separated by underscores. Examples: PI, </span><span class="c3">I_AM_A_CONSTANT.</span></li><li class="c9"><span class="c3">The names of functions (including getters, setters, methods and local or library functions) and non-constant variables begin with a lowercase letter. If the name consists of multiple words, each word (except the first) begins with an uppercase letter. No other uppercase letters are used. Examples: camlCase, , dart4TheWorld. </span></li><li class="c9"><span class="c3">The names of types (including classes, type variables and type aliases) begin with an uppercase letter. If the name consists of multiple words, each word begins with an uppercase letter. No other uppercase letters are used. Examples: CamlCase, Dart4TheWorld.</span></li><li class="c9"><span class="c3">The names of type variables are short (preferably single letter). Examples: T, S, K, V , E.</span></li><li class="c9"><span class="c3">The names of libraries or library prefixes never use upper case letters. If they consist of multiple words, those words are separated by underscores. Example: </span><span class="c3">my_favorite_library</span><span class="c3">.</span></li></ol><p class="c8"><span class="c3"></span></p><p class="c8"><span class="c3"></span></p><p class="c8"><span></span></p></div><div id="footer"><span>Published by <a target="_blank" title="Learn more about Google Drive" href="//docs.google.com/">Google Drive</a></span></div></body></html>